## 1 含义

1. 简单来说，秒杀就是**在同一时刻大量请求争夺购买同一商品并完成交易的过程**。
2. 从架构角度来看，秒杀系统本质上是一个**高性能**、**高一致**、**高可用**的系统，要解决的两个核心问题是**并发读**和**并发写**。

## 2 架构设计

### 2.1 高性能

1. 秒杀涉及高读和高写的支持，如何支持高并发，如何抵抗高 QPS，核心优化理念为：
   1. **高读就是尽量少读或读少**。
   2. **高写就是数据拆分**。
2. 高性能的实现可以从**动静分离**、**热点优化**、**服务器端性能优化**三种方法。

#### 2.1.1 动静分离

1. 大家可能会注意到，秒杀过程中我们是不需要刷新整个页面的，只有时间在不停地跳动，这是因为一般都会**对大流量的秒杀系统做静态化改造**，即**数据意义上的动静分离**。
2. 动静分离可以**提高单次请求的效率**，**减少没必要的请求**，让系统快起来。
3. 动静分离可以分为三步，分别为**数据拆分**、**静态缓存**、**数据整合**。

##### 2.1.1.1 数据拆分

1. 动静分离的首要目的是**将动态页面改造成适合缓存的静态页面**，因此第一步就是**分离出动态数据**，动态数据和静态数据的主要区别是**是否和 URL**、**浏览者**、**浏览时间**、**地域相关**，以及**是否含有 Cookie 等私密数据**，例如：
   1. 很多媒体类的网站，某一篇文章的内容不管是谁访问，他都是一样的，这就是一个典型的静态数据。
   2. 如果我们现在访问淘宝的首页，每个人看到的页面可能都是不一样的，因为淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。
2. 而针对秒杀系统，对动态数据的分离可以从以下两个方面进行：
   1. **用户**：
      1. 用户身份信息包括登录状态以及登录画像等，相关要素可以单独拆分出来，通过动态请求进行获取。
      2. 与之相关的推荐信息，可以通过异步方式进行加载。
   2. **时间**：
      1. 秒杀时间是由服务端统一管控的，可以通过动态请求进行获取。

##### 2.1.1.2 静态缓存

分离出动态数据和静态数据之后，第二步就是**将静态数据进行合理的缓存**，**由此衍生出两个问题**：

1. **怎么缓存**。
2. **哪里缓存**。

###### 2.1.1.2.1 怎么缓存

1. 静态化改造的一个特点是**直接缓存整个 HTTP 连接而不是仅仅缓存静态数据**，如此一来，**Web 代理服务器根据请求 URL**，**可以直接取出对应的响应体然后返回**，**响应过程无需重组 HTTP 协议**，**也无需解析 HTTP 请求头**。
2. 作为缓存键，**URL 唯一化是必不可少的**，只是**对于商品系统**，**URL 天然可以基于商品 ID 来进行唯一识别的**，比如淘宝的`https://item.taobao.com/item.htm?id=xxxx`。

###### 2.1.1.2.2 哪里缓存

静态数据缓存可以有三种方式：

1. **浏览器**：
   1. **浏览器当然是第一选择**，但是**用户的浏览器是不可控的**，**主要体现在如果用户不主动刷新**，**系统很难主动地把消息推送给用户**，这样可能**会导致用户端在很长一段时间内看到的信息都是错误的**，**对于秒杀系统**，**保证缓存可以在秒级时间内失效是不可获取的**。
2. **服务端**：
   1. **服务端主要进行动态逻辑计算及加载**，**本身并不擅长处理大量连接**，**每个连接消耗内存较多**。
   2. 同时，**Servlet 容器解析 HTTP 较慢**，**容易侵占逻辑计算资源**。
   3. 另外，**静态数据下沉至此也会拉长请求路径**。
3. **CDN**：
   1. **静态数据通常缓存在 CDN**，**其本身更擅长处理大并发的静态文件请求**，**既可以做到主动失效**，**又离用户尽可能近**，**同时规避 Java 语言层面的弱点**。
   2. 需要注意的是，上 CDN 有以下几个问题需要解决：
      1. **失效问题**：任何一个缓存应该都是有时效的，尤其对于一个秒杀场景，所以系统**需要保证全国各地的 CDN 在秒级时间内失效掉缓存信息**，这实际对 CDN 的失效系统要求是很高的。
      2. **命中率问题**：**高命中是缓存系统最为核心的性能要求**，不然缓存就失去了意义，如果**将数据放到全国各地的 CDN**，势必**会导致请求命中同一个缓存的可能性降低**，那么缓存命中率就成了一个问题。
   3. 因此，将数据放到全国所有的 CDN 节点是不太现实的，失效问题、命中率问题都会面临比较大的挑战，更为可行的做法是**选择若干 CDN 节点进行静态化改造**，节点的选取通常需要满足以下几个条件：
      1. **临近访问量集中的地区**。
      2. **距离主站较远的地区**。
      3. **节点与主站间网络质量良好的地区**。
   4. 基于以上因素，**选择 CDN 的二级缓存比较合适**，因为**二级缓存数量偏少**，**容量也更大**，**让用户的请求先访问 CDN 二级缓存**，**如果没命中再回源站获取数据**，**访问量相对集中**，这样就**可以较好解决缓存的失效问题以及命中率问题**，**是当前比较理想的一种 CDN 化方案**，部署方式如下图所示：![图片](https://notebook.ricear.com/media/202108/2021-08-15_1603590.40171835048846494.png)

##### 2.1.1.3 数据整合

分离出动态数据和静态数据之后，前端如何组织数据页就是一个新的问题，主要在于**动态数据的加载处理**，通常有两种方案：

1. **ESI**（Edge Side Includes）：
   1. **Web 代理服务器请求动态数据**，并**将动态数据插入到静态页面中**，**用户看到时已经是一个完整的页面**。
   2. 这种方式**对服务端性能要求高**，但**用户体验好**。
2. **CSI**（Client Side Include）：
   1. **Web 代理服务器只返回静态页面**，**前端单独发起一个异步 JS 请求动态数据**，这种方式**对服务端性能友好**，但**用户体验稍差**。

##### 2.1.1.4 总结

动静分离对于性能的提升，抽象起来只有两点，一是**数据要尽量少**，**以便减少没必要的请求**；二是**路径要尽量短**，**以便提高单次请求的效率**，具体方法其实就是基于这个大方向进行的。

#### 2.1.2 热点优化

1. 我们一定要关注热点，因为热点会对系统产生一系列影响：
   1. **热点请求会大量占用服务器处理资源**，如果这个热点请求还是**没有价值的无效请求**，那么**对系统资源来说完全是浪费**，即使这些热点是**有效的请求**，我们也**要识别出来做针对性的优化**，从而**用更低的代价来支撑这些热点请求**。
2. 热点分为**热点操作**和**热点数据**两个方面：
   1. **热点操作**：
      1. 例如**大量的刷新页面**、**大量的添加购物车**、**双十一零点大量的下单**等都属于此类操作。
   2. **热点数据**：
      1. 用户的热点请求对应的数据。
3. 热点数据的处理一般分为三步，分别为**热点识别**、**热点隔离**、**热点优化**。

##### 2.1.2.1 热点识别

热点数据分为**静态热点数据**和**动态热点数据**两种：

1. **静态热点数据**：

   1. 就是**能够提前预测的热点数据**。
   2. 大促前夕，可以**根据大促的行业特点**、**活动商家等维度信息分析出热点商品**，**或者通过卖家报名的方式提前筛选**。
   3. 另外，还可以**通过技术手段提前预测**，例如**对买家每天访问的商品进行大数据计算**，然后**统计出 TopN 的商品**，即可**视为热点商品**。
2. **动态热点数据**：

   1. 就是**不能被提前预测到的**，**系统在运行过程中临时产生的热点数据**。
   2. **冷热数据往往是随实际业务场景发生交替变化的**，尤其是如今直播卖货模式的兴起，带货商临时做一个广告，就有可能导致一件商品在短时间内被大量购买，由于**此类商品日常访问较少**，**即使在缓存系统中一段时间后也会被逐出或过期掉**，**甚至在 DB 中也是冷数据**，**瞬时流量的涌入**，往往**导致缓存被[击穿](https://notebook.ricear.com/project-37/doc-811)**，**请求直接到达 DB**，**引发 DB 压力过大**。
   3. 因此秒杀系统需要**实现热点数据的动态发现能力**，一个常见的实现思路是：
      1. **异步采集交易链路各个环节的热点 `key` 信息**，如 Nginx 采集访问 URL 或 Agent 采集热点日志（一些中间件本身已具备热点发现能力），**提前识别潜在的热点数据**。
      2. **聚合分析热点数据**，**达到一定规则的热点数据**，**通过订阅分发推送到链路系统**，**各系统根据自身需求决定如何处理热点数据**，**或限流或缓存**，**从而实现热点保护**。
   4. 需要注意的是：
      1. **热点数据采集最好采用异步方式**，一方面**不会影响业务的核心交易链路**，一方面**可以保证采集的通用性**。
      2. **热点发现最好做到秒级实时**，**这样动态发现才有意义**，实际上也是**对核心节点的数据采集和分析能力提出了较高的要求**。

##### 2.1.2.2 热点隔离

热点数据识别出来之后，第一原则就是**将热点数据隔离出来**，不要让 1% 影响到另外的 99%，可以基于以下几个层次实现热点隔离：

1. **业务隔离**：
   1. 秒杀作为一种营销活动，卖家需要单独报名，从技术上来说，系统**可以提前对已知热点做缓存预热**。
2. **系统隔离**：
   1. **系统隔离是运行时隔离**，**通过分组部署和另外 99% 进行分离**。
   2. 另外，**秒杀也可以申请单独域名**，**入口层就让请求落到不同的集群中**。
3. **数据隔离**：
   1. 秒杀数据作为热点数据，**可以启动单独的缓存集群或者 DB 服务组**，**从而更好的实现横向或纵向能力扩展**。

##### 2.1.2.3 热点优化

热点数据隔离之后，也就方便对这 1% 的请求做针对性的优化，优化方式主要有以下两种：

1. **缓存**：**热点缓存是最为有效的办法**，**如果热点数据做了动静分离**，**那么可以长期缓存静态数据**。
2. **限流**：**流量限制更多是一种保护机制**，需要注意的是，**各服务要时刻关注请求是否触发[限流](https://notebook.ricear.com/project-46/doc-830)并及时进行 `review`**。

#### 2.1.3 系统优化

对于一个软件系统，提高性能可以有很多种手段，如**提升硬件水平**、**调优 JVM 性能**，这里主要关注代码层面的性能优化：

1. **减少序列化**：
   1. **减少 Java 中的序列化操作可以很好的提升系统性能**。
   2. **序列化大部分是在 RPC 阶段发生**，因此**应该尽量减少 RPC 调用**，**一种可行的方案是将多个关联性较强的应用进行合并部署**，从而**减少不同应用之间的 RPC 调用**。
2. **直接输出流数据**：
   1. **只要涉及字符串的 I/O 操作**，**无论是磁盘 I/O 还是网络 I/O**，**都比较耗费 CPU 资源**，**因为字符需要转换成字节**，**而这个转换又必须查表编码**。
   2. 所以**对于常用数据**，比如静态字符串，推荐**提前编码成字节并缓存**，**具体到代码层面就是通过 `outputStream()` 类函数从而减少数据的编码转换**。
   3. 另外，**热点方法 `toString()` 不要直接调用 `reflectionToString()` 实现**，**推荐直接硬编码**，并且**只打印基础要素和核心要素**。
3. **裁剪日志异常堆栈**：
   1. 无论是外部系统异常还是应用本身异常，都会有堆栈打出，超大流量下，**频繁的输出完整堆栈**，只**会加剧系统当前负载**，**可以通过日志配置文件控制异常堆栈输出的深度**。
4. **去组件框架**：
   1. 极致优化要求下，**可以去掉一些组件框架**，比如去掉传统的 MVC 框架，直接使用 Servlet 处理请求，这样**可以绕过一大堆复杂且用处不大的处理逻辑**，**节省毫秒级的时间**，当然，这**需要合理评估我们对框架的依赖程度**。

#### 2.1.4 总结

1. **性能优化需要一个基准值**，所以**系统还需要做好应用基线**（何时性能突然下降）、**成本基线**（去年大促用了多少机器）、**链路基线**（核心流程发生了哪些变化），**通过基线持续关注系统性能**，**促使系统在代码层面持续提升编码质量**、**业务层面及时下调不合理调用**、**架构层面不断优化改进**。

### 2.2 一致性

1. 秒杀系统中，**库存是个关键数据**，卖不出去是个问题，超卖更是个问题。
2. **秒杀场景下的一致性问题**，**主要就是库存扣减的准确性问题**。

#### 2.2.1 减库存的方式

电商场景下的购买过程一般分为两步，分比为**下单**和**扣款**，**提交订单即为下单**，**支付订单即为付款**，基于此设定，减库存一般有一下几种方式：

1. **下单减库存**：
   1. **买家下单后**，**扣减商品库存**。
   2. 下单减库存是**最简单的减库存方式**，也是**控制最为精确**的一种。
2. **付款减库存**：
   1. **买家下单后**，并**不立即扣减库存**，而是**等到付款后才真正扣减库存**。
   2. 因为付款时才减库存，**如果并发比较高**，**可能出现买家下单后付不了款的情况**，**因为商品已经被其他人买走了**。
3. **预扣库存**：
   1. 这种方式**相对复杂一些**，**买家下单后**，**库存为其保留一定的时间**（如 15 分钟），**超过这段时间**，**库存自动释放**，**释放后其他买家可以购买**。

#### 2.2.2 减库存的问题

##### 2.2.2.1 下单减库存

###### 2.2.2.1.1 优点

1. **用户体验最好**。
2. 下单减库存是**最简单的减库存方式**，也是**控制最精确**的一种。
3. **下单时可以直接通过数据库事务机制控制商品库存**，所以**一定不会出现已下单却付不了款的情况**。

###### 2.2.2.1.2 缺点

1. **可能卖不出去**。
2. 正常情况下，买家下单后付款概率很高，所以不会有太大问题，但有一种场景例外，就是**当卖家参加某个促销活动时**，**竞争对手通过恶意下单的方式将该商品全部下单**，**导致库存清零**，那么这**就不能正常售卖了**，要知道，**恶意下单的人是不会真正付款的**，这正是下单减库存的不足之处。

##### 2.2.2.2 付款减库存

###### 2.2.2.2.1 优点

1. **一定实际售卖**。
2. 下单减库存可能导致恶意下单，从而影响卖家的商品销售，**付款减库存由于需要付出真金白银**，**可以有效避免**。

###### 2.2.2.2.2 缺点

1. **用户体验差**。
2. **用户下单后**，**不一定会实际付款**，假设有 100 件商品，就可能出现 200 人下单成功的情况，因为下单时不会减库存，所以也就**可能出现下单成功数远远超过真正库存数的情况**，这**尤其会发生在大促的热门商品上**，如此一来就**会导致很多买家下单成功后却付不了款**，**购物体验自然是比较差的**。

##### 2.2.2.3 预扣库存

###### 2.2.2.3.1 优点

1. **缓解了以上两种方式的问题**，预扣库存**实际就是下单减库存和付款减库存两种方式的结合**，**将两次操作进行了前后关联**，**下单时预扣库存**，**付款时释放库存**。

###### 2.2.2.3.2 缺点

1. 并**没有彻底解决以上问题**，比如针对恶意下单的场景，虽然可以把有效付款时间设置为 15 分钟，但恶意买家完全可以在 15 分钟之后再次下单。

#### 2.2.3 实际如何减库存

1. 业界最常用的减库存方案是[预扣库存](#2-2-2-3-预扣库存)，但是预扣库存还需要解决下面两个问题：
   1. **解决恶意下单问题**，**保证商品卖得出去**：
      1. 恶意下单的解决方案主要还是**结合安全和反作弊措施来制止**，例如：
         1. **识别频繁下单不付款的买家并进行打标**，这样**可以在打标买家下单时不减库存**。
         2. **为大促商品设置单人最大购买件数**，**一人最多只能买 $N$ 件商品**。
         3. **对重复下单不付款的行为进行次数限制阻断**。
   2. **避免超卖**：
      1. 库存超卖的情况实际分为两种：
         1. 对于**普通商品**，**秒杀只是一种大促手段**，**即使库存超卖**，**商家也可以通过补货来解决**。
         2. 对于一些**其他商品**，**秒杀作为一种营销手段**，**完全不允许库存为负**，也就是**在数据一致性上**，需要**保证大并发请求时数据库中的库存字段值不能为负**，一般有以下方案：
            1. **通过事务判断**，**保证减后库存不能为负**，**否则就会滚**。
            2. 直接**设置数据字段类型为无符号整数**，这样**一旦库存为负就会在执行 SQL 时报错**。
            3. **使用 CASE WHEN 判断语句**：

               ```sql
               UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory - xxx ELSE inventory END;
               ```

#### 2.2.4 一致性性能的优化

**库存是个关键数据**，**更是个热点数据**，对系统来说，热点的实际影响就是**高读**和**高写**，也是秒杀场景下最为核心的一个技术难题。

##### 2.2.4.1 高并发读

1. 秒杀场景解决高并发读的问题，关键在于**分层校验**，即**在读链路时**，**只进行不影响性能的检查操作**，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求等，而**不做一致性校验等容易引发瓶颈的操作**，**直到写链路时**，**才对库存做一致性检查**，**在数据层保证最终准确性**。
2. 因此，**在分层校验设定下**，**系统可以采用分布式缓存甚至 LocalCache 来抵抗高并发读**，即**允许读场景下一定的脏数据**，这样**只会导致少量原本无库存的下单请求被误认为是有库存的**，**等到真正写数据时再保证最终一致性**，**由此做到高可用和一致性之间的平衡**。
3. 实际上，分层校验的核心思想是**不同层次尽可能过滤掉无效请求**，**只在漏斗最末端进行有效处理**，从而**缩短系统瓶颈的影响路径**。

##### 2.2.4.2 高并发写

高并发写的优化方式有两种，一种是**更换 DB 选型**，一种是**优化 DB 性能**。

###### 2.2.4.2.1 更换 DB 选型

秒杀商品和普通商品的减库存是有差异的，核心区别在于**数量级小**、**交易时间短**，因此：

1. **如果减库存逻辑非常单一的话**，比如没有复杂的 SKU 库存和总库存这种联动关系的话，**可以直接在一个带有持久化功能的缓存中进行减库存操作**，比如 Redis。
2. **如果有比较复杂的减库存逻辑**，或者**需要使用到事务**，那**就必须在数据库中完成减库存操作**。

> 什么是 SKU？
>
> 1. SKU，全称为 Stock Keeping Unit，即**库存单元**，为**库存管理中的最小可用单元**，例如纺织品中一个 SKU 通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个 SKU。
> 2. **当一种商品的品牌、型号、配置等属性与其他商品存在不同时**，**就是一个不同的最小存货单元**。
> 3. **最小存货单元可以区分不同商品销售的最小单元**，**是科学管理商品的采购**、**销售**、**物流和财务管理以及 POS 和 MIS 系统的数据统计的需求**，**通常对应一个管理信息系统的编码**。

###### 2.2.4.2.2 优化 DB 性能

1. 库存数据落地到数据库实现其实是**一行存储 MySQL**，因此**会有大量线程来竞争 InnoDB 行锁**，但**并发越高**、**等待线程就会越多**，**TPS 下降**、**RT 上升**，**吞吐量会受到严重影响**。
2. 解决这种并发锁的问题，有两种办法：

   1. **应用层排队**：

      1. **通过缓存加入集群[分布式锁](https://notebook.ricear.com/project-37/doc-809)**，**从而控制集群对数据库同一行记录进行操作的并发度**，**同时也能控制单个商品占用数据库连接的数量**，**防止热点商品占用过多的数据库连接**。
   2. **数据层排队**：

      1. **应用层排队是有损性能的**，**数据层排队是最为理想的**，业界中，阿里的数据库团队开发了针对 InnoDB 层上的补丁，**可以基于 DB 层对单行记录做并发排队**，**从而实现秒杀场景下的定制优化**。

         > 1. 需要注意的是**排队和锁竞争是有区别的**，**InnoDB 的死锁检测**，**以及 MySQL Server 和 InnoDB 的切换都是比较消耗性能的**。
         > 2. 高并发性能指标：
         >    1. **QPS**：
         >       1. 全称为 Queries Per Second，即**每秒查询数**，**是一台服务器每秒能够响应的查询次数**，**是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准**，也即是**最大吞吐能力**。
         >    2. **TPS**：
         >       1. 全称为Transaction Per Second，即**每秒事务数**。
         >       2. 一个事务是指**一个客户机向服务器发送请求然后服务器作出响应的过程**，**客户机在发送请求时开始计时**，**收到服务器响应后结束计时**，**以此来计算使用的时间和完成的事务个数**。
         >       3. QPS基本类似于TPS，但不同的是**对于一个页面的一次访问**，**形成一个TPS**，**但一次页面请求**，**可能产生多次对服务器的请求**，**服务器对这些请求**，**计入QPS之中**，例如，访问一个页面会请求服务器3次，则一次访问产生1个T，3个Q。
         >    3. **RT**：
         >       1. 全称为Response Time，即**响应时间**，是指**执行一个请求从开始到最后收到响应数据所花费的总体时间**，即**从客户端发起请求到收到服务器响应结果的时间**。
         >

##### 2.2.4.3 总结

高读和高写的两种处理方式大相径庭，**读请求的优化空间要大一些**，而**写请求的瓶颈一般都在存储层**，**优化思路的本质还是基于 CAP 理论做平衡**。

#### 2.2.5 总结

当然，减库存还有很多细节问题，例如**预扣的库存超时后如何进行回补**，**第三方支付如何保证减库存和付款时的状态一致性**，这些也是很大的挑战。

### 2.3 高可用

盯过**秒杀流量监控**的话，会发现他**不是一条蜿蜒而起的曲线**，**而是一条挺拔的直线**，这是因为**秒杀请求高度集中于某一特定的时间点**，这样一来就**会造成一个特别高的零点峰值**，而**对资源的消耗也几乎是瞬时的**，所以**秒杀系统的可用性保护是不可或缺的**。

#### 2.3.1 流量削峰

1. 对于秒杀的场景，最终能够抢到商品的人数是固定的，无论 100 人和 10000 人参加结果都是一样的，即**有效请求额度是有限的**，**并发度越高**，**无效请求也就越多**。
2. 但秒杀作为一种商业营销手段，活动开始之前是希望有更多的人来刷页面，只是**真正开始后**，**秒杀请求不是越多越好**。
3. 因此**系统可以设计一些规则**，**人为的延缓秒杀请求**，**甚至可以过滤掉一些无效请求**。
4. 流量削峰主要有**答题**、**排队**、**过滤**三种方法。

##### 2.3.1.1 答题

1. 早期秒杀只是简单的点击秒杀按钮，后来才增加了答题，主要是**提升购买的复杂度**，**达到以下两个目的**：
   1. **防止作弊**：
      1. 早期秒杀器比较猖獗，**存在恶意买家或竞争对手使用秒杀器扫货等情况**，**商家没有达到营销的目的**，所以**增加答题来进行限制**。
   2. **延缓请求**：
      1. **零点流量的起效时间是毫秒级的**，**答题可以人为拉长峰值下单的时长**，**由之前的 $< 1s$ 延长到 $< 10s$**，**这个时间对于服务端非常重要**，**会大大减轻高峰期并发压力**。
      2. 另外，由于**请求具有先后顺序**，**答题后置的请求到来时可能已经没有库存了**，因此**根本无法下单**，此阶段**落到数据层真正的写也就非常有限了**。
2. 需要注意的是，**答题除了做正确性验证**，**还需要对提交时间做验证**，比如 $< 1s$ 人为操作的可能性就很小，**可以进一步防止机器答题的情况**。
3. 答题目前已经使用非常普遍了，本质是**通过在入口层削减流量**，**从而让系统更好地支撑瞬时峰值**。

##### 2.3.1.2 排队

1. **最为常见的削峰方案是使用消息队列**，**通过把同步的直接调用转换成异步的间接推送缓冲瞬时流量**。
2. 除了消息队列，类似的排队方案还有很多，例如：
   1. **线程池加锁等待**。
   2. **本地内存蓄洪等待**。
   3. **本地文件序列化写**，**再顺序读**。
3. 排队方式的弊端也是显而易见的，主要有两点：
   1. **请求积压**：
      1. **流量高峰如果长时间持续**，**达到了队列的水位上限**，**队列同样会被压垮**，这样**虽然保护了下游系统**，**但是和请求直接丢弃也没多大区别**。
   2. **用户体验**：
      1. **异步推送的实时性和有序性自然是比不上同步调用的**，由此**可能出现请求先发后至的情况**，**影响部分敏感用户的购物体验**。
4. 排队本质是**在业务层将一步操作转变成两步操作**，**从而起到缓冲的作用**，但**鉴于此种方式的弊端**，**最终还是要基于业务量级和秒杀场景做出妥协和平衡**。

##### 2.3.1.3 过滤

1. 过滤的核心结果在于**分层**，通过**在不同层次过滤掉无效请求**，**达到数据读写的精准触发**。
2. 常见的过滤主要有以下几层：
   1. **读限流**：**对读请求做限流保护**，**将超出系统承载能力的请求过滤掉**。
   2. **读缓存**：**对读请求做数据缓存**，**将重复的请求过滤掉**。
   3. **写限流**：**对写请求做限流保护**，**将超出系统承载能力的请求过滤掉**。
   4. **写校验**：**对写请求做一致性校验**，**只保留最终的有效数据**。
3. 过滤的核心目的是**通过减少无效请求的数据 IO**，**保障有效请求的 IO 性能**。

##### 2.3.1.4 总结

1. 系统可以**通过入口层的答题**、**业务层的排队**、**数据层的过滤达到流量削峰的目的**，**本质是在寻求商业诉求与架构性能之间的平衡**。
2. 另外，新的削峰手段也层出不穷，**以业务切入居多**，比如**零点大促时同步发放优惠券或发起抽奖活动**，**将一部分流量分散到其他系统**，**这样也能起到削峰的作用**。

#### 2.3.2 Plan B

1. 当**一个系统面临持续的高峰流量时**，其实是**很难单靠自身调整来恢复状态**的，**日常运维没有人能够预估所有情况**，**意外总是无法避免**，**为了保证系统的高可用**，**必须设计一个 Plan B 方案来进行兜底**。
2. **高可用建设**，其实**是一个系统工程**，**贯穿在系统建设的整个生命周期**，具体来说，系统的高可用建设涉及**架构阶段**、**编码阶段**、**测试阶段**、**发布阶段**、**运行阶段**、以及**故障发生时**：
   1. **架构阶段**：**考虑系统的可扩展性和容错性**，**避免出现单点问题**，例如多地单元化部署，即使某个 IDC 甚至地市出现故障，仍不会影响系统运转。
   2. **编码阶段**：**保证代码的健壮性**，例如 RPC 调用时，设置合理的超时退出机制，防止被其他系统拖垮，同时也要对无法预料的返回错误进行默认的处理。
   3. **测试阶段**：**保证 CI 的覆盖度以及 Sonar 的容错率**，**对基础质量进行二次校验**，**并定期生产出整体质量的趋势报告**。
   4. **发布阶段**：系统部署最容易暴露错误，因此**要有前置的 `checklist` 模板**、**中置的上下游周知机制以及后置的回滚机制**。
   5. **运行阶段**：系统多数时间处于运行态，最重要的是**运行时的实时监控**，**及时发现问题**、**准确报警并能提供详细数据**，**以便排查问题**。
   6. **故障发生**：首要目标是**及时止损**，**防止影响面扩大**，然后**定位原因**、**解决问题**，最后**恢复服务**。![图片](https://cdn.jsdelivr.net/gh/wliduo/CDN@1.1/2019/11/20191121002.png)
3. 对于日常运维而言，**高可用更多的是针对运行阶段而言的**，此阶段**需要额外进行加强建设**，主要有以下几种手段：
   1. **预防**：**建立常态压测体系**，**定期对服务进行单点压测以及全链路压测**，**摸排水位**。
   2. **管控**：**做好线上运行的降级**、**限流和熔断保护**，需要注意的是，无论是限流、降级还是熔断，**对业务都是有损的**，所以在**进行操作前**，**一定要和上下游业务确认好再进行**，就拿限流来说，哪些业务可以限、什么情况下限、限流时间多长、什么情况下进行恢复，都要和业务方反复确认。
   3. **监控**：**建立性能基线**，**记录性能的变化趋势**，**建立报警体系**，**发现问题及时预警**。
   4. **恢复**：**遇到故障能够及时止损**，**并提供快速的数据订正工具**，**不一定要好**，**但一定要有**。
4. 在系统建设的整个生命周期中，每个环节中都有可能犯错，甚至有些环节犯的错，后面是无法弥补的或者成本极高的，所以**高可用是一个系统化工程**，**必须放到整个生命周期中进行全面考虑**，同时**考虑服务的增长性**，**高可用更需要长期规划并进行体系化建设**。

#### 2.3.3 总结

1. 高可用其实是在说**稳定性**，稳定性是一个**平时不重要**，但**出了问题就要命的事情**，然而他的落地又是一个问题，**平时业务发展良好**，**稳定性建设就会降级给业务让路**。
2. 解决这个问题必须**在组织上有所保障**，比如**让业务负责人背上稳定性绩效指标**，同时**在部门中建立稳定性建设小组**，**小组成员由每条线的核心力量兼任**，**绩效由稳定性负责人来打分**，这样就可以**把体系化的建设任务落实到具体的业务系统中**了。

### 2.4 总结

1. 一个秒杀系统的设计，**可以根据不同级别的流量**，**由简单到复杂打造出不同的架构**，**本质是各方面的取舍和权衡**。
2. 本文并**没有涉及具体的选型方案**，因为这些**对于架构来说并不重要**，做微架构师，应该时刻提醒自己主线是什么。
3. 本文涉及到的秒杀系统设计的提纲如下图所示：![图片](https://notebook.ricear.com/media/202108/2021-08-16_1715440.19526252872712335.png)

## 参考文献

1. [秒杀系统的设计思考](https://note.dolyw.com/distributed/01-Design-Thinking.html)。
2. [秒杀系统设计(二) 高性能 01-动静分离与热点缓存](https://zhouj000.github.io/2018/10/15/SecKill-System-2)。
3. [存货单位](https://zh.wikipedia.org/wiki/%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D)。
4. [一文搞懂高并发性能指标：QPS、TPS、RT、吞吐量](http://blog.itpub.net/69942496/viewspace-2665766)。
5. [QPS、TPS、并发用户数、吞吐量关系](https://zhuanlan.zhihu.com/p/111914041)。
