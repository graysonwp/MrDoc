
            <!DOCTYPE html>
            <html>
            <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Algorithm Notebook</title>
            <link rel="stylesheet" href="../../static/layui/css/layui.css" />
            <link rel="stylesheet" href="../../static/editor.md/css/editormd.css" />
            <link rel="stylesheet" href="../../static/mrdoc/mrdoc-docs.css" />
            <script src="../../static/jquery/3.1.1/jquery.min.js"></script>
            <script>var iframe_whitelist = []</script>
            <script src="../../static/editor.md/lib/marked.min.js"></script>
            <script src="../../static/editor.md/lib/purify.min.js"></script>
            <script src="../../static/editor.md/lib/prettify.min.js"></script>
            <script src="../../static/editor.md/lib/raphael.min.js"></script>
            <script src="../../static/editor.md/lib/underscore.min.js"></script>
            <script src="../../static/editor.md/editormd.js"></script>
            <style>
            pre.linenums {
                max-height: 100%;
            }
            ol.linenums li {
                width: 100%;
            }
            /*一级无序li显示实心圆点*/
            ul li{
                list-style:disc;
            }
            /*二级无序li显示空心圆点*/
            ul > li > ul > li{
                list-style-type: circle;
            }
            /*有序li显示数字*/
            ol li{
                list-style-type: decimal;
            }
            ol ol ul,ol ul ul,ul ol ul,ul ul ul {
                list-style-type: square;
            }
            /* 三级及以下无序li显示小方块 */
            ul ul ul li{
                list-style-type: square;
            }
            </style>
            </head>
            <body>
                <div style="position: fixed;font-size:8px; bottom: 5px;padding: 5px; right: 10px; color: white;background: black; z-index: 10000">
                    本文件由MrDoc觅思文档生成
                </div>
                <div style="text-align:center;margin-top:400px;">
                    <h1>Algorithm Notebook</h1>
                    <p>作者：grayson</p>
                    <p>日期：2022-07-13</p>
                </div>

                <div class="markdown-body" id="content" style="padding:0px;font-family:宋体;">
                    <textarea style="display: none;"><h1 style='page-break-before: always;'>算法准备</h1>

0、算法准备



<h1 style='page-break-before: always;'>0.0 牛客网编程OJ的典型输入输出</h1>

> 记得自己以前一直在[Leetcode](https://leetcode-cn.com)上刷题，只需要自己写方法的具体逻辑，不用考虑输入输出的问题，直到第一次面试字节的时候才知道原来有的面试是使用的一块白板，程序的输入、输出，甚至导包都需要自己来写，因此结果可想而知 😭，因此决定对[牛客网](https://www.nowcoder.com)上常见的输入输出进行总结，避免在面试的时候再次踩雷 💣，让自己可以更加专注于具体的逻辑，提升自己面试通过的概率 😉。

> 大家在熟悉了下面的输入输出模板后可以使用[OJ 在线编程常见输入输出练习场](https://ac.nowcoder.com/acm/contest/5652)来进行练习。

## 1 典型实例

### 1.1 输入是已知大小的数组

> 第一行是一个整数 $n$，表示二维数组有 $n$ 行 $n$ 列。

**Java**：

```java
import java.util.Scanner;

Scanner scan = new Scanner(System.in);
int n = scan.nextInt();
int[][] arr = new int[n][n];
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        arr[i][j] = scan.nextInt();
    }
}
```

### 1.2 输入的每组测试数据有多行的情况

> 第一行是一个正整数 $m$，表示有 $m$ 组测试数据，之后每组数据有三行，第一行为 $n$（$ 1 \le n \le 10000 $），第二行有 $n$ 个正整数，第三行也有 $n$ 个正整数，都在整数范围内。

> 示例：
> 3
> 3
> 1 2 3
> 1 2 3
> 4
> 4 3 2 1
> 1 1 1 1
> 2
> 1 2
> 10 20

```java
import java.util.Arrays;
import java.util.Scanner;

Scanner scan = new Scanner(System.in);
int m = scan.nextInt();
while (m > 0) {
    m--;
    int n = scan.nextInt();;
    int[] a = new int[n];
    int[] b = new int[n];
    for (int i = 0; i < n; i++) {
        a[i] = scan.nextInt();
    }
    for (int i = 0; i < n; i++) {
        b[i] = scan.nextInt();
    }
    System.out.println(Arrays.toString(a));
    System.out.println(Arrays.toString(b));
}
```

### 1.3 每行测试数据的数量在该行开头给出

> 第一行是一个正整数 $m$，表示有 $m$ 组测试数据，之后每组数据第一个数为 $n$（$ 1 \le n \le 10000 $），紧接着有 $n$ 个正整数（注意在一行）。

> 示例：
> 2
> 3123
> 41234

```java
import java.util.Arrays;
import java.util.Scanner;

Scanner scan = new Scanner(System.in);
int m = scan.nextInt();
while (m > 0) {
    m--;
    String s = scan.next();
    int n = s.charAt(0) - '0';
    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
        arr[i] = s.charAt(i + 1) - '0';
    }
    System.out.println(Arrays.toString(arr));
}
```

### 1.4 测试数据组数未知

> 输入数据有多组，每行表示一组输入数据，每行不定有 $n$ 个整数，用空格隔开。

```java
import java.util.Scanner;

Scanner scan = new Scanner(System.in);
while (scan.hasNextLine()) {
    String s = scan.nextLine();
    String[] arr = s.split(" ");
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += Integer.parseInt(arr[i]);
    }
    System.out.println(sum);
}
```

## 2 注意事项

### 2.1 Java 中 next()、nextInt()和 nextLine()的用法及区别

1. `next()`、`nextInt()` 和 `nextLine()` 都是 Scanner 内置的方法，他们的区别主要在于对于**空格的处理方式**及**返回值**的不同：
   1. **空格的处理方式**：
      1. `next()` 和 `nextInt()`**遇到空格时会停止读取**，返回的结果为**空格前读取的部分**。
      2. `nextLine()`**从指针的当前位置开始读取**，**遇到换行符时会停止读取**，返回**换行符前读取的部分**。
   2. **返回值**：
      1. `next()` 和 `nextLine()` 的返回值为 `String` 类型。
      2. `nextInt()` 的返回值为 `int` 类型。

## 参考文献

1. [牛客网编程 OJ 的典型输入 Java 模板](https://www.cnblogs.com/treasury/p/13285997.html)
2. [java 中 next()，nextInt()，nextLine()的用法及区别](https://blog.csdn.net/qq_45445841/article/details/104824176)

<h1 style='page-break-before: always;'>算法框架</h1>

1、算法框架




<h1 style='page-break-before: always;'>1.0 动态规划</h1>

以下内容为自己学习时的笔记，内容参考自《labuladong 的算法小抄官方完整版》作者的微信公众号 `labuladong`，原文地址为：[labuladong 的算法小抄](https://labuladong.gitbook.io/algo)




<h1 style='page-break-before: always;'>1.0.0 斐波那契数列</h1>

## 1 题目

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```txt
输入：n = 2
输出：1
```

**示例 2：**

```txt
输入：n = 5
输出：5
```

**提示：**

* 0 <= n <= 100

1. 遇到**求总数的问题**时一般考虑用**动态规划**来求。
2. 这类问题的基本思路就是**先寻找状态之间的关系**，**确定状态转移方程**，**然后使用暴力递归的方法求解**，**接着使用带有备忘录的递归**、**dp 数组的迭代解法进行优化**。
3. 类似的题目还有：
   1. [62. 不同路径](https://leetcode-cn.com/problems/unique-paths)。
   2. [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)。
   3. [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs)。

> 在解决**爬楼梯**的问题时注意的是：
> 
> 1. **要爬到第**$i$**层有两种方法**，**一种是从第**$i - 2$**层直接爬两层来到达第**$i$**层**，**另一种方法是从第**$i - 1$**层直接爬一层来到达第**$i$**层**。
> 2. **因此假设爬到第**$i$**层楼梯共有**$dp[i]$**种方法**，**则**$dp[i] = dp[i - 2] + dp[i - 1]$。

## 2 解题思路

### 2.1 暴力递归

* 代码

```c++
int fib(int N) {
  if (N == 1) || (N == 2) return 1;
  return fib(N - 1) + fib(N - 2);
}
```

* 递归树

![](https://notebook.ricear.com/media/202103/2021-03-01_094618.png)

### 2.2 带备忘录的递归解法

* 代码

```c++
int fib(int N) {
  if (N < 1) return 0;
  //  备忘录全初始化为 0
  vector<int> memo(N + 1, 0);
  //  初始化最简情况
  return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
  //  base case
  if (n == 1) || (n == 2) return 1;
  //  已经计算过
  if (memo[n] != 0) return memo[n];
  memo[n] = memo[n - 1] + memo[n - 2];
  return memo[n]
}
```

* 递归树

![](https://notebook.ricear.com/media/202103/2021-03-01_095518.png)

![](https://notebook.ricear.com/media/202103/2021-03-01_102418.png)

此时本算法不存在冗余计算，子问题就是 `f(1)、f(2)`...`f(20)`，所以子问题个数为 o(n)，解决一个子问题的时间为 o(1)，因此本算法的时间复杂度为 o(n)。

### 2.3 dp 数组的迭代解法

```c++
int fib(int N) {
  vector<int> dp(N + 1, 0);
  //  base case
  dp[1] = dp[2] == 1;
  for (int i = 1; i <= N; i++)
    dp[i] = dp[i - 1] + dp[i - 2];
  return dp[N];
}
```

![](https://notebook.ricear.com/media/202103/2021-03-01_103126.png)

### 2.4 细节优化

斐波那契数列的状态转移方程如下：

![](https://notebook.ricear.com/media/202103/2021-03-01_104211.png)

根据斐波那契数列的状态转移方程可知，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行。所以，可以进一步优化，把空间复杂度降为 o(1)。

```c++
int fib(int n) {
  if (n == 1 || n == 2) return 1;
  int prev = 1, curr = 1;
  for (int i = 3; i <= N; i++) {
    int sum = prev + next;
    prev = curr;
    curr = sum;
  }
  return curr;
}
```

## 3 参考文献

1. [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof)。
2. [62. 不同路径](https://leetcode-cn.com/problems/unique-paths)。
3. [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)。
4. [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs)。
5. [动态规划解题核心框架](https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye/dong-tai-gui-hua-xiang-jie-jin-jie)。




<h1 style='page-break-before: always;'>1.0.1 背包问题</h1>

## 1 含义

1. **给定一个背包容量 $target$**，**再给定一个数组**$nums$（物品），**能否按一定方式选取 $nums$ 中的元素得到 $target$**。
2. 需要注意的是：
   1. **背包容量 $target$ 和物品 $nums$ 的类型可能是数**，**也可能是字符串**。
   2. $target$**可能题目已经给出**（显式），**也可能是需要我们从题目的信息中挖掘出来**（非显式）（常见的非显式 $target$ 比如 $sum / 2$ 等）。
   3. **选取的方式**有常见的以下几种：
      1. **每个元素选一次**。
      2. **每个元素选多次**。
      3. **选元素进行排列组合**。

## 2 分类及解题模板

1. 常见的背包类型有以下几种：
   1. **0/1 背包问题**：
      1. **每个元素最多选取一次**。
      2. **外循环 $nums$**，**内循环**（倒序）**$target$**，且 $target \ge num$。
   2. **完全背包问题**：
      1. **每个元素可以重复选择**。
      2. **外循环 $nums$**，**内循环**（正序）$target$，且 $target \ge num$。
   3. **组合背包问题**：
      1. **背包中的物品要考虑顺序**。
      2. **外循环**（正序）**$target$**，**内循环 $nums$**，且 $target \ge num$。
   4. **分组背包问题**：
      1. **不止一个背包**，**需要遍历每一个背包**。
      2. **这个比较特殊**，**需要三重循环**，**外循环背包 $bags$**，**内部两层循环根据题目的要求转化为上面三种背包类型的模板**。
2. 而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：
   1. **最值问题**：
      1. **要求最大值或最小值**。
      2. $dp[i] = max/min(dp[i], dp[i - num] + 1)$ 或 $dp[i] = max/min(dp[i], dp[i - num] + num)$。
      3. 一般需要把$dp[i]$初始化为 `Integer.MAX_VALUE`或`Integer.MIN_VALUE`
   2. **存在问题**：
      1. **是否存在**...，**满足**...。
      2. $dp[i] = dp[i] || dp[i - num]$。
      3. 一般需要把$dp[0]$初始化为 `true`。
   3. **组合问题**：
      1. **求所有满足**...**的排列组合**。
      2. $dp[i] += dp[i - num]$。
      3. 一般需要把$dp[0]$初始化为1。

## 3 题目示例

### 3.1 完全背包最值问题

> 题目来源[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change)。

#### 3.1.1 题目

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```txt
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```

**示例 2：**

```txt
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```txt
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```txt
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```txt
输入：coins = [1], amount = 2
输出：2
```

**提示：**

* 1 <= coins.length <= 12
* 1 <= coins[i] <= 231 - 1
* 0 <= amount <= 104

#### 3.1.2 问题分析

1. 该题目属于**完全背包最值问题**，直接套用相应的解题模板即可。

#### 3.1.3 参考代码

```java
/**
 * 322. 零钱兑换
 * @param coins 不同面额的硬币数组
 * @param amount    总金额
 * @return  可以凑成总金额所需的最少的硬币个数
 */
public int coinChange(int[] coins, int amount) {
    int m = coins.length;
    //  dp 数组，其中 dp[i] 表示凑成金额 i 所需的最少的硬币个数
    int[] dp = new int[amount + 1];

    Arrays.fill(dp, amount + 1);

    dp[0] = 0;
    for (int coin: coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }

    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```

#### 3.1.3 扩展题目

##### 3.1.3.1 [完全平方数](https://leetcode-cn.com/problems/perfect-squares)

###### 3.1.3.1.1 题目

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

**示例 1：**

```txt
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4
```

**示例 2：**

```txt
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

* 1 <= n <= 104

###### 3.1.3.1.2 问题分析

1. **完全平方数最小为 1**，**最大为 $sqrt(n)$**，故**题目转换为在 $nums = [1,2,...,sqrt(n)]$ 中选任意数平方和为 $target = n$**。
2. 该题目属于**完全背包最值问题**，直接套用相应的解题模板即可。

###### 3.1.3.1.3 参考代码

```java
/**
 * 279. 完全平方数
 * @param n 一个正整数
 * @return  和为 n 的完全平方数的 最少数量
 */
public int numSquares(int n) {
    //  dp 数组，其中 dp[i] 表示和为 i 的完全平方数的最少数量
    int[] dp = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);

    dp[0] = 0;
    for (int num = 1; num <= Math.sqrt(n); num++) {
        for (int i = num * num; i <= n; i++) {
            dp[i] = Math.min(dp[i], dp[i - num * num] + 1);
        }
    }

    return dp[n];
}
```

### 3.2 0/1 背包存在性问题

> 题目来源[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum)。

#### 3.2.1 题目

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```java
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```txt
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 100

#### 3.2.2 问题分析

1. 该题目等价于**是否存在一个子集**，**其和为 $target = sum / 2$**。
2. 该题目属于**0/1 背包存在性问题**，直接套用相应的解题模板即可。

#### 3.2.3 参考代码

```java
/**
 * 416. 分割等和子集
 * @param nums  只包含正整数的非空数组
 * @return  是否可以将这个数组分割成两个子集，使得两个子集的元素和相等
 */
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum(), target = sum / 2;
    int m = nums.length + 1;
    //  dp 数组，其中 dp[i] 表示是否可以将原数组分成两个和为 i 的子集
    boolean[] dp = new boolean[target + 1];

    //  base case
    //  如果和为奇数，显然无法分成两个等和子集
    if (sum % 2 != 0) {return false;}

    dp[0] = true;
    for (int num: nums) {
        for (int i = target; i >= num; i--) {
            dp[i] = dp[i] || dp[i - num];
        }
    }

    return dp[target];
}
```

### 3.3 0/1 背包组合问题

> 题目来源[494. 目标和](https://leetcode-cn.com/problems/target-sum)。

#### 3.3.1 题目

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

**示例 1：**

```txt
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```txt
输入：nums = [1], target = 1
输出：1
```

**提示：**

* 1 <= nums.length <= 20
* 0 <= nums[i] <= 1000
* 0 <= sum(nums[i]) <= 1000
* -1000 <= target <= 1000

#### 3.3.2 问题分析

1. **假设数组和为 $sum$**，**目标和为 $s$**，**正数和为 $x$**，**负数和为 $y$**，则：

   $$
   x + y = sum, x - y = s
   $$

   可得：

   $$
   x = \frac{s + sum}{2}
   $$
2. 所以该题目可以转换为**从数组**$nums$**中无放回的选取几个数**，**其和等于**$x$**的组合的个数**。
3. 该题目属于**0/1 背包组合问题**，直接套用相应的解题模板即可。

#### 3.3.3 参考代码

```java
/**
 * 494. 目标和
 * @param nums  整数数组
 * @param target    目标整数
 * @return  通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目
 */
public int findTargetSumWays(int[] nums, int target) {
    int m = nums.length;
    int sum = Arrays.stream(nums).sum();
    //  dp 数组，其中 dp[i] 表示 从数组 nums 中无放回选取元素，其和等于 i 的组合的个数
    int[] dp = null;

    if ((sum + target) % 2 != 0 || sum < Math.abs(target)) {return 0;}

    target = (sum + target) / 2;
    dp = new int[target + 1];
    dp[0] = 1;
    for (int num: nums) {
        for (int i = target; i >= num; i--) {
            dp[i] += dp[i - num];
        }
    }

    return dp[target];
}
```

### 3.4 组合背包组合问题

> 题目来源[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv)。

#### 3.4.1 题目

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```txt
输入：nums = [9], target = 3
输出：0
```

**提示：**

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 1000
* nums 中的所有元素 互不相同
* 1 <= target <= 1000

进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

#### 3.4.2 问题分析

1. 该题目中**顺序不同的序列被视作不同的组合**，即**背包中的物品需要考虑顺序**，所以该题目属于**组合背包组合问题**，直接套用相应的解题模板即可。

#### 3.4.3 参考代码

```java
/**
 * 377. 组合总和 Ⅳ
 * @param nums  不同整数组成的数组
 * @param target    目标整数
 * @return  从 nums 中可以找到的总和为 target 的元素组合的个数
 */
public int combinationSum4(int[] nums, int target) {
    int m = nums.length;
    //  dp 数组，其中 dp[i] 表示从 nums 中可以找到的总和为 i 的元素组合的个数
    int[] dp = new int[target + 1];

    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int num: nums) {
            if (i >= num) {
                dp[i] += dp[i - num];
            }
        }
    }

    return dp[target];
}
```

### 3.5 完全背包组合问题

> 题目来源[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2)。

#### 3.5.1 题目

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```txt
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```txt
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```txt
输入：amount = 10, coins = [10]
输出：1
```

**提示：**

* 1 <= coins.length <= 300
* 1 <= coins[i] <= 5000
* coins 中的所有值 互不相同
* 0 <= amount <= 5000

#### 3.5.2 问题分析

1. 该题目属于**完全背包组合问题**，直接套用相应的解题模板即可。

#### 3.5.3 参考代码

```java
/**
 * 518. 零钱兑换 II
 * @param amount    总金额
 * @param coins 不同面额的硬币数组
 * @return  可以凑成总金额的硬币组合数
 */
public int change(int amount, int[] coins) {
    int m = coins.length;
    //  dp 数组，其中 dp[i] 表示可以凑成总金额为 i 的硬币组合数
    int[] dp = new int[amount + 1];

    dp[0] = 1;
    for (int coin: coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }

    return dp[amount];
}
```

## 参考文献

1. [ 一篇文章吃透背包问题！（细致引入 + 解题模板 + 例题分析 + 代码呈现）](https://leetcode-cn.com/problems/coin-change-2/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-2xkk)。
2. [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change)。
3. [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum)。
4. [494. 目标和](https://leetcode-cn.com/problems/target-sum)。
5. [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares)。
6. [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv)。
7. [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2)。



<h1 style='page-break-before: always;'>1.0.2 贪心算法</h1>

## 1 定义

**贪心算法**可以认为是**动态规划算法**的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（**贪心选择性质**），但是效率比动态规划要高。

**贪心选择性质：** 简单地说就是每一步做出一个局部最优的选择，最终的结果就是全局最优。需要注意的是，这是一种特殊性质，只有一部分问题拥有这个性质。

* 比如面前放着 100 张人民币，我们只能拿 10 张，怎么才能拿到最多的面额？显然每次选择剩下钞票中面值最大的一张，最后我们的选择一定是最优的。
* 但是大部分问题明显不具有贪心选择性质，比如斗地主，对手出对儿三，按照贪心策略，我们应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决。

## 2 示例

### 2.1 区间调度问题

#### 2.1.1 [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals)

##### 2.1.1.1 题目

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

```txt
1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
```

**示例 1:**

```txt
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```txt
输入: [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```txt
输入: [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

##### 2.1.1.2 问题分析

这个问题的实质是需要我们设计一个算法，**算出这些区间中最多有几个互不相交的区间**。

这个问题在生活中的应用广泛，比如我们今天有好几个活动，每个活动都可以用区间 `[start, end]` 表示开始和结束时间，请问我们今天**最多能参加几个活动呢**？显然我们一个人不能同时参加两个活动，所以说这个问题就是**求这些时间区间的最大不相交子集**。

正确的思路其实很简单，可以分为以下三步：

1. 从区间集合`intvs` 中选择一个区间`x`，这个`x` 是在当前所有区间中**结束最早的**（end 最小）。
2. 把所有与`x` 相交的区间从区间集合`intvs` 中删除。
3. 重复步骤 1 和 2，直到`intvs` 为空为止，之前选出的那些`x` 就是最大不相交子集。

把这个思路实现成算法的话，可以按每个区间的 `end` 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多。

![](../../media/202103/2021-03-24_151330.png)

现在来实现算法，对于步骤 1，由于我们预先按照 `end` 排了序，不难发现所有与 `x` 相交的区间必然会与 `x` 的 `end` 相交，他的 `start` 必然要大于或等于 `x` 的 `end`：

![](../../media/202103/2021-03-24_151809.png)

##### 2.1.1.3 参考代码

```java
/**
 * 435. 无重叠区间
 * @param intervals 区间集合
 * @return  需要移除区间的最小数量，使剩余区间互不重叠
 */
public int eraseOverlapIntervals(int[][] intervals) {
    //  区间集合的长度
    int m = intervals.length;
    //  需要移除区间的最小数量
    int count = 0;
    //  当前不需要移除区间的右边界
    int end = -1;

    //  将区间集合根据元素右边界进行排序
    Arrays.sort(intervals, (int[] a, int[] b) -> a[1] - b[1]);

    end = intervals[0][1];
    for (int i = 1; i < m; i++) {
        if (intervals[i][0] < end) {
            //  如果当前区间的左边界小于当前不需要移除区间的右边界，则当前区间需要移除，即将 count 的值加 1
            count++;
        } else {
            //  如果当前区间的左边界大于等于当前不需要移除区间的右边界，则将当前不需要移除区间的右边界修改为当前区间的右边界
            end = intervals[i][1];
        }
    }

    //  返回最后结果
    return count;
}
```

#### 2.1.2 [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons)

##### 2.1.2.1 题目

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
**示例 1：**

```txt
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
```

**示例 2：**

```txt
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
```

**示例 3：**

```txt
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
```

**示例 4：**

```txt
输入：points = [[1,2]]
输出：1
```

**示例 5：**

```txt
输入：points = [[2,3],[2,3]]
输出：1
```

##### 2.1.2.2 问题分析

这个问题和区间调度的算法一样，如果最多有 `n` 个不重叠的区间，那么就至少需要 `n` 个箭头穿透所有区间。
![](../../media/202103/2021-03-24_152613.png)

只是有点不一样，在 `无重叠区间` 算法中，如果两个区间的边界触碰，不算重叠，而按照这道题目的描述，箭头如果碰到气球的边界，气球也会爆炸，所以说相当于区间的边界触碰也算重叠。

![](../../media/202103/2021-03-24_152911.png)

所以只要将之前的算法稍作修改，就是这道题目的答案。

##### 2.1.2.3 参考代码

```java
/**
 * 452.用最少数量的箭引爆气球
 * @param points    气球位置
 * @return  引爆气球所需要的箭的最少数量
 */
public static int findMinArrowShots(int[][] points) {
    //  如果没有气球，则返回 0
    if (points.length == 0) {return 0;}
    //  对气球坐标按照 xend 正序排序
    Arrays.sort(points, (int[] a, int [] b) -> {
        //  防止 a[1] - b[1] 越界导致排序不正确
        //  [[-2147483646,-2147483645],[2147483646,2147483647]]
        if (a[1] > b[1]) {return 1;}
        else {return -1;}
    });
    //  至少需要一个箭
    int count = 1;
    //  遍历计算引爆气球所需的最少数量的箭
    int x_end = points[0][1];
    for (int i = 1; i < points.length; i++) {
        int start = points[i][0];
        if (start > x_end) {
            //  找到下一个不相邻的起球了
            count++;
            x_end = points[i][1];
        }
    }
    return count;
}
```

### 2.2 跳跃游戏

#### 2.2.1 [跳跃游戏 1](https://leetcode-cn.com/problems/jump-game)

##### 2.2.1.1 题目

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例 1：**

```txt
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```txt
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

##### 2.2.1.2 问题分析

这题让求的是能否到达最后一个位置，我们先遍历数组的数字，然后保存下来他所能跳到的最大距离，如果能到达最后一个位置，直接返回 true，如果不能到达就继续遍历，如果最大距离连下一步都到不了，就直接返回 false。

##### 2.2.1.3 参考代码

```java
/**
 * 55.跳跃游戏
 * @param nums  数组
 * @return  是否能够到达最后一个下标
 */
public boolean canJump(int[] nums) {
    int m = nums.length;
    int farthest = 0;

    if (nums[0] == 0 && m > 1) {return false;}

    for (int i = 0; i < m - 1; i++) {
        int item = nums[i];
        farthest = Math.max(farthest, i + item);
        if (farthest <= i) {return false;}
    }

    return farthest >= m - 1;
}
```

#### 2.2.2 [跳跃游戏 2](https://leetcode-cn.com/problems/jump-game-ii)

##### 2.2.2.1 题目

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

**示例:**

```txt
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**说明:**

假设你总是可以到达数组的最后一个位置。

##### 2.2.2.2 问题分析

![](../../media/202103/2021-03-24_155914.png)

当我们站在索引 0 的位置上时，可以向前跳 1、2 或 3 步，但是**我们应该跳 2 步到索引 2，因为 `nums[2]` 的可跳跃区域涵盖了索引区间 `[3..6]`，比其他都大**，如果我们想求最少的跳跃次数，那么往索引 2 跳必然是最优的选择，**这就是贪心选择性质，我们不需要【递归地】计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有【潜力】，看起来最优的选择即可。**

如果某一个作为**起跳点**的格子可以**跳跃**的距离是 3，那么表示后面 3 个格子都可以作为**起跳点**。可以对每一个能作为**起跳点**的格子都尝试跳一次，把**能跳到最远的距离**不断更新。

![](../../media/202103/2021-03-24_160941.png)

##### 2.2.2.3 参考代码

![](../../media/202103/2021-03-24_161835.png)

下面的代码中 `i` 和 `end` 标记了可以选择的跳跃步数，`farthest` 标记了所有选择 `[i..end]` 中能够跳到的最远距离，`jumps` 记录了跳跃次数。

```java
/**
 * 45.跳跃游戏 II
 * @param nums
 * @return
 */
public static int jump(int[] nums) {
    int n = nums.length;
    int end = 0, farthest = 0;
    int jumps = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        farthest = Math.max(i + nums[i], farthest);
        if (end == i) {
            jumps++;
            end = farthest;
        }
    }
    return jumps;
}
```

## 3 参考文献

1. [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals)。
2. [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons)。
3. [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game)。
4. [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii)。
5. [贪心算法之区间调度问题](https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-3/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti)。



<h1 style='page-break-before: always;'>1.0.3 序列和数组类问题</h1>

## 1 序列类问题

### 1.1 [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)

#### 1.1.1 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

**示例 1：**

```txt
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```txt
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```txt
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

* 1 <= nums.length <= 2500
* -104 <= nums[i] <= 104

**进阶：**

* 你可以设计时间复杂度为 O(n2) 的解决方案吗？
* 你能将算法的时间复杂度降低到 O(n log(n)) 吗?

#### 1.1.2 解题思路

##### 1.1.2.1 动态规划法

###### 1.1.2.1.1 问题分析

**动态规划的核心设计思想是数学归纳法。**

比如我们想证明一个数学结论，那么我们先假设这个结论在 $k \lt n$ 时成立，然后想办法证明 $k = n$ 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 $k$ 等于任何数都成立。

类似的，我们在设计动态规划算法时，需要一个 $dp$ 数组，我们可以假设 $dp[0...i-1]$ 都已经被算出来了，然后需要通过这些结果算出 $dp[i]$。

该题目的具体解题思路如下：

1. **定义 $dp$ 数组：$dp[i]$ 表示以 $nums[i]$ 这个数结尾的最长递增子序列的长度。** 根据这个定义，**我们的最终结果（子序列的最大长度）应该是 $dp$ 数组中的最大值**。

![](https://notebook.ricear.com/media/202104/2021-04-04_202723.png)

![](https://notebook.ricear.com/media/202104/2021-04-04_202743.png)

2. 刚在这个过程中每个 $dp[i]$ 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 $dp[i]$ 呢？这就是动态规划中关键的部分了，要思考如何进行**状态转移**，这里就可以使用**数学归纳**的思想了。

![](https://notebook.ricear.com/media/202104/2021-04-04_203956.png)

* 假设此时我们已经知道了 $dp[0...4]$ 的所有结果，现在需要求 $dp[5]$ 值，也就是相求以 $nums[5]$ 结尾的最长递增子序列。
* $nums[5]=3$，既然是递增子序列，我们只要**找到前面那些结尾比 3 小的子序列，然后把 3 接到最后**，就可以形成一个新的递增子序列，而且这个新的子序列长度加 1。
* 当然，**可能形成很多新的子序列，但是我们只要最长的，把最长子序列的长度作为 $dp[5]$ 即可**。

```java
for (int j = 0; j < i; j++) {
    //  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
    if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

* 这段代码的逻辑可以算出 $dp[5]$，类似数学归纳法，我们可以算出 $dp[5]$，其他的就可以都算出来了。

```java
//  遍历 nums
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        //  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
        if (nums[j] < nums[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```

3. 还有一个细节问题，$dp$ 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最少为 1。

至此，这道题就解决了，时间复杂度为 $O(N^2)$，最后总结一下动态规划的设计流程：

1. **首先明确 $dp$ 数组所存数据的含义。** 这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。
2. 然后根据 $dp$ 数组的定义，运用**数学归纳法**的思想，假设 $dp[0...i-1]$ 都已知，想办法求出 $dp[i]$，一旦这一步完成，整个题目就解决了。但如果无法完成这一步，可能是以下原因：
   * $dp$ 数组的定义不够恰当，需要重新定义 $dp$ 数组的含义。
   * $dp$ 数组存储的信息不够，不足以推出下一步的答案，需要把 $dp$ 数组扩大成二维数组甚至三维数组。
3. 最后想一想问题的 $base\space case$ 是什么，以此来初始化 $dp$ 数组，以保证算法正确运行。

###### 1.1.2.1.2 参考代码

```java
/**
     * 300. 最长递增子序列（版本 1：动态规划）
     * 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
     * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
     *
     * @param nums 整数数组
     * @return 最长严格递增子序列的长度
     */
    public int lengthOfLISV1(int[] nums) {
        //  定义 dp 数组，其中第 i 个元素表示以 nums[i]这个数结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];
        //  将数组中的元素初始化为 1
        Arrays.fill(dp, 1);

        //  遍历 nums
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                //  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        //  dp 数组中最大的元素即为最长递增子序列的长度
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }

        //  返回结果
        return res;
    }
```

##### 1.1.2.2 二分查找法

###### 1.1.2.2.1 问题分析

**最长递增子序列**和一种叫做**Patience Game**的纸牌游戏有关，甚至有一种排序方法就叫做**Patience Sorting**（耐心排序）。该纸牌游戏的玩法如下：

1. 首先，给我们一副扑克牌，我们想遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

![](https://notebook.ricear.com/media/202104/2021-04-04_210817.png)

2. 处理这些扑克牌要遵循以下规则：
   1. **只能把点数小的牌压到点数比他大的牌上。**
   2. 如果当前牌**点数较大没有可以放置的堆**，则**新建一个堆**，把这张牌放进去。
   3. 如果当前牌**有多个堆可供选择**，则选择**最左边的堆**放置（保证牌堆顶的牌有序）。
3. 比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 $A$ 的值最大，而不是 1）。

![](https://notebook.ricear.com/media/202104/2021-04-04_211338.png)

4. 按照上述规则执行，可以算出最长递增子序列，**牌的堆数就是最长递增子序列的长度**。

![](https://notebook.ricear.com/media/202104/2021-04-04_211739.png)

5. 我们只要把**处理扑克牌的过程**编程写出来即可。每次处理一张扑克牌不是要找到一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到[二分查找]()了：用**寻找左侧边界的二分查找法来搜索当前牌应放置的位置**。

###### 1.1.2.2.2 参考代码

```java
/**
     * 300. 最长递增子序列（版本 2：二分数组）
     * 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
     * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
     *
     * @param nums 整数数组
     * @return 最长严格递增子序列的长度
     */
    public int lengthOfLISV2(int[] nums) {
        //  牌堆顶部的牌
        int[] top = new int[nums.length];
        //  牌堆数
        int piles = 0;

        //  遍历 nums，将牌进行分堆
        for (int i = 0; i < nums.length; i++) {
            int poker = nums[i];

            //  采用寻找左侧边界的二分查找法，寻找牌应放置的堆的位置
            int left = 0, right = piles - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (top[mid] > poker) {
                    right = mid - 1;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else if (top[mid] == poker) {
                    right = mid - 1;
                }
            }

            //  没找到放牌的位置，则新建一堆
            if (left >= piles) {piles++;};
            //  将牌放到该堆的位置
            top[left] = poker;
        }

        //  牌堆数即为最长递增子序列的长度，将其直接返回即可
        return piles;
    }
```

### 1.2 [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)

#### 1.2.1 题目

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
**示例 1:**
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**
输入:

```
"cbbd"
```

输出:

```
2
```

一个可能的最长回文子序列为 "bb"。

**提示：**

* 1 <= s.length <= 1000
* s 只包含小写英文字母

#### 1.2.2 解题思路

##### 1.2.2.1 子序列问题处理模板

对于这种子序列问题，我们一般需要使用**动态规划**的方法来解决：

1. **找状态关系（通过数学归纳获得）。**
2. **定义 dp 数组（根据状态转移方程获得）。**

dp 数组的定义主要有两种方式，一种是定义一个**一维数组**，另一种是定义一个**二维数组**。

###### 1.2.2.1.1 一维 dp 数组

例如，在[最长递增子序列](http://notebook.ricear.com/project-21/doc-266)中，我们就是定义了一个一维数组，其含义为：**在子数组 $array[0..i]$ 中，我们要求的子序列（最长递增子序列）的长度是 $dp[i]$。**

```java
int n = array.length;
int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

###### 1.2.2.1.2 二维 dp 数组

这种思路运用相对多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为**只涉及一个字符串**和**涉及两个字符串**两种情况。

1. **只涉及一个字符串/数组时：** 在子数组 $array[i..j]$ 中，我们要求的子序列（最长回文子序列）的长度为 $dp[i][j]$。
2. **涉及两个字符串/数组：在子数组 $arr1[0..i]$ 和 $arr2[0..j]$ 中，我们要求的子序列（最长公共子序列）长度为 $dp[i][j]$。**

##### 1.2.2.2 问题分析

![](https://notebook.ricear.com/media/202104/2021-04-08_163717.png)

dp 函数的定义为：**在子串 $s[i..j]$ 中，最长回文子序列的长度为 $dp[i][j]$**。

如果我们想求 $dp[i][j]$，假设我们已经知道了子问题 $dp[i+1][j-1]$ 的结果，即 $s[i+1..j-1]$ 中最长回文子序列的长度，那么我们就可以想办法算出 $dp[i][j]$ 的值，即 $s[i..j]$ 中最长回文子序列的长度，这主要取决于 $s[i]$ 和 $s[j]$ 的字符。

1. **如果 $s[i]==s[j]$：** 则他俩加上 $s[i+1..j-1]$ 中的最长回文子序列就是 $s[i..j]$ 的最长回文子序列。

![](https://notebook.ricear.com/media/202104/2021-04-08_164936.png)

2. **如果 $s[i]!=s[j]$：** 说明他俩不可能同时出现在 $s[i..j]$ 的最长回文子序列中，那么把他俩分别加入 $s[i+1..j-1]$ 中，看看哪个子串产生的回文子序列更长即可。

![](https://notebook.ricear.com/media/202104/2021-04-08_165224.png)

代码模板如下：

```c++
if (s[i] == s[j])
    // 它俩⼀定在最⻓回⽂⼦序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else
    //  s[i+1..j] 和 s[i..j-1] 谁的回⽂⼦序列更⻓？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

至此，状态转移方程就写出来了，根据**dp 数组**的定义，**我们要求的就是 $dp[0][n-1]$，也就是整个 s 的最长回文子序列的长度**。

##### 1.2.2.3 参考代码

1. 首先明确一下 $base \space case$，如果只有一个字符，显然最长回文子序列的长度为 1，即 $dp[i][j]=1 \space (i==j)$。
2. 因为 $i$ 肯定小于 $j$，所以对于那些 $i>j$ 的位置，根本不存在什么子序列，应该初始化为 0。
3. 根据我们刚才的状态转移方程，想求 $dp[i][j]$ 需要知道 $dp[i+1][j-1]$，$dp[i+1][j]$，$dp[i][i-1]$ 这三个位置，将其填入 dp 数组后是这样：

![](https://notebook.ricear.com/media/202104/2021-04-08_173451.png)

**为了保证每次计算 $dp[i][j]$，左、下、右方向的位置已经被计算出来了，只能斜着遍历或者反着遍历。**

![](https://notebook.ricear.com/media/202104/2021-04-09_152953.png)

我选择**反着遍历**，参考代码如下：

```java
package com.grayson.top;

import java.util.Arrays;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/8 14:50
 * @Description 最长回文子序列
 */
public class L516 {

    /**
     * 516. 最长回文子序列
     * 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
     * @param s 字符串
     * @return  最长回文子序列的长度
     */
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        //  dp table: s[i...j] 子串的回文子序列的最大长度
        //  最终的结果为 dp[0][n - 1]
        int[][] dp = new int[n][n];

        //  base case: 单个字符的回文子序列的最大长度为 1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    //  两个字符相等，将 dp[i + 1][j - 1] + 1
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    //  两个字符不相等，则 dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        // 返回最终的结果 dp[0][n - 1]
        return dp[0][n - 1];
    }

}
```

### 1.3 [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

#### 1.3.1 解题思路

##### 1.3.1.1 动态规划

###### 1.3.1.1.1 问题分析

1. 类似的解法还可用于[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)，不过这里和求最长重复子数组不同的一点是子序列中的元素不一定在原数组中连续，因此，在 $dp$ 数组的转换上稍微会有一定区别，具体如下：

* **如果 $nums1[i] = nums2[j]$**，**则 $dp[i][j] = dp[i + 1][j + 1] + 1$**。
* **否则**，$dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])$。

![](https://notebook.ricear.com/media/202107/2021-07-17_205353.png)

###### 1.3.1.1.2 参考代码

```java
/**
 * 1143. 最长公共子序列
 * @param text1 数组 1
 * @param text2 数组 2
 * @return  两个数组中公共的、长度最长的子数组的长度
 */
public int longestCommonSubsequence(String text1, String text2) {
    int n1 = text1.length();
    int n2 = text2.length();
    int res = 0;
    //  dp 数组，其中 dp[i][j] 表示 nums1[i:] 和 nums2[j:] 的最长公共子序列的长度，则 dp 数组中最大的元素即为 nums1 和 nums2 的最长公共子序列的长度
    int[][] dp = new int[n1 + 1][n2 + 1];

    //  分别遍历 nums1 和 nums2，计算最长公共子序列的长度
    for (int i = n1 - 1; i >= 0; i--) {
        for (int j = n2 - 1; j >=0; j--) {
            //  如果 nums1[i] = nums2[j]，则 dp[i][j] = dp[i + 1][j + 1]，否则，dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
            if (text1.charAt(i) == text2.charAt(j)) {
                dp[i][j] = dp[i + 1][j + 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
            }
            res = Math.max(res, dp[i][j]);
        }
    }

    //  返回结果
    return res;
}
```

## 2 数组类问题

### 2.1 [最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

#### 2.1.1 题目

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```txt
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```txt
输入：nums = [1]
输出：1
```

**示例 3：**

```txt
输入：nums = [0]
输出：0
```

**示例 4：**

```txt
输入：nums = [-1]
输出：-1
```

**示例 5：**

```txt
输入：nums = [-100000]
输出：-100000
```

**提示：**

* 1 <= nums.length <= 3 * 104
* -105 <= nums[i] <= 105

**进阶：** 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

#### 2.1.2 解题思路

##### 2.1.2.1 暴力法

###### 2.1.2.1.1 问题分析

1. 依次遍历单个元素、两个元素、...、N 个元素，然后从中选取最大子序和。

![](https://notebook.ricear.com/media/202105/2021-05-22_193233.png)

###### 2.1.2.1.2 参考代码

```java
/**
 * 53. 最大子序和（版本 1：暴力法）
 *
 * @param nums 数组
 * @return 最大子序和
 */
public int maxSubArrayV1(int[] nums) {
    int len = nums.length;
    int max = nums[0];
    for (int i = 0; i < len; i++) {
        for (int j = 0; j < len - i; j++) {
            int sum = 0;
            for (int k = 0; k <= i; k++) {
                sum += nums[j + k];
            }
            max = Math.max(sum, max);
        }
    }
    return max;
}
```

##### 2.1.2.2 动态规划

###### 2.1.2.2.1 问题分析

1. 定义 $dp$ 数组：
   1. $dp[i]$ 表示 $nums$ 中以 $nums[i]$ 结尾的最大子序和。
   2. $dp[i]$ 中最大的元素即为 $nums$ 的最大子序和。
   3. $dp[0] = nums[0]$。
2. 列出状态转移方程：
   $$
   dp[i] = max(dp[i-1] + nums[i], nums[i])
   $$

![](https://notebook.ricear.com/media/202105/2021-05-22_194007.png)

###### 2.1.2.2.2 参考代码

```java
/**
 * 53. 最大子序和（版本 2：动态规划）
 *
 * @param nums 数组
 * @return 最大子序和
 */
public int maxSubArrayV2(int[] nums) {
    int len = nums.length, max;
    //  dp 数组，其中 dp[i] 表示以 nums[i] 结尾的 nums[0...i] 序列中最大子序和
    //  则最终 dp 数组中的最大值便是整个数组的最大子序和
    int[] dp = new int[len];
    dp[0] = nums[0];
    max = dp[0];
    for (int i = 1; i < len; i++) {
        dp[i] = Math.max(nums[i] + dp[i - 1], nums[i]);
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

##### 2.1.2.3 贪心法

###### 2.1.2.3.1 问题解析

1. 如果 sum 小于 0，说明他对于下一个 sum 起副作用，所以将 sum 重置为当前元素。
2. 否则的话，直接将当前元素累加到 sum 上。

![](https://notebook.ricear.com/media/202105/2021-05-22_194238.png)

###### 2.1.2.3.2 参考代码

```java
/**
 * 53. 最大子序和（版本 3：贪心算法）
 *
 * @param nums 数组
 * @return 最大子序和
 */
public int maxSubArrayV3(int[] nums) {
    int sum = nums[0], max = nums[0];
    int len = nums.length;
    for (int i = 1; i < len; i++) {
        if (sum < 0) {
        //  如果 sum 小于 0，说明他对于下一个 sum 起副作用，所以将 sum 重置为当前元素
            sum = nums[i];
        } else {
            //  否则的话，直接将当前元素累加到 sum 上
            sum += nums[i];
        }
        max = Math.max(max, sum);
    }
    return max;
}
```

#### 2.1.3 扩展题目

##### 2.1.3.1 返回最大和对应的子数组

###### 2.1.3.1.1 问题分析

1. 可以**使用 $start$ 和 $end$ 来记录最大和对应的子数组区间**，**使用 $tmp\_start$ 和 $tmp\_end$ 作为从数组右侧往左侧遍历的过程中和递增的子数组区间**，然后**当更新 $res$ 值的时候用 $tmp\_start$ 和 $tmp\_end$ 来更新 $start$ 和**$end$。

###### 2.1.3.1.2 参考代码

```java
/**
 * 53. 最大子序和（返回最大和对应的子数组）
 *
 * @param nums 数组
 * @return 最大和对应的子数组
 */
public int[] maxSubArray(int[] array) {
    int n = array.length, start = n - 1, end = n - 1, tmp_start = start, tmp_end = end;
    int[] dp = new int[n];
    dp[n - 1] = array[n - 1];
    int max = dp[n - 1];

    /**
     * 获取最大和对应的子数组区间
     */
    for (int i = n - 2; i >= 0; i--) {
        if (array[i] > dp[i + 1] + array[i]) {
            //  dp[i + 1] 为负数，说明 i 对应的元素为一个新的和递增的区间，因此需要更新 tmp_start 和 tmp_end
            tmp_start = i;
            tmp_end = i;
            dp[i] = array[i];
        } else {
            //  dp[i + 1] 为整数，说明 i 对应的元素和后面的元素依然是同一个和递增的区间，因此只需要更新 tmp_start 即可
            tmp_start = i;
            dp[i] = dp[i + 1] + array[i];
        }
        if (max <= dp[i]) {
            //  当前递增区间的和大于历史递增区间的和，因此需要用 tmp_start 和 tmp_end 来更新 start 和 end
            start = tmp_start;
            end = tmp_end;
            max = dp[i];
        }
    }

    /**
     * 获取结果数组
     */
    int len = end - start + 1;
    int[] res = new int[len];
    for (int i = 0; i < len; i++) {
        res[i] = array[start + i];
    }

    return res;
}
```

### 2.2 [打家劫舍](https://leetcode-cn.com/problems/house-robber)

#### 2.2.1 解题思路

##### 2.2.1.1 动态规划

###### 2.2.1.1.1 问题分析

1. 该题目中 $dp$ 数组的含义为 $dp[i]$ 表示以从第 $i$ 家开始偷窃，在不触动警报装置的情况下，一夜之内能够偷窃得到的最高金额，且：
   
   $$
   dp[i] = max(dp[i + 1], dp[i + 2] + nums[i])
   $$

###### 2.2.1.1.2 参考代码

```java
public int rob(int[] nums) {
    int m = nums.length;
    int[] dp = new int[m];

    //  base case
    if (m >= 1) {dp[m - 1] = nums[m - 1];}
    if (m >= 2) {dp[m - 2] = Math.max(nums[m - 1], nums[m - 2]);}
    for (int i = m - 3; i >= 0; i--) {
        dp[i] = Math.max(dp[i + 1], dp[i + 2] + nums[i]);
    }

    return dp[0];
}
```

### 2.3 [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray)

#### 2.3.1 解题思路

##### 2.3.1.1 动态规划

###### 2.3.1.1.1 问题分析

1. 对于这种**含有不定状态的最值问题**，一般可以通过**设置多个 $dp$ 数组来求解**，**分别用不同的 $dp$ 数组来表示不同的状态**。
2. 在本题中，假如我们直接**使用一个 $dp$ 数组**，其中 $dp[i]$**表示以第 $i$ 个元素结尾的最大连续子数组的乘积**，此时**当前位置的最优解未必是由前一个位置的最优解转移得到**。
3. 因此，我们可以**根据正负性进行讨论**：
   1. 如果**当前位置是一个负数**的话，那么**我们希望以他前一个位置结尾的某个段的积也是个负数**，**这样就可以负负得正**，**并且我们希望这个积尽可能负得多**，即**尽可能小**。
   2. 如果**当前位置是一个正数的话**，那么**我们希望以他前一个位置结尾的某个段的积也是个正数**，**并且我们希望这个积尽可能大**。
4. 因此我们需要**维护两个 $dp$ 数组**，**分别是 $dp_{max}$ 和**$dp_{min}$：
   1. $dp_{max}$ 表示**以第 $i$ 个元素结尾的最大连续子数组的乘积**，且：
      
      $$
      dp_{max} = max(dp_{max}[i - 1] \times nums[i], dp_{min}[i - 1] \times nums[i], nums[i])
      $$
   2. $dp_{min}$ 表示**以第 $i$ 个元素结尾的最小连续子数组的乘积**，且：
      
      $$
      dp_{min} = min(dp_{max}[i - 1] \times nums[i], dp_{min}[i - 1] \times nums[i], nums[i])
      $$

###### 2.3.1.1.2 参考代码

```java
/**
 * 152. 乘积最大子数组（版本 1：动态规划（优化前））
 *
 * @param nums 数组
 * @return 数组中乘积最大的连续子数组的乘积
 */
public int maxProductV1(int[] nums) {
    int m = nums.length;
    //  dp 数组，dpMax[i] 表示以第 i 个元素结尾的最大连续子数组的乘积
    int[] dpMax = new int[m];
    //  dp 数组，dpMin[i] 表示以第 i 个元素结尾的最小连续子数组的乘积
    int[] dpMin = new int[m];
    int res;

    dpMax[0] = nums[0];
    dpMin[0] = nums[0];
    res = dpMax[0];
    for (int i = 1; i < m; i++) {
        int item = nums[i];

        //  dpMax[i] = max(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])
        dpMax[i] = Math.max(
                dpMax[i - 1] * item,
                Math.max(
                        dpMin[i - 1] * item,
                        item
                )
        );

        //  dpMin[i] = min(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])
        dpMin[i] = Math.min(
                dpMax[i - 1] * item,
                Math.min(
                        dpMin[i - 1] * item,
                        item
                )
        );

        //  去 dpMax 中的最大值
        res = Math.max(res, dpMax[i]);
    }

    //  返回最后结果
    return res;
}
```

由于**第 $i$ 个状态只和第 $i - 1$ 个状态相关**，根据**滚动数组**思想，我们可以**只用两个变量来维护 $i - 1$ 时刻的状态**，**一个维护 $dpMax$**，**一个维护 $dpMin$**。

```java
/**
 * 152. 乘积最大子数组（版本 2：动态规划（优化后））
 *
 * @param nums 数组
 * @return 数组中乘积最大的连续子数组的乘积
 */
public int maxProductV2(int[] nums) {
    int m = nums.length;
    //  dpMax 表示以第 i 个元素结尾的最大连续子数组的乘积
    int dpMax = nums[0];
    //  dpMin 表示以第 i 个元素结尾的最小连续子数组的乘积
    int dpMin = nums[0];
    int res;

    res = dpMax;
    for (int i = 1; i < m; i++) {
        int item = nums[i];
        int dpMaxTemp = dpMax, dpMinYemp = dpMin;

        //  dpMax = max(dpMaxTemp * nums[i], dpMinYemp * nums[i], nums[i])
        dpMax = Math.max(
                dpMaxTemp * item,
                Math.max(
                        dpMinYemp * item,
                        item
                )
        );

        //  dpMin = min(dpMaxTemp * nums[i], dpMinYemp * nums[i], nums[i])
        dpMin = Math.min(
                dpMaxTemp * item,
                Math.min(
                        dpMinYemp * item,
                        item
                )
        );

        //  去 dpMax 中的最大值
        res = Math.max(res, dpMax);
    }

    //  返回最后结果
    return res;
}
```

### 2.4 [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

#### 2.4.1 解题思路

##### 2.4.1.1 动态规划

###### 2.4.1.1.1 问题分析

1. 该题目中 $dp$ 数组的含义为 $dp[i][j]$**表示从顶点到 $triangle.get(i).get(j)$ 的最小路径和**，且：
   
   $$
   dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j)
   $$

###### 2.4.1.1.2 参考代码

```java
/**
 * 120. 三角形最小路径和
 *
 * @param triangle 三角形顶点列表
 * @return 三角形自顶向下的最小路径和
 */
public int minimumTotal(List<List<Integer>> triangle) {
    int m = triangle.size();
    int n = triangle.get(m - 1).size();
    //  dp 数组，其中 dp[i][j] 表示从顶点到 triangle.get(i).get(j) 的最小路径和
    int[][] dp = new int[m][n];
    int res = Integer.MAX_VALUE;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < triangle.get(i).size(); j++) {
            int item = triangle.get(i).get(j);

            //  转移关系为：dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j)
            //  需要确保数组下标不要越界，即：i - 1 >= 0 && j - 1 >= 0 && j < triangle.get(i - 1).size()
            if (i - 1 >= 0) {
                if (j - 1 >= 0) {
                    if (j < triangle.get(i - 1).size()) {
                        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + item;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + item;
                    }
                } else {
                    dp[i][j] = dp[i - 1][j] + item;
                }
            } else {
                dp[i][j] = item;
            }
        }
    }

    //  三角形最后一行中的最小路径和即为整个三角形自顶向下的最小路径和
    for (int i = 0; i < triangle.get(m - 1).size(); i++) {
        res = Math.min(res, dp[m - 1][i]);
    }

    return res;
}
```

### 2.5 [解码方法](https://leetcode-cn.com/problems/decode-ways/)

#### 2.5.1 解题思路

##### 2.5.1.1 动态规划

###### 2.5.1.1.1 问题分析

1. 动态规划中：
   
   1. 对于**一维 $dp$ 数组**一般**有两种思路**，**一种是以 $nums[i]$ 开头**，**另一种是以 $nums[i]$ 结尾**，我们在定义 $dp$ 数组时可以**从这两个方面去考虑**即可。
   2. 对于**二维 $dp$ 数组**一般**可以从中间进行截取**，例如[1.1.7 最长回文子序列](https://notebook.ricear.com/project-21/doc-273)中 $dp$ 数组的定义为 $dp[i][j]$ 表示 $s[i...j]$ 中包含的最长回文子序列的长度。
2. 该题目中 $dp$ 数组的含义为 $dp[i]$ 表示以 $s.charAt(i)$ 开头的字符串的解码方法的总数，且：
   
   $$
   dp[i] = dp[i + 1] + dp[i + 2]
   $$

###### 2.5.1.1.2 参考代码

```java
/**
 * 91. 解码方法
 *
 * @param s 消息字符串
 * @return 消息字符串解码方法的总数
 */
public int numDecodings(String s) {
    int m = s.length();
    //  dp 数组，其中 dp[i] 表示以 s.charAt(i) 开头的消息字符串解码方法的总数
    int[] dp = new int[m];

    for (int i = m - 1; i >= 0; i--) {
        //  如果当前字符为 0，那么以该字符开头的字符串的解码方法总数为 0
        if (s.charAt(i) == '0') {dp[i] = 0;}
        //  如果当前字符不为 0，并且当前字符位于最后一个位置，那么以该字符开头的字符串的解码方法总数为 1
        else if (i == m - 1) {dp[i] = 1;}
        //  当前字符不为 0，并且当前字符位于倒数第二个位置
        else if (i == m - 2) {
            //  如果当前字符及其后两位所组成的数字大于 26，则当前字符及其后两位字符组成的字符串不能被解码，
            //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
            if (Integer.parseInt(s.substring(i, i + 2)) > 26) {dp[i] = dp[i + 1];}
            //  如果当前字符及其后两位所组成的数字不大于 26，则当前字符及其后两位字符组成的字符串可以被解码，
            //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数加 1
            else {dp[i] = dp[i + 1] + 1;}
        }
        //  当前字符不为 0，并且当前字符不位于倒数第二个位置
        //  如果当前字符及其后两位所组成的数字大于 26，则当前字符及其后两位字符组成的字符串不能被解码，
        //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
        else if (Integer.parseInt(s.substring(i, i + 2)) > 26) {dp[i] = dp[i + 1];}
        //  如果当前字符及其后两位所组成的数字不大于 26，则当前字符及其后两位字符组成的字符串可以被解码，
        //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数及以下面第二个字符开头的字符串的解码方法总数
        else {dp[i] = dp[i + 1] + dp[i + 2];}
    }

    //  返回最后的结果
    return dp[0];
}
```

#### 2.6.2 扩展题目

##### 2.6.2.1 [把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof)

###### 2.6.2.1.1 问题分析

1. 参见[解码方法](#2-5-1-1-1-问题分析)。

###### 2.6.2.1.2 参考代码

```java
/**
 * 剑指 Offer 46. 把数字翻译成字符串
 * @param num   待翻译的数字
 * @return  数字翻译后的字符串
 */
public int translateNum(int num) {
    String s = String.valueOf(num);
    int m = s.length();
    //  dp 数组，其中 dp[i] 表示以 s.charAt(i) 开头的消息字符串解码方法的总数
    int[] dp = new int[m];

    for (int i = m - 1; i >= 0; i--) {
        //  如果当前字符位于最后一个位置，那么以该字符开头的字符串的解码方法总数为 1
        if (i == m - 1) {dp[i] = 1;}
        //  当前字符位于倒数第二个位置
        else if (i == m - 2) {
            //  如果当前字符及其后两位所组成的数字大于 25 或当前字符为 0，则当前字符及其后两位字符组成的字符串不能被解码，
            //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
            if (Integer.parseInt(s.substring(i, i + 2)) > 25 || s.charAt(i) == '0') {dp[i] = dp[i + 1];}
            //  如果当前字符及其后两位所组成的数字不大于 26，则当前字符及其后两位字符组成的字符串可以被解码，
            //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数加 1
            else {dp[i] = dp[i + 1] + 1;}
        }
        //  当前字符不位于倒数第二个位置
        //  如果当前字符及其后两位所组成的数字大于 25 或当前字符为 0，则当前字符及其后两位字符组成的字符串不能被解码，
        //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
        else if (Integer.parseInt(s.substring(i, i + 2)) > 25 || s.charAt(i) == '0') {dp[i] = dp[i + 1];}
        //  如果当前字符及其后两位所组成的数字不大于 25，则当前字符及其后两位字符组成的字符串可以被解码，
        //  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数及以下面第二个字符开头的字符串的解码方法总数
        else {dp[i] = dp[i + 1] + dp[i + 2];}
    }

    //  返回最后的结果
    return dp[0];
}
```

### 2.6 [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

#### 2.6.1 解题思路

##### 2.6.1.1 动态规划

###### 2.6.1.1.1 问题分析

1. 对于这种**圆环型**的问题，我们可以**把他拆分成两部分**，并对其**分别去求结果**，然后再**将两部分的结果取最值**即可。
2. 该题目中 $dp$ 数组的含义为 $dp[i]$ 表示第 $i$ 户及之后所能偷到的最大金额，且：
   
   $$
   dp[i] = max(dp[i + 1], dp[i + 2] + nums[i]);
   $$

###### 2.6.1.1.2 参考代码

```java
/**
 * 213. 打家劫舍 II
 * @param nums  每个房屋存放金额的非负整数数组
 * @return  在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
 */
public int rob(int[] nums) {
    int m = nums.length;
    //  将整个数组拆分成两部分，分别为 nums[0, nums.length - 2] 和 nums[1, nums.length - 1]，然后对这两部分分别求能够偷窃到的最大金额，并取二者的最大值即可
    return m > 1 ? Math.max(subRob(nums, 0, m - 1), subRob(nums, 1, m)) : nums[0];
}

/**
 * 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
 * @param nums  每个房屋存放金额的非负整数数组
 * @param start 起始位置
 * @param end   结束位置
 * @return  在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
 */
public int subRob(int[] nums, int start, int end) {
    int m = nums.length;
    //  dp 数组，其中 dp[i] 表示从第 i 户及后面住户中所能偷窃到的最高金额
    int[] dp = new int[m];

    //   base case
    if (end >= 1) {
        dp[end - 1] = nums[end - 1];
    }
    if (end >= 2) {
        if (nums[end - 2] >= nums[end - 1]) {
            dp[end - 2] = nums[end - 2];
        } else {
            dp[end - 2] = nums[end - 1];
        }
    }

    for (int i = end - 3; i >= start; i--) {
        //  第 i 户及之后所能偷到的最大金额 等于 第 i 户及之后所能偷到的最大金额 与 第 i + 2 户所能偷到的最大金额和第 i 户金额之和 的最大值
        dp[i] = Math.max(dp[i + 1], dp[i + 2] + nums[i]);
    }

    return dp[start];
}
```

### 2.7 [最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray)

#### 2.7.1 解题思路

##### 2.7.1.1 暴力解法

###### 2.7.1.1.1 问题分析

1. 首先将 $nums2$ 中的元素对应的下标保存在 $map$ 中，这样便于查找 $nums1$ 中的元素是否在 $nums2$ 中出现。
2. 然后遍历 $nums1$，假设当前遍历的元素为 $item$：
   1. 如果 $item$ 没有在 $nums2$ 中出现，则直接返回。
   2. 如果 $item$ 在 $nums2$ 中出现，则以 $item$ 为起点，**同步遍历 $nums1$ 和 $nums2$ 的后续元素**，**直到两个数组中对应元素不相等**，**或达到任意数组的边界**，**计算两个数组相应部分的的重复子数组的大小**，并**对最终的结果进行更新**。
3. 最后返回最终结果即可。

###### 2.7.1.1.2 参考代码

```java
/**
 * 718. 最长重复子数组（版本 1：暴力解法）
 * @param nums1 数组 1
 * @param nums2 数组 2
 * @return  两个数组中公共的、长度最长的子数组的长度
 */
public int findLengthV1(int[] nums1, int[] nums2) {
    Map<Integer, Map<Integer, Integer>> map = new HashMap<>();
    int n1 = nums1.length;
    int n2 = nums2.length;
    int maxLength = 0;

    //  将 nums2 中的元素对应的下标保存在 map 中，这样便于查找 nums1 中的元素是否在 nums2 中出现
    for (int i = 0; i < n2; i++) {
        int item = nums2[i];
        if (!map.containsKey(item)) {
            Map<Integer, Integer> mapTemp = new HashMap<>();
            mapTemp.put(i, 0);
            map.put(item, mapTemp);
        } else {
            Map<Integer, Integer> mapTemp = map.get(item);
            mapTemp.put(i, 0);
            map.put(item, mapTemp);
        }
    }

    //  遍历 nums1
    for (int i = 0; i < n1; i++) {
        int item = nums1[i];
        //  item 没有在 nums2 中出现，直接返回
        if (!map.containsKey(item)) {continue;}
        //  item 在 nums2 中出现，获取其在 nums2 中对应的下标
        Map<Integer, Integer> mapTemp = map.get(item);
        //  依次以 item 在 nums2 中的下标的下一个位置为起点，计算两个数组的重复子数组的大小
        for (Map.Entry<Integer, Integer> entry: mapTemp.entrySet()) {
            int tempLength = 1;
            int key = entry.getKey();
            for (int j = key + 1; j < n2; j++) {
                if (i + tempLength >= n1) {break;}
                if (nums1[i + tempLength] != nums2[j]) {break;}
                tempLength++;
            }
            maxLength = Math.max(maxLength, tempLength);
        }
    }

    //  返回结果
    return maxLength;
}
```

##### 2.7.1.2 动态规划

###### 2.7.1.2.1 问题分析

1. 对于求**最值**的题目，都可以思考一下看是否可以用**动态规划**来求解，而**动态规划的核心就是定义 $dp$ 数组**，**寻找状态转移方程**。
2. $dp$**数组的定义有一维和二维数组两种**，这个**需要根据具体的题目来具体分析**。
3. 本题中 $dp$ 数组可以定义为 $dp[i][j]$，**表示 $nums1[i]$ 和 $nums2[j]$ 的最长公共前缀的长度**，这样 $dp$**数组中最大的元素即为 $nums1$ 和 $nums2$ 的最长重复子数组的长度**。
4. 然后分别遍历 $nums1$ 和 $nums2$：
   
   1. **如果 $nums1[i] = nums2[j]$**，**则 $dp[i][j] = dp[i + 1][j + 1] + 1$**。
   2. **否则**，$dp[i][j] = 0$。
      > 该题目类似于[最长公共子序列](#1-3-最长公共子序列)，不同的是在最长公共子序列中当 $nums1[i] \ne nums2[j]$ 时，$dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])$，而在最长重复子数组中当 $nums1[i] \ne nums2[j]$ 时，$dp[i][j] = 0$，这是因为**序列不要求连续**，而**数组要求连续**。
   
   ![](https://notebook.ricear.com/media/202107/2021-07-16_212026.png)

###### 2.7.1.2.2 参考代码

```java
/**
 * 718. 最长重复子数组（版本 2：动态规划）
 * @param nums1 数组 1
 * @param nums2 数组 2
 * @return  两个数组中公共的、长度最长的子数组的长度
 */
public int findLengthV2(int[] nums1, int[] nums2) {
    int n1 = nums1.length;
    int n2 = nums2.length;
    int res = 0;
    //  dp 数组，其中 dp[i][j] 表示 nums1[i:] 和 nums2[j:] 的最长公共前缀的长度，则 dp 数组中最大的元素即为 nums1 和 nums2 的最长重复子数组的长度
    int[][] dp = new int[n1 + 1][n2 + 1];

    //  分别遍历 nums1 和 nums2，计算最长重复子数组的长度
    for (int i = n1 - 1; i >= 0; i--) {
        for (int j = n2 - 1; j >=0; j--) {
            //  如果 nums1[i] = nums2[j]，则 dp[i][j] = dp[i + 1][j + 1]，否则，dp[i][j] = 0
            dp[i][j] = (nums1[i] == nums2[j] ? dp[i + 1][j + 1] + 1 : 0);
            res = Math.max(res, dp[i][j]);
        }
    }

    //  返回结果
    return res;
}
```

##### 2.7.1.3 滑动窗口

###### 2.7.1.3.1 问题分析

1. 对于**两个数组的遍历**，可以**通过滑动窗口的方法来减少遍历的次数**，因为**每次比较的只是滑动窗口内部相同区域的元素**，**相比于暴力解法而言**，**可以显著减少遍历的次数**。
2. 本题目中可以先**把 $nums1$ 放在上面**，$nums2$**放在下边**，然后**将 $nums1$ 的第一个元素和 $nums2$ 的最后一个元素对齐**，然后**将 $nums2$ 从做往右滑动**，**直到 $nums1$ 的第一个元素和 $nums2$ 的第一个元素对齐**，且**每滑动一次**，**都对两个数组滑块内部相同区域的元素进行比较**。
3. 然后**把 $nums2$ 放在上面**，$nums1$**放在下面**，并且**把 $nums2$ 的第一个元素和 $nums1$ 的第一个元素对齐**，然后**把 $nums1$ 从右往左滑动**，**直到 $nums2$ 的第一个元素和 $nums1$ 的最后一个元素对齐**，且**每滑动一次**，**都对两个数组滑块内部相同区域的元素进行比较**。
4. 其实**第三步可以合到第二步里面**，即**在第二步中一直把 $nums2$ 滑动到第一个元素和 $nums1$ 的第一个元素对齐**，但这样**不太好实现**，因此**后面一步拆分成等价的第四步来实现**。
   
   ![](https://notebook.ricear.com/media/202107/718-最长重复子数组（解法三：滑动窗口）_1626441966.gif)

###### 2.7.1.3.2 参考代码

```java
/**
 * 718. 最长重复子数组（版本 3：滑动窗口）
 * @param nums1 数组 1
 * @param nums2 数组 2
 * @return  两个数组中公共的、长度最长的子数组的长度
 */
public int findLengthV3(int[] nums1, int[] nums2) {
    int n1 = nums1.length;
    int n2 = nums2.length;
    int res = 0;

    //  nums1 的第一个元素和 nums2 的最后一个元素对齐，然后将 num2 从左往右滑动，直到 nums2 的第一个元素和 nums1 的第一个元素对齐
    for (int i = n2 - 1; i >= 0; i--) {
        int minLen = Math.min(n1, n2 - i);
        int tempRes = 0;
        //  遍历 nums1 和 nums2 交叉的部分，并计算这一部分的最长重复子数组的长度
        for (int j = 0; j < minLen; j++) {
            if (tempRes != 0 && nums1[j] != nums2[i + j]) {
                res = Math.max(res, tempRes);
                tempRes = 0;
            }
            if (nums1[j] == nums2[i + j]) {
                tempRes++;
            }
        }
        res = Math.max(res, tempRes);
    }

    //  nums2 的第一个元素和 nums1 的第一个元素对齐，然后将 num1 从右往左滑动，直到 nums2 的第一个元素和 nums1 的最后一个元素对齐
    for (int i = 0; i < n1; i++) {
        int minLen = Math.min(n1 - i, n2);
        int tempRes = 0;
        //  遍历 nums1 和 nums2 交叉的部分，并计算这一部分的最长重复子数组的长度
        for (int j = 0; j < minLen; j++) {
            if (tempRes != 0 && nums1[i + j] != nums2[j]) {
                res = Math.max(res, tempRes);
                tempRes = 0;
            }
            if (nums1[i + j] == nums2[j]) {
                tempRes++;
            }
        }
        res = Math.max(res, tempRes);
    }

    return res;
}
```

## 参考文献

1. [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)。
2. [动态规划设计：最长递增子序列](https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-1/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie)。
3. [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)。
4. [动态规划之子序列问题解题模板](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zi-xu-lie-lei-xing-wen-ti/zi-xu-lie-wen-ti-mo-ban)。
5. [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray)。
6. [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber)。
7. [最大子序和 c++ 实现四种解法 暴力法、动态规划、贪心法和分治法 图示讲解](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f)。
8. [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray)。
9. [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution)。
10. [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle)。
11. [91. 解码方法](https://leetcode-cn.com/problems/decode-ways)。
12. [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii)。
13. [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray)。
14. [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)。
15. [最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode-solution)。
16. [滑动窗口解法](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2)。
17. [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof)。






<h1 style='page-break-before: always;'>1.0.4 编辑距离</h1>

## 1 题目

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

* 插入一个字符
* 删除一个字符
* 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

* 0 <= word1.length, word2.length <= 500
* word1 和 word2 由小写英文字母组成

## 2 解题思路

### 2.1 递归

#### 2.1.1 问题解析

**解决两个字符串的动态规划问题，一般都是用两个指针 `i、j` 分别指向两个字符串的最后，然后一步一步往前走，缩小问题的规模。**

设两个字符串分别为 `rad` 和 `apple`，为了把 `s1` 变成 `s2`，算法会这样进行：

![](../../media/202104/2021-04-06_204148.png)

根据上面的 GIF，可以发现操作不止有三个，其实还有第四个操作，就是什么都不要做（skip），比如这个情况：

![](../../media/202104/2021-04-06_204612.png)

因为这两个字符本来就相同，为了使编辑距离最小，显然不应该对他们有任何操作，直接往前移动 `i、j` 即可。

还有一个很容易处理的情况，就是 `j` 走完 `s2` 时，如果 `i` 还没走完 `s1`，那么只能用删除操作把 `s1` 缩短为 `s2`，比如这个情况：

![](../../media/202104/2021-04-06_204858.png)

类似的，如果 `i` 走完 `s1` 时 `j` 还没走完 `s2`，那就只能用插入操作把 `s2` 剩下的字符全部插入 `s1`，这两种情况就是算法的**base case**。

#### 2.1.2 代码解析

先梳理下之前的思路：

**base case**是 `i` 走完 `s1` 或 `j` 走完 `s2`，可以直接返回另一个字符串剩下的长度。

对于每队字符 `s1[i]` 和 `s2[j]`，可以有四种操作：

```c++
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）
```

对于这三个操作，需要全试一遍，哪个操作最后得到的编辑距离小，就选谁，具体代码如下：

```c++
def minDistance(s1, s2) -> int:

    def dp(i, j):
        # base case
        if i == -1: return j + 1
        if j == -1: return i + 1

        if s1[i] == s2[j]:
            return dp(i - 1, j - 1)  # 啥都不做
        else:
            return min(
                dp(i, j - 1) + 1,    # 插入
                dp(i - 1, j) + 1,    # 删除
                dp(i - 1, j - 1) + 1 # 替换
            )

    # i，j 初始化指向最后一个索引
    return dp(len(s1) - 1, len(s2) - 1)
```

下面对这段递归代码进行以下解释。

1. **dp[i][j]表示将 `s1[i]` 之前的字符修改为 `s2[j]` 之前的字符的最小编辑距离。**

```c++
def dp(i, j) -> int
```

2. **如果 `s1[i]==s2[j]`：**
   1. **说明这两个字符本来就相等，不需要进行任何操作。**
   2. **此时 `s1[0..i]` 和 `s2[0..j]` 的最小编辑距离等于 `s1[0..i-1]` 和 `s2[0..j-1]` 的最小编辑距离。**
   3. **`dp(i,j)` 等于 `dp(i-1,j-1)`。**

```c++
if s1[i] == s2[j]:
    return dp(i - 1, j - 1)
```

3. **如果 `s1[i]!=s2[j]`，此时就需要对三个操作递归了：**
   1. **插入：** **直接在 `s1[i]` 插入一个和 `s2[j]` 相同的字符，那么 `s2[j]` 就被匹配了，前移 `j`，继续跟 `i` 对比，同时操作数加 1。**

      ```c++
      dp(i, j - 1) + 1,    # 插入
      ```

      ![](../../media/202104/2021-04-06_210959.png)
   2. **删除：** **直接把 `s[i]` 这个字符删掉，前移 `i`，继续跟 `j` 对比，同时操作数加 1。**

      ```c++
      dp(i - 1, j) + 1,    # 删除
      ```

      ![](https://gblobscdn.gitbook.com/assets%2F-MWvhB2heCSJoT6IpxDY%2Fsync%2F36559b37dd118d77713ebc57ecfdcf11a2de599a.gif?alt=media)
   3. **替换：直接把 `s1[i]` 替换成 `s2[j]`，这样他俩就匹配了，然后前移 `i、j`，并将其继续对比，同时操作数加 1。**

      ```c++
      dp(i - 1, j - 1) + 1 # 替换
      ```

      ![](https://gblobscdn.gitbook.com/assets%2F-MWvhB2heCSJoT6IpxDY%2Fsync%2Fb2153166d681c0557bb40d2276f9b5707ba9b252.gif?alt=media)

#### 2.1.3 参考代码

```java
/**
 * 返回三个数之间的最小值
 * @param a 第一个参数
 * @param b 第二个参数
 * @param c 第三个参数
 * @return  三个数之间的最小值
 */
int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}

/**
 * dp 函数（版本 1）
 * @param s1    第一个字符串
 * @param s2    第二个字符串
 * @param i s1 的最后一个字符下标
 * @param j s2 的最后一个字符下标
 * @return  s1 前 i 个字符替换成 s2 前 j 个字符所需要的最小编辑次数
 */
int dpV1(String s1, String s2, int i, int j) {
    //  base case
    //  1. 如果第一个单词遍历到最左边，则把 s2 剩余测字符全插入到 s1 前面
    if (i == -1) {return j + 1;}
    //  2. 如果第二个单词遍历到最左边，则把 s1 剩余字符都删除
    if (j == -1) {return i + 1;}

    //  如果两个字符串当前字符相同，则啥也不做
    if (s1.charAt(i) == s2.charAt(j)) {return dpV1(s1, s2, i - 1, j - 1);}
    else {
        //  否则，一次尝试插入、删除、替换三种操作，并返回编辑距离最小的距离
        return min(
                //  插入
                dpV1(s1, s2, i, j - 1) + 1,
                //  删除
                dpV1(s1, s2, i - 1, j) + 1,
                dpV1(s1, s2, i - 1, j - 1) + 1
        );
    }
}

/**
 * 72. 编辑距离（版本 1：动态规划）
 * 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
 * 你可以对一个单词进行如下三种操作：
 * 插入一个字符
 * 删除一个字符
 * 替换一个字符
 * @param word1 第一个单词
 * @param word2 第二个单词
 * @return  最少操作数
 */
public int minDistanceV1(String word1, String word2) {
    return dpV1(word1, word2, word1.length() - 1, word2.length() - 1);
}
```

### 2.2 动态规划优化

动态规划的优化方法主要有两种，一种是**备忘录**，另一种是**DP Table**。

#### 2.2.1 备忘录优化

##### 2.2.1.1 问题解析

备忘录优化主要是把上面递归方法中的 `dp(i,j)` 的数据保存在**备忘录**（实质是一个二维数组）中，每次递归时先判断 `dp(i,j)` 的数据有没有在备忘录中，如果有的话直接返回，没有的话再进行计算即可。

##### 2.2.1.2 参考代码

```java
/**
 * 返回三个数之间的最小值
 * @param a 第一个参数
 * @param b 第二个参数
 * @param c 第三个参数
 * @return  三个数之间的最小值
 */
int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}

/**
 * dp 函数（版本 2：备忘录优化）
 * @param s1    第一个字符串
 * @param s2    第二个字符串
 * @param i s1 的最后一个字符下标
 * @param j s2 的最后一个字符下标
 * @return  s1 前 i 个字符替换成 s2 前 j 个字符所需要的最小编辑次数
 */
int dpV2(String s1, String s2, int i, int j, int[][] memo) {
    //  base case
    //  1. 如果第一个单词遍历到最左边，则把 s2 剩余测字符全插入到 s1 前面
    if (i == -1) {return j + 1;}
    //  2. 如果第二个单词遍历到最左边，则把 s1 剩余字符都删除
    if (j == -1) {return i + 1;}

    if (memo[i][j] != -1) {return memo[i][j];}

    //  如果两个字符串当前字符相同，则啥也不做
    if (s1.charAt(i) == s2.charAt(j)) {memo[i][j] = dpV2(s1, s2, i - 1, j - 1, memo);}
    else {
        //  否则，一次尝试插入、删除、替换三种操作，并返回编辑距离最小的距离
        memo[i][j] = min(
                //  插入
                dpV2(s1, s2, i, j - 1, memo) + 1,
                //  删除
                dpV2(s1, s2, i - 1, j, memo) + 1,
                dpV2(s1, s2, i - 1, j - 1, memo) + 1
        );
    }

    //  返回结果
    return memo[i][j];
}

/**
 * 72. 编辑距离（版本 2：动态规划（备忘录优化））
 * 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
 * 你可以对一个单词进行如下三种操作：
 * 插入一个字符
 * 删除一个字符
 * 替换一个字符
 * @param word1 第一个单词
 * @param word2 第二个单词
 * @return  最少操作数
 */
public int minDistanceV2(String word1, String word2) {
    //  定义备忘录，并将其里面的每个元素初始化为 -1
    int[][] memo = new int[word1.length()][word2.length()];
    for (int i = 0; i < memo.length; i++) {
        Arrays.fill(memo[i], -1);
    }
    //  递归获取最小编辑距离
    return dpV2(word1, word2, word1.length() - 1, word2.length() - 1, memo);
}
```

#### 2.2.2 DP Table 优化

##### 2.2.2.1 问题解析

1. **定义 `dp[i][j]`：**

   1. `dp[i][j]` 代表`word1` 中前`i` 个字符，变换到`word2` 中前`j` 个字符，最短需要操作的次数。
   2. 需要考虑`word1` 或`word2` 一个字母都没有，即**全增加**或**全删除**的情况，所以预留`dp[0][j]` 和`dp[i][0]`。
2. **状态转移：**

   1. **增：**`dp[i][j] = dp[i][j-1] + 1`
   2. **删：**`dp[i][j] = dp[i-1][j] + 1`
   3. **改：**`dp[i][j] = dp[i-1][j-1]`
   4. 按顺序计算，当计算`dp[i][j]` 时，`dp[i][j-1]、dp[i-1][j]、dp[i-1][j-1]` 均已经确定。
   5. 配合**增删改**这三种操作，需要对应的`dp` 把操作数加 1，取三种的最小。
   6. 如果刚好这两个字母相同，即`word1[i-1]=word2[j-1]`，那么可以直接参考`dp[i-1][j-1]`，操作不用加 1。

具体的图解如下：

* **绿色：** 增。
* **红色：** 删。
* **黄色：** 改。

![](../../media/202104/2021-04-06_220218.png)

![](../../media/202104/2021-04-06_220327.png)

![](../../media/202104/2021-04-06_220334.png)

![](../../media/202104/2021-04-06_220341.png)

![](../../media/202104/2021-04-06_220348.png)

![](../../media/202104/2021-04-06_220356.png)

##### 2.2.2.2 参考代码

```java
/**
 * 返回三个数之间的最小值
 * @param a 第一个参数
 * @param b 第二个参数
 * @param c 第三个参数
 * @return  三个数之间的最小值
 */
int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}

/**
 * 72. 编辑距离（版本 3：动态规划（DP Table 优化））
 * 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
 * 你可以对一个单词进行如下三种操作：
 * 插入一个字符
 * 删除一个字符
 * 替换一个字符
 * @param word1 第一个单词
 * @param word2 第二个单词
 * @return  最少操作数
 */
public int minDistanceV3(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
  
    //   base case
    for (int i = 1; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int j = 1; j <= n; j++) {
        dp[0][j] = j;
    }

    //  自底向上求解
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];}
            else {
                dp[i][j] = min(
                        dp[i][j - 1] + 1,
                        dp[i - 1][j] + 1,
                        dp[i - 1][j - 1] + 1
                );
            }
        }
    }

    //  储存着整个 word1 和 word2 的最小编辑距离
    return dp[m][n];
}
```

## 3 参考文献

1. [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance)。
2. [经典动态规划：编辑距离](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zi-xu-lie-lei-xing-wen-ti/bian-ji-ju-li)。
3. [【编辑距离】入门动态规划，你定义的 dp 里到底存了啥](https://leetcode-cn.com/problems/edit-distance/solution/edit-distance-by-ikaruga)。



<h1 style='page-break-before: always;'>1.0.5 高楼扔鸡蛋</h1>

## 1 题目

给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

**示例 1：**

```txt
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
```

**示例 2：**

```txt
输入：k = 2, n = 6
输出：3
```

**示例 3：**

```txt
输入：k = 3, n = 14
输出：4
```

**提示：**

* 1 <= k <= 100
* 1 <= n <= 104

## 2 解题思路

### 2.1 动态规划

#### 2.1.1 问题分析

我们可以考虑使用动态规划来做这道题，状态可以表示成 $(k,n)$，其中 $k$ 为鸡蛋数，$n$ 为楼层数。当我们从第 $x$ 楼扔鸡蛋的时候：

* 如果鸡蛋不碎，那么状态变成 $(k,n-x)$，即我们鸡蛋的数目不变，但答案只可能在上方的 $n-x$ 层楼了。也就是说，我们把原问题缩小成了一个规模为 $(k,n-x)$ 的子问题；
* 如果鸡蛋碎了，那么状态变成 $(k-1,x-1)$，即我们少了一个鸡蛋，但我们直到答案只可能在 $x$ 楼下方的 $x-1$ 层楼中了。也就是说，我们把原问题缩小成了一个规模为 $(k-1,x-1)$ 的子问题。

![](../../media/202104/2021-04-07_214952.png)

这样一来，我们定义 $dp(k,n)$ 为在状态 $(k,n)$ 下最少需要的步数。根据以上分析，我们可以列出状态转移方程：

$$
dp(k,n)=1+\min_{1 \leq x \leq n}(max(dp(k-1,x-1),dp(k,n-x)))
$$

这个状态转移方程是如何得来的呢？对于 $dp(k,n)$ 而言，我们像上面分析的那样，枚举第一个鸡蛋扔在的楼层数 $x$。由于我们并不知道真正的 $f$ 值，因此我们必须保证**鸡蛋碎了之后接下来需要的步数**和**鸡蛋没碎之后需要的步数**二者**最大值**最小，这样就保证了在**最坏情况下（也就是无论 $f$ 的值如何）**$dp(k,n)$ 的值最小。

#### 2.1.2 解题方法

动态规划的解法有**递归**、**备忘录优化**、**DP Table 优化**。

##### 2.1.2.1 递归方法

```java
/**
 * 最坏情况下扔鸡蛋的次数（版本 1：递归）
 *
 * @param k 鸡蛋个数
 * @param n 总楼层数
 * @return 最坏情况下扔鸡蛋的次数
 */
public int dpV1(int k, int n) {
    //  如果只有 1 个鸡蛋，则所有楼层都需要试一下
    if (k == 1) {
        return n;
    }
    //  如果楼层数为 0，则不需要进行尝试，直接返回 0 即可
    if (n == 0) {
        return 0;
    }

    int res = n;
    for (int i = 1; i <= n; i++) {
        res = Math.min(
                res,
                Math.max(
                        //  鸡蛋碎了
                        dpV1(k - 1, i - 1),
                        //  鸡蛋没碎
                        dpV1(k, n - i)
                ) + 1
        );
    }
    return res;
}

/**
 * 887. 鸡蛋掉落（版本 1：递归）
 * 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
 * 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
 * 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
 * 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
 *
 * @param k 目标楼层
 * @param n 总楼层
 * @return 要确定 f 确切的值 的 最小操作次数
 */
public int superEggDropV1(int k, int n) {
    return dpV1(k, n);
}
```

##### 2.1.2.2 备忘录优化

```java
/**
 * 最坏情况下扔鸡蛋的次数（版本 2：备忘录优化）
 *
 * @param k 鸡蛋个数
 * @param n 总楼层数
 * @return 最坏情况下扔鸡蛋的次数
 */
public int dpV2(int k, int n, int[][] memo) {
    //  如果只有 1 个鸡蛋，则所有楼层都需要试一下
    if (k == 1) {
        return n;
    }
    //  如果楼层数为 0，则不需要进行尝试，直接返回 0 即可
    if (n == 0) {
        return 0;
    }

    //  如果数据在备忘录中已经存在的话，直接返回即可
    if (memo[k][n] != Integer.MAX_VALUE) {
        return memo[k][n];
    }

    for (int i = 1; i <= n; i++) {
        memo[k][n] = Math.min(
                memo[k][n],
                Math.max(
                        //  鸡蛋碎了
                        dpV2(k - 1, i - 1, memo),
                        //  鸡蛋没碎
                        dpV2(k, n - i, memo)
                ) + 1
        );
    }
    return memo[k][n];
}

/**
 * 887. 鸡蛋掉落（版本 2：备忘录优化）
 * 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
 * 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
 * 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
 * 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
 *
 * @param k 目标楼层
 * @param n 总楼层
 * @return 要确定 f 确切的值 的 最小操作次数
 */
public int superEggDropV2(int k, int n) {
    //  备忘录
    int[][] memo = new int[k + 1][n + 1];
    for (int i = 0; i < memo.length; i++) {
        Arrays.fill(memo[i], Integer.MAX_VALUE);
    }
    return dpV2(k, n, memo);
}
```

##### 2.1.2.3 二分查找优化

如果我们直接暴力求解每个状态的 $dp$ 值，时间复杂度为 $O(kn^2)$，即一共有 $O(kn)$ 个状态，对于每个状态枚举扔鸡蛋的楼层 $x$，需要 $O(n)$ 的时间。这无疑在当前数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。

随我们观察到 $dp(k,n)$ 是一个关于 $n$ 的单调递增函数，也就是说在鸡蛋数 $k$ 固定的情况下，楼层数 $n$ 越多，需要的步数一定不会变少。在**2.1.1 问题分析**中的状态转移方程中，第一项 $T_1(x)=dp(k-1,x-1)$ 是一个随 $x$ 的增加而单调递增的函数，第二项 $T_2(x)=dp(k,n-x)$ 是一个随着 $x$ 的增加而单调递减的函数。

![887_fig1.jpg (2560×1213)](/media/202104/2021-04-08_141222.png)

如上图所示，如果这两个函数都是连续函数，那么我们只需要找出这两个函数的交点，在交点处就能保证这两个函数的最大值最小。但在本题中，$T_1(x)$ 和 $T_2(x)$ 都是离散函数，也就是说 $x$ 的值只能取 1、2、3 等等。在这种情况下，我们需要找到最大的满足 $T_1(x) \lt T_2(x)$ 中的 $x_0$，以及最小的满足 $T_1(x) \ge T_2(x)$ 的 $x_1$，对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。

我们只需要比较在 $x_0$ 和 $x_1$ 处两个函数的最大值，取一个最小的作为 $x$ 即可。

参考代码如下：

```java
/**
 * 最坏情况下扔鸡蛋的次数（版本 3：二分查找优化）
 *
 * @param k 鸡蛋个数
 * @param n 总楼层数
 * @return 最坏情况下扔鸡蛋的次数
 */
public int dpV3(int k, int n, int[][] memo) {
    //  如果只有 1 个鸡蛋，则所有楼层都需要试一下
    if (k == 1) {
        return n;
    }
    //  如果楼层数为 0，则不需要进行尝试，直接返回 0 即可
    if (n == 0) {
        return 0;
    }

    //  如果数据在备忘录中已经存在的话，直接返回即可
    if (memo[k][n] != Integer.MAX_VALUE) {
        return memo[k][n];
    }

    int left = 1, right = n + 1, res = Integer.MAX_VALUE;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        //  鸡蛋碎了
        int broken = dpV3(k - 1, mid - 1, memo);
        //  鸡蛋没碎
        int notBroken = dpV3(k, n - mid, memo);
        if (broken > notBroken) {
            right = mid - 1;
            res = Math.min(res, broken + 1);
        } else if (broken < notBroken) {
            left = mid + 1;
            res = Math.min(res, notBroken + 1);
        } else if (broken == notBroken) {
            right = mid - 1;
            res = Math.min(res, broken + 1);
        }
    }
    memo[k][n] = res;
    return res;
}
```

## 3 参考文献

1. [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop)。
2. [《鸡蛋掉落》官方题解](https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2)。



<h1 style='page-break-before: always;'>1.0.6 股票问题系列通解</h1>

> 本篇文章转载自[ 股票问题系列通解（转载翻译）](https://leetcode-cn.com/circle/article/qiAgHn)。

## 1 前言

1. 股票问题一共有六道题，链接如下：
   * [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)。
   * [122. 买卖股票的最佳时机 II]()。
   * [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)。
   * [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)。
   * [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)。
   * [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)。
2. 每个问题都有优质的题解，但是大多数题解没有建立起这些问题之间的联系，也没有给出股票问题系列的通解，这篇文章给出适用于全部股票问题的通解，以及对于每个特定问题的特解。

## 2 通用情况

1. 这个想法基于如下问题，**给定一个表示每天股票价格的数组**，**什么因素决定了可以获得的最大收益**，相信大多数人可以很快给出答案，例如**在那些天进行交易以及允许多少次交易**，这些因素当然也很重要，在问题描述中也有这些因素，然而还有一个隐藏但是关键的因素决定了最大收益，下文将阐述这一点。
2. 首先介绍一些符号：
   1. 用 $n$**表示股票价格的数组**。
   2. 用 $i$**表示第 $i$ 天**（$i$ 的取值范围是 0 到 $n - 1$）。
   3. 用 $k$**表示允许的最大交易次数**。
   4. 用 $T[i][k]$**表示在第 $i$ 天结束时**，**最多进行 $k$ 次交易的情况下可以获得的最大收益**。
3. **基准情况为 $T[-1][k] = T[i][0] = 0$**，**表示没有进行股票交易时没有收益**（注意第一天对应 $i = 0$，因此 $i = -1$ 表示没有股票交易）。
4. 现在开始**将 $T[i][k]$ 关联到子问题**，**得到状态转移方程**：
   1. **第 $i$ 天可能有三个操作**，分别为**买入**、**卖出**、**休息**。
   2. 我们并**不知道哪个操作是最好的**，但是**可以通过计算得到选择每个操作可以得到的最大收益**，**假设没有别的限制条件**，则**可以尝试每一种操作**，并**选择可以最大化收益的一种操作**，但是，**题目中确实有限制条件**，**规定不能同时进行多次交易**，因此**如果决定在第 $i$ 天买入**，**在买入之前必须持有 0 份股票**，**如果决定在第 $i$ 天卖出**，**在卖出之前必须恰好持有 1 份股票**，**持有股票的数量是上文提及到的隐藏因素**，**该因素影响第 $i$ 天可以进行的操作**，**进而影响最大收益**。
   3. 因此对 $T[i][k]$ 的定义需要分成两项：
      1. $T[i][k][0]$**表示第 $i$ 天结束时**，**最多进行 $k$ 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益**。
      2. $T[i][k][1]$**表示在第 $i$ 天结束时**，**最多进行 $k$ 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益**。
   4. 使用新的状态表示之后，可以得到基准情况和状态转移方程如下：
      1. **基准情况**：

         $$
         T[-1][k][0] = 0, T[-1][k][1] = -Infinity
         $$

         $$
         T[i][0][0] = 0, T[i][0][1] = -Infinity
         $$

         1. 基准情况中，$T[-1][k][0] = T[i][0][0] = 0$ 的含义和上文相同，$T[-1][k][1] = T[i][0][1]$ 的含义是**在没有进行股票交易时不允许持有股票**。
      2. **状态转移方程**：

         $$
         T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
         $$

         $$
         T[i][k][1] = max(T[i - 1][k - 1][0] - prices[i], T[i - 1][k][1])
         $$

         1. **对于状态转移方程中的**$T[i][k][0]$，**第 $i$ 天进行的操作只能是休息或卖出**，因为**在第 $i$ 天结束时持有的股票数量是 0**，$T[i - 1][k][0]$**是休息操作可以得到的最大收益**，$T[i - 1][k][1] + prices[i]$**是卖出操作可以得到的最大收益**，**注意到允许的最大交易次数是不变的**，因为**每次交易包含两次成对的操作**，分别为**买入**和**卖出**，**只有买入操作会改变允许的最大交易次数**。
         2. **对于状态转移方程中的 $T[i][k][1]$**，**第 $i$ 天进行的操作只能是休息或卖出**，因为**在第 $i$ 天结束时持有的股票数量是 0**，$T[i - 1][k][1] + prices[i]$**是卖出操作可以得到的最大收益**，$T[i - 1][k - 1][0] - prices[i]$**是买入操作可以得到的最大收益**，**注意到允许的最大交易次数减少了一次**，因为**每次买入操作会使用一次交易**。
   5. **为了得到最后一天结束时的最大收益**，**可以遍历股票价格数组**，**根据状态转移方程计算 $T[i][k][0]$ 和 $T[i][k][1]$ 的值**，**最终答案是 $T[n - 1][k][0]$**，因为**结束时持有 0 份股票的收益一定大于持有 1 份股票的收益**。

## 3 应用于特殊情况

上述六个股票问题是**根据 $k$ 的值进行分类**的，其中 $k$**是允许的最大交易次数**，**最后两个问题有附加限制**，**包括【冷冻期】和【手续费】**，**通解可以应用于每个股票问题**。

### 3.1 情况一：$k = 1$

1. 情况一对应的题目是[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)。
2. 对于情况一，**每天有两个未知变量**，分别为 $T[i][1][0]$ 和 $T[i][1][1]$，状态转移方程如下：

   $$
   T[i][1][0] = max(T[i - 1][1][0], T[i - 1][1][1] + prices[i])
   $$

   $$
   T[i][1][1] = max(T[i - 1][1][1], T[i - 1][0][0] - prices[i]) = max(T[i - 1][1][1], -prices[i])
   $$

   第二个状态转移方程利用了 $T[i - 1][0][0] = 0$
3. 根据上述状态转移方程，可以写出时间复杂度为 $O(n)$ 和空间复杂度为 $O(n)$ 的解法。

   ```java
   /**
    * 121. 买卖股票的最佳时机（版本 3：动态规划）
    * @param prices    股票价格
    * @return  最大利润
    */
   public int maxProfit(int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][] dp = new int[m + 1][2];

       dp[0][0] = 0;
       dp[0][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
           dp[i][1] = Math.max(-prices[i], dp[i - 1][1]);
       }

       return dp[m - 1][0];
   }
   ```

### 3.2 情况二：$k$ 为正无穷

1. 情况二对应的题目是[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)。
2. **如果 $k$ 为正无穷**，**则 $k$ 和 $k - 1$ 可以看成是相同的**，因此**有**$T[i - 1][k - 1][0] = T[i - 1][k][0]$**和 $T[i - 1][k - 1][1] = T[i - 1][k][1]$**，**每天仍然有两个未知变量**，**分比为 $T[i][k][0]$ 和 $T[i][k][1]$**，其中 $k$**为正无穷**，状态转移方程如下：

   $$
   T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
   $$

   $$
   T[i][k][1] = max(T[i - 1][k - 1][0] - prices[i], T[i - 1][k][1]) = max(T[i - 1][k][0] - prices[i], T[i - 1][k][1])
   $$

   第二个状态转移方程利用了 $T[i - 1][k - 1][0] = T[i - 1][k][0]$
3. 根据上述状态转移方程，可以写出时间复杂度为 $O(n)$ 和空间复杂度为 $O(n)$ 的解法：

   ```java
   /**
    * 122. 买卖股票的最佳时机 II
    * @param prices    股票价格
    * @return  最大利润
    */
   public int maxProfit(int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][] dp = new int[m + 1][2];

       dp[0][0] = 0;
       dp[0][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
           dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
       }

       return dp[m - 1][0];
   }
   ```

### 3.3 情况三：$k = 2$

1. 情况三对应的题目是[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)。
2. 情况三和情况一相似，区别之处是，对于情况三，**每天有四个未知变量**，分别为 $T[i][1][0]$、$T[i][1][1]$、$T[i][2][0]$、$T[i][2][1]$，状态转移方程如下：

   $$
   T[i][1][0] = max(T[i - 1][1][0], T[i - 1][1][1] + prices[i])
   $$

   $$
   T[i][1][1] = max(T[i - 1][0][0] - prices[i], T[i - 1][1][1]) = max(-prices[i], T[i - 1][1][1])
   $$

   $$
   T[i][2][0] = max(T[i - 1][2][0], T[i - 1][2][1] + prices[i])
   $$

   $$
   T[i][2][1] = max(T[i - 1][1][0] - prices[i], T[i - 1][2][1])
   $$

   第二个状态转移方程利用了 $T[i][0][0] = 0$。
3. 根据上述状态转移方程，可以写出时间复杂度为 $O(n)$ 和空间复杂度为 $O(n)$ 的解法：

   ```java
   /**
    * 123. 买卖股票的最佳时机 III
    * @param prices    股票价格
    * @return  最大利润
    */
   public int maxProfit(int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][][] dp = new int[m + 1][3][2];

       dp[0][1][0] = 0;
       dp[0][1][1] = -prices[0];
       dp[0][2][0] = 0;
       dp[0][2][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);
           dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i]);
           dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]);
           dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);
       }

       return dp[m - 1][2][0];
   }
   ```

### 3.4 情况四：$k$ 为任意值

1. 情况四对应的题目是[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)。
2. 情况四是**最通用的情况**，**对于每一天需要使用不同的 $k$ 值更新所有的最大收益**，**对应持有 0 份股票或 1 份股票**，**如果 $k$ 超过一个临界值**，**最大收益就不在取决于允许的最大交易次数**，**而是取决于股票价格数组的长度**，因此**可以进行优化**。
3. **一个由有收益的交易至少需要两天**（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格），**如果股票价格数组的长度为 $n$**，则**有收益的交易的数量最多为 $n / 2$**（整数除法），因此 $k$**的临界值是 $n / 2$**，**如果给定的 $k$ 不小于临界值**，即 $k >= n / 2$，则**可以将 $k$ 扩展为正无穷**，**此时问题等价于[情况二](#3-2-情况二--为正无穷)。**
4. 根据状态转移方程，可以写出时间复杂度为 $O(nk)$ 和空间复杂度为 $O(nk)$ 的解法：

   ```java
   /**
    * 188. 买卖股票的最佳时机 IV
    * @param prices    股票价格
    * @param k 交易最大笔数
    * @return  最大利润
    */
   public int maxProfit(int k, int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}
       if (k >= prices.length / 2) {return maxProfit(prices);}

       int m = prices.length;
       int[][][] dp = new int[m + 1][k + 1][2];

       for (int i = 0; i <= k; i++) {
           dp[0][i][0] = 0;
           dp[0][i][1] = -prices[0];
       }
       for (int i = 1; i < m; i++) {
           for (int j = k; j > 0; j--) {
               dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
               dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
           }
       }

       return dp[m - 1][k][0];
   }

   /**
    * 当 k 趋近于无穷大时买卖股票的最佳时机
    * @param prices    股票价格
    * @return  最大利润
    */
   public int maxProfit(int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][] dp = new int[m + 1][2];

       dp[0][0] = 0;
       dp[0][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
           dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
       }

       return dp[m - 1][0];
   }
   ```

### 3.5 情况五：$k$ 为正无穷但有冷却时间

1. 情况五对应的题目是[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)。
2. 由于具有相同的 $k$ 值，因此**情况五和情况二非常类似**，**不同之处在于情况五有「冷却时间」的限制**，因此**需要对状态转移方程进行一些修改**。
3. 情况二的状态转移方程如下：

   $$
   T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
   $$

   $$
   T[i][k][1] = max(T[i - 1][k][0] - prices[i], T[i - 1][k][1])
   $$
4. 但是**在有「冷却时间」的情况下**，**如果在第 $i - 1$ 天卖出了股票**，**就不能在第 $i$ 天买入股票**，因此，**如果要在第 $i$ 天买入股票**，**第二个状态转移方程就不能使用 $T[i - 1][k][0]$**，而**应该使用 $T[i - 2][k][0]$**，**状态转移方程中的别的项保持不变**，**新的状态转移方程如下**：

   $$
   T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
   $$

   $$
   T[i][k][1] = max(T[i - 2][k][0] - prices[i], T[i - 1][k][1])
   $$
5. 根据上述状态转移方程，可以写出时间复杂度为 $O(n)$ 和空间复杂度为 $O(n)$ 的解法：

   ```java
   /**
    * 309. 最佳买卖股票时机含冷冻期
    * @param prices    股票价格
    * @param k 交易最大笔数
    * @return  最大利润
    */
   public int maxProfit(int k, int[] prices) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][] dp = new int[m + 1][2];

       dp[0][0] = 0;
       dp[0][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
           dp[i][1] = Math.max((i >= 2 ? dp[i - 2][0] : 0) - prices[i], dp[i - 1][1]);
       }

       return dp[m - 1][0];
   }
   ```

### 3.6 情况六：$k$ 为正无穷但有手续费

1. 情况六对应的题目是[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)。
2. 由于具有相同的 $k$ 值，因此**情况六和情况二非常相似**，**不同之处在于情况六有「手续费」**，因此需要对状态转移方程进行一些修改。
3. 情况二的状态转移方程如下：

   $$
   T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
   $$

   $$
   T[i][k][1] = max(T[i - 1][k][0] - prices[i], T[i - 1][k][1])
   $$
4. 由于**需要对每次交易付手续费**，因此**在每次买入或卖出股票之后的收益需要扣除手续费**，**新的状态转移方程有两种表示方法**：

   1. **第一种表示方法**，**在每次买入股票时扣除手续费**：

      $$
      T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
      $$

      $$
      T[i][k][1] = max(T[i - 1][k][0] - prices[i] - fee, T[i - 1][k][1])
      $$
   2. **第二种表示方法**，**在每次卖出股票时扣除手续费**：

      $$
      T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i] - fee)
      $$

      $$
      T[i][k][1] = max(T[i - 1][k][0] - prices[i], T[i - 1][k][1])
      $$
5. 根据上述状态转移方程，可以写出时间复杂度为 $O(n)$ 和空间复杂度为 $O(n)$ 的解法：

   ```java
   /**
    * 714. 买卖股票的最佳时机含手续费
    * @param prices    股票价格
    * @param fee   手续费
    * @return  最大利润
    */
   public int maxProfit(int[] prices, int fee) {
       if (prices == null || prices.length == 0) {return 0;}

       int m = prices.length;
       int[][] dp = new int[m + 1][2];

       dp[0][0] = 0;
       dp[0][1] = -prices[0];
       for (int i = 1; i < m; i++) {
           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
           dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
       }

       return dp[m - 1][0];
   }
   ```

## 参考文献

1. [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)。
2. [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)。
3. [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)。
4. [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)。
5. [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)。
6. [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)。
7. [ 股票问题系列通解（转载翻译）](https://leetcode-cn.com/circle/article/qiAgHn)。



<h1 style='page-break-before: always;'>1.0.7 最长有效括号</h1>

## 1 题目

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```txt
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```txt
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```txt
输入：s = ""
输出：0
```

**提示：**

* 0 <= s.length <= 3 * 104
* s[i] 为 '(' 或 ')'

## 2 解题思路

### 2.1 动态规划

#### 2.1.1 问题解析

1. 对于这种**最值型**题目一般采用**动态规划**的方法来求解。
2. 动态规划题目的分析分为以下 4 个步骤：
   1. **确定状态**：
      1. **研究最优策略的最后一步**。
      2. **化为子问题**。
   2. **转移方程**：
      1. **根据子问题定义得到**。
   3. **初始条件和边界情况**。
   4. **计算顺序**。
3. 首先，我们定义一个 $dp$ 数组，其中 $dp[i]$**表示以下标为 $i$ 的字符结尾的最长有效子字符串的长度**。
4. 然后进行动态规划的求解：
   1. **确定状态**：
      1. 对于最优的策略，一定有最后一个元素 $s[i]$，所以，我们先看第 $i$ 个位置，这个位置的元素 $s[i]$ 有两种情况：
         1. $s[i] = '('$：这时 $s[i]$**无法和其之前的元素组成有效的括号对**，所以 $dp[i] = 0$。
         2. $s[i] = ')'$：这时，**需要看其前面一个元素来判断是否为有效括号对**：
            1. $s[i - 1] = '('$：即 $s[i]$**和 $s[i - 1]$ 组成一对有效括号**，**有效括号长度新增 2**，此时以 $i$**位置的字符结尾的最长有效括号长度为以 $(i - 2)$ 位置的字符结尾的最长有效括号长度加 2**，我们**无需知道 $(i - 2)$ 位置的字符是否可以组成有序括号对**，此时有：

               $$
               dp[i] = dp[i - 2] + 2
               $$

               ![截屏 2020-04-17 下午 4.30.46.png](/media/202107/2021-07-20_2159340.25846779094837236.png)
            2. $s[i - 1] = ')'$：这种情况下，如果**前面有和 $s[i]$ 组成有效括号对的字符**，即形如 $((...)) $，这样的话，就**要求 $s[i - 1]$ 位置必然是有效的括号对**，否则 $s[i]$**无法和前面对字符组成有效括号对**，这时，我们只需**找到和 $s[i]$ 配对的字符的位置**（$i - dp[i - 1] - 1$），并**判断其是否可以和 $s[i]$ 配对**即可：

               1. 如果 $s[i - dp[i - 1] - 1] = '('$，即 $s[i - dp[i -1] - 1]$**可以和 $s[i]$ 配对**，则**以 $s[i]$ 结尾的最长有序括号长度为以 $s[i - 1]$ 为结尾的最长有序括号长度加 2**，此时有：

                  $$
                  dp[i] = dp[i - 1] + 2
                  $$

                  需要注意的是，$s[i - dp[i - 1] - 1]$ 和 $s[i]$ 组成了有序括号对，这将是**一段独立的有序括号对**，如果**之前的子序列是形如 $(...)$ 这种序列**，那么**当前位置的最长有序括号对的长度还需加上这一段**，即：

                  $$
                  dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
                  $$

                  ![截屏 2020-04-17 下午 4.26.34.png](/media/202107/2021-07-20_2215560.0730175812392132.png)
   2. **子问题**：
      1. 根据上面的分析，我们得到了如下**两个计算公式**：

         $$
         dp[i] = dp[i - 1] + 2
         $$

         $$
         dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 1] + 2
         $$
      2. 那么，求 $dp[i]$ 就变成了**求 $dp[i - 1]$**、**$dp[i - 2]$**、**$dp[i - dp[i - 1] - 1]$ 的子问题**。
      3. 这样状态也明确了：**设 $dp$ 数组**，**其中第 $i$ 个元素表示以下标为 $i$ 的字符结尾的最长有效字符串的长度**。
   3. **转移方程**：
      1. **子问题明确后**，**转移方程直接由子问题得到**：

         ```java
         if (s.charAt(i) == '(') {
             dp[i] = 0
         }
         if (s.charAt(i) == ')') {
             if (s.charAt(i - 1) == '(') {
                 dp[i] = dp[i - 2] + 2 // 要保证 i - 2 >= 0
               }
             if (s.charAt(i - 1) == ')' && s[i - dp[i - 1] - 1] == '(') {
                 dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 // 要保证 i - dp[i - 1] - 2 >= 0
               }
         }
         ```
   4. **初始条件和边界情况**：
      1. **初始条件**：$dp[i] = 0$。
      2. **边界情况**：**需要保证计算过程中 $i - 2 >= 0$ 和 $i - dp[i - 1] - 2 >= 0$**。
   5. **计算顺序**：
      1. **无论第一个字符是什么**，**都有**$dp[0] = 0$。
      2. **然后依次计算**$dp[1]、dp[2],...,dp[n - 1]$。
      3. **最后结果是 $max(dp[i])$**。

#### 2.1.2 参考代码

```java
/**
 * 32. 最长有效括号（版本 1：动态规划）
 *
 * @param s 字符串
 * @return 字符串中最长有效括号子串的长度
 */
public int longestValidParenthesesV1(String s) {
    int m = s.length();
    //  dp 数组，其中 dp[i] 表示以 s.charAt(i) 结尾的最长有效括号子串的长度
    int[] dp = new int[m + 1];
    int res = 0;

    for (int i = 1; i < m; i++) {
        if (s.charAt(i - 1) == '(' && s.charAt(i) == ')') {
            //  第 i - 1 个元素为 (，第 i 个元素为 )，即第 i - 1 个元素和第 i 个元素可以组成一个有序括号，则 dp[i] = dp[i - 2] + 2
            dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
        } else if (s.charAt(i - 1) == ')' && s.charAt(i) == ')') {
            //  第 i - 1 个元素为 )，第 i 个元素为 )
            if (i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                //  如果 s.charAt(i - dp[i - 1] - 1) 为 (，即该元素和 s.charAt(i) 配对，则 dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2，其中 s.charAt(i - dp[i - 1] - 2) 为与 s.charAt(i) 配对的前一个元素
                dp[i] = dp[i - 1] + 2;
                if (i - dp[i - 1] - 2 >= 0) {
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                }
            }
        }
        res = Math.max(res, dp[i]);
    }

    //  返回最终结果
    return res;
}
```

### 2.2 栈

#### 2.2.1 问题分析

1. 对于这种**符号匹配**的题目，我们一般可以采用**栈**的方法来求解。
2. 具体做法是**我们始终保持栈底元素为当前已遍历过的元素中最后一个没有被匹配的右括号的下标**，这样的做法**主要是考虑了边界条件的处理**，**栈里其他元素维护左括号的下标**：
   1. **对于遇到的每个 `(`**，我们**将他的下标放入栈中**。
   2. **对于遇到的每个 `)`**，我们**先弹出栈顶元素表示匹配了当前右括号**：
      1. 如果**栈为空**，说明**当前的右括号为没有被匹配的右括号**，我们**将其下标放入栈中来更新我们之前提到的最后一个没有被匹配的右括号的下标**。
      2. 如果**栈不为空**，**当前右括号的下标减去栈顶元素即为以该括号为结尾的最长有效括号的长度**。
3. 然后我们**从前往后遍历字符串并更新答案即可**。
4. 需要注意的是，**如果一开始栈为空**，**第一个字符为左括号的时候**，**我们会将其放入栈中**，这样就**不满足提及的最后一个没有被匹配的右括号的下标**，**为了保持统一**，我们**在一开始的时候往栈中放入一个值为-1 的元素**。
5. 具体演示动画可参考[ 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution)。

#### 2.2.2 参考代码

```java
/**
 * 32. 最长有效括号（版本 2：栈）
 *
 * @param s 字符串
 * @return 字符串中最长有效括号子串的长度
 */
public int longestValidParenthesesV2(String s) {
    int m = s.length();
    //  栈底元素始终为当前已经遍历过的元素中 最后一个没有被匹配的右括号的下标
    Stack<Integer> stack = new Stack<>();
    int maxLength = 0;

    //  如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样栈就不满足栈底元素始终为当前已遍历过的元素中 最后一个没有被匹配的右括号的下标，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素
    stack.push(-1);
    for (int i = 0; i < m; i++) {
        char item = s.charAt(i);

        if (item == '(') {
            //  如果当前遍历的元素为 (，则把当前元素的下标放入栈中
            stack.push(i);
        } else if (item == ')') {
            //  当前遍历的元素为 )
            if (!stack.empty()) {
                //  如果栈不为空，则将栈顶元素弹出
                stack.pop();
            }

            if (stack.size() == 0) {
                //  如果栈为空，则把当前元素的下标放入栈中
                stack.push(i);
            } else {
                //  如果栈不为空，则 当前遍历元素的下标 减去 栈顶元素 即为以该右括号为结尾的最长有效括号的长度
                maxLength = Math.max(maxLength, i - stack.peek());
            }
        }
    }

    //  返回结果
    return maxLength;
}
```

## 3 参考文献

1. [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses)。
2. [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution)。
3. [动态规划思路详解（c++）——32.最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042)。



<h1 style='page-break-before: always;'>1.0.8 剪绳子</h1>

## 1 题目

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n>1 并且 m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。

**示例 1：**

```txt
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```txt
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

**提示：**

* 2 <= n <= 58

> 相似题目：
>
> 1. [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof)。

## 2 问题分析

1. 首先**定义函数 $f(n)$ 为把长度为 $n$ 的绳子剪成若干段后各段长度乘积的最大值**。
2. **在剪第一刀的时候**，**我们有 $n - 1$ 种可能的选择**，**也就是剪出来的第一段绳子的可能长度分别为 $ 1, 2, ..., n - 1$**，因此 $f(n) = max(f(i) \times f(n - i))$，其中 $ 0 < i < n$。
3. **这是一个从上至下的递归公式**，**由于递归会有很多重复的子问题**，**从而有大量不必要的重复计算**，**一个更好的方法是按照从下而上的顺序计算**，**也就是说我们先得到 $f(2)$**、**$f(3)$**，**再得到 $f(4)$**、**$f(5)$**，**直到得到 $f(n)$**。
4. **当绳子长度为 2 时**，**只可能剪成长度都为 1 的两段**，**因此 $f(2)$ 等于 1**，**当绳子的长度为 3 时**，**可能把绳子剪成长度分别为 1 和 2 的两段或者长度都为 1 的三段**，**由于 $ 1 \times 2 > 1 \times 1 \times 1$**，**因此 $f(3) = 2$**。

## 3 参考代码

```java
/**
 * 剑指 Offer 14- I. 剪绳子
 * @param n 绳子长度
 * @return  剪成 m 段后所有段长的最大乘积
 */
public int cuttingRope(int n) {
    //  dp 数组，其中 dp[i] 表示长度为 i 的绳子剪成 m 段后所有段长的最大乘积
    int[] dp = new int[n + 1];

    if (n == 2) {return 1;}
    if (n == 3) {return 2;}

    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    for (int i = 4; i <= n; i++) {
        for (int j = 1; j <= i / 2; j++) {
            //  转移方程
            dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);
        }
    }

    //  返回最后结果
    return dp[n];
}
```

## 参考文献

1. [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof)。
2. [无需复杂数学！二元基本不等式分析动态规划、贪心算法](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offermian-shi-ti-14suan-fa-zhon-6bxx)。
3. [剑指 Offer-14：剪绳子](https://blog.csdn.net/Koala_Tree/article/details/78932316)。
4. [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof)。



<h1 style='page-break-before: always;'>1.0.9 正则表达式匹配</h1>

## 1 题目

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

**示例 1：**

```txt
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```txt
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3：**

```txt
输入：s = "ab", p = "."
输出：true
解释："." 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

**提示：**

* 1 <= s.length <= 20
* 1 <= p.length <= 30
* s 只包含从 a-z 的小写字母。
* p 只包含从 a-z 的小写字母，以及字符 . 和 *。
* 保证每次出现字符 * 时，前面都匹配到有效的字符

## 2 问题分析

1. 本题中**点号通配符其实很好实现**，$s$**中的任何字符**，**只要遇到 $.$ 通配符**，**无脑匹配就完事了**，**主要是这个 $*$ 通配符不好实现**，**一旦遇到 $*$ 通配符**，**前面的那个字符可以选择重复一次**，**可以重复多次**，**也可以一次都不出现**，**针对这个问题**，**我们可以对所有可能出现的情况**，**全部都穷举一遍**，**只要有一种情况可以完成匹配**，**就认为 $p$ 可以匹配 $s$**，**那么一旦涉及两个字符串的穷举**，**我们就应该条件反射地想到动态规划的技巧了**。
2. 我们先脑补一下，**$s$ 和 $p$ 相互匹配的大致过程是两个指针 $i,  j$ 分别在 $s$ 和 $p$ 上移动**，**如果最后两个指针都能移动到字符串的末尾**，**那么就匹配成功**，**反之则匹配失败**。
3. **正则表达算法问题只需要把握住一个基本点**，**看两个字符是否匹配**，**一切逻辑围绕匹配/不匹配两种情况展开即可**：
   1. **如果不考虑 $*$ 通配符**，**面对两个待匹配字符串 $s[i]$ 和 $p[j]$**，**我们唯一能做的就是看他俩是否匹配**：

      ```java
      bool isMatch(string s, string p) {
          int i = 0, j = 0;
          while (i < s.size() && j < p.size()) {
              // 「.」通配符就是万金油
              if (s.charAt(i) == p.charAt(i) || p.charAt(j) == '.') {
                  // 匹配，接着匹配 s[i+1..] 和 p[j+1..]
                  i++; j++;
              } else {
                  // 不匹配
                  return false;
              }
          }
          return i == j;
      }
      ```
   2. 那么，考虑一下，**如果加入$*$通配符**，**局面就会稍微复杂一些**，不过只要分情况来分析，也不难理解：

      1. **当$p[j + 1]$为$*$通配符时**，**我们分情况讨论下**：

         1. **如果匹配**，**即$s.charAt(i) = p.charAt(j)$**，**那么有两种情况**：

            1. $p.charAt(j)$**匹配多个字符**，比如$s = "aaa", p = "a*"$，**那么$p.charAt(0)$会通过$*$匹配3个字符$a$。**
            2. $p.charAt(j)$**匹配0个字符**，比如$s = "aa", p = a*aa$**，***由于后面的字符可以匹配$s$**，**所以$p.charAt(0)$只能匹配0次**。
         2. **如果不匹配**，**即$s.charAt(i) \ne p.charAt(j)$**，**只有一种情况**：

            1. $p.charAt(j)$**只能匹配0次**，**然后看下一个字符是否能和$s.charAt(i)$匹配**，比如说$s = "aa", p = "b*aa"$，**此时$p.charAt(0)$只能匹配0次**。
         3. 综上，我们可以**把之前的代码针对$*$通配符进行一下改造**：

            ```java
            if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
                // 匹配
                if (j < p.size() - 1 && p.charAt(j + 1) == '*') {
                    // 有 * 通配符，可以匹配 0 次或多次
                } else {
                    // 无 * 通配符，老老实实匹配 1 次
                    i++; j++;
                }
            } else {
                // 不匹配
                if (j < p.size() - 1 && p.charAt(j + 1) == '*') {
                    // 有 * 通配符，只能匹配 0 次
                } else {
                    // 无 * 通配符，匹配无法进行下去了
                    return false;
                }
            }
            ```
      2. 整体的思路应该很清晰了，但现在的问题时，**遇到通配符$*$时**，**到底应该是匹配0次还是匹配多次**，**多次是几次**，**这就是一个做【选择】的问题**，**要把所有可能的选择都穷举一遍才能得出结果**，**动态规划的核心就是【状态】和【选择】**，**【状态】无非就是$i$和$j$两个指针的位置**，**【选择】就是$p.charAt(j)$选择匹配几个字符**。
      3. **根据【状态】**，**我们可以定义一个$dp$函数**，**其中$dp(s, i, p, j)$表示$s[i...]$是否可以匹配$p[j...]$**：

         ```java
         public boolean dp(String s, int i, String p, int j)
         ```
      4. **根据这个定义**，**我们想要的答案就是$i = 0, j = 0$时$dp$函数的结果**，**所以可以这样使用这个$dp$函数**：

         ```java
         public boolean isMatch(String s, String p) {
             //  指针 i, j 从索引 0 开始移动
             return dp(s, 0, p, 0);
         }
         ```
      5. **可以根据之前的代码写出$dp$函数的主要逻辑**：

         ```java
         public boolean dp(String s, int i, String p, int j) {
             int m = s.length(), n = p.length();

             if (j == n) {return i == m;}
             if (i == m) {
                 //  如果能匹配空串，一定是字符和 * 成对出现
                 if (((n - j) % 2) == 1) {return false;}
                 //  检查是否为 x*y*z* 这种形式
                 for (; j + 1 < n; j += 2) {
                     if (p.charAt(j + 1) != '*') {return false;}
                 }
                 return true;
             }

             //  如果备忘录中存在，直接从备忘录中取
             String key = String.format("%s_%s", i, j);
             if (memo.containsKey(key)) {return memo.get(key);}

             if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
                 //  匹配
                 if (j < n - 1 && p.charAt(j + 1) == '*') {
                     //  * 匹配 0 次或多次
                     res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j);
                 } else {
                     //  * 常规匹配 1 次
                     res = dp(s, i + 1, p, j + 1);
                 }
             } else {
                 //  不匹配
                 if (j < n - 1 && p.charAt(j + 1) == '*') {
                     //  * 匹配 0 次
                     res = dp(s, i, p, j + 2);
                 } else {
                     //  无法继续匹配
                     res = false;
                 }
             }

             //  将当前结果计入备忘录
             memo.put(key, res);

             return res;
         }
         ```
      6. **根据$dp$函数的定义**，**上面的几种情况都很好解释**：

         1. **当前字符可以匹配**：
            1. **通配符匹配0次或多次**：
               1. **将$j$加2**，$i$**不变**，**含义就是直接跳过$p.charAt(j)$和之后的通配符**，**即通配符匹配0次**。

                  ![图片](/media/202202/2022-02-13_1511410.7641277856847676.png)
               2. **将$i$加1**，$j$**不变**，**含义就是$p.charAt(j)$匹配了$s.charAt(i)$**，**但$p.charAt(j)$还可以继续匹配**，**即通配符匹配多次的情况**。

                  ![图片](/media/202202/2022-02-13_1514110.2020226863039436.png)
               3. **上面两种情况只要有一种可以完成匹配即可**，**所以对上面两种情况求或运算**。
            2. **常规匹配1次**：
               1. **由于这个条件分支是无$*$的常规匹配**，**那么如果$s.charAt(i) == p.charAt(j)$**，**就是$i$和$j$分别加1**。

                  ![图片](/media/202202/2022-02-13_1517130.4059230763448286.png)
         2. **当前字符不可以匹配**：
            1. **通配符匹配0次**：
               1. **类似于上面的当前字符可以匹配时通配符匹配0的情况**，**将$j$加2**，**$i$不变**。

                  ![图片](/media/202202/2022-02-13_1523160.06426259020298242.png)
            2. **没有$*$通配符**：
               1. **如果无法匹配**，**也没有$*$通配符**，**那只能说明匹配失败了**。

                  ![图片](/media/202202/2022-02-13_1525000.6853264208756238.png)
      7. 下面我们**考虑一下$dp$函数的$base \; case$**：

         1. **一个$base \; case$是$j == p.size()$时**，**按照$dp$函数的定义**，**这意味着模式串$p$已经被匹配完了**，**那么应该看看文本串$s$匹配到哪里了**，**如果$s$也恰好被匹配完**，**则说明匹配成功**：

            ```
            if (j == p.size) {return i == s.size();}
            ```
         2. 另一个$base \; case$是$i = s.size()$时，按照$dp$函数的定义，这种情况意味着文本串$s$已经全部被匹配完了，此时并不能根据$j$是否等于$p.size()$来判断是否完成匹配，只要$p[j...]$能够匹配空串，就可以算完成匹配，比如说$s = "a", p = "ab*c*"$，当$i$走到$s$末尾的时候，$j$并没有走到$p$的末尾，但是$p$依然可以匹配$s$，代码中使用了一个哈希表$memo$作为备忘录来减少重复遍历问题：

            ```
            int m = s.length(), n = p.length();

            if (j == n) {return i == m;}
            if (i == m) {
                //  如果能匹配空串，一定是字符和 * 成对出现
                if (((n - j) % 2) == 1) {return false;}
                //  检查是否为 x*y*z* 这种形式
                for (; j + 1 < n; j += 2) {
                    if (p.charAt(j + 1) != '*') {return false;}
                }
                return true;
            }

            //  如果备忘录中存在，直接从备忘录中取
            String key = String.format("%s_%s", i, j);
            if (memo.containsKey(key)) {return memo.get(key);}

            if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
                //  匹配
                if (j < n - 1 && p.charAt(j + 1) == '*') {
                    //  * 匹配 0 次或多次
                    res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j);
                } else {
                    //  * 常规匹配 1 次
                    res = dp(s, i + 1, p, j + 1);
                }
            } else {
                //  不匹配
                if (j < n - 1 && p.charAt(j + 1) == '*') {
                    //  * 匹配 0 次
                    res = dp(s, i, p, j + 2);
                } else {
                    //  无法继续匹配
                    res = false;
                }
            }

            //  将当前结果计入备忘录
            memo.put(key, res);

            return res;
            ```

## 3 参考代码

```java
//  最终结果
boolean res;
//  备忘录
HashMap<String, Boolean> memo = new HashMap<>();

/**
 * 10. 正则表达式匹配
 * @param s 字符串
 * @param p 正则表达式
 * @return  p 是否可以匹配 s
 */
public boolean isMatch(String s, String p) {
    //  指针 i, j 从索引 0 开始移动
    return dp(s, 0, p, 0);
}

/**
 * dp 函数
 * @param s 文本串
 * @param i 文本串索引
 * @param p 模式串
 * @param j 模式串索引
 * @return  p[j:] 是否可以匹配 s[i:]
 */
public boolean dp(String s, int i, String p, int j) {
    int m = s.length(), n = p.length();

    if (j == n) {return i == m;}
    if (i == m) {
        //  如果能匹配空串，一定是字符和 * 成对出现
        if (((n - j) % 2) == 1) {return false;}
        //  检查是否为 x*y*z* 这种形式
        for (; j + 1 < n; j += 2) {
            if (p.charAt(j + 1) != '*') {return false;}
        }
        return true;
    }

    //  如果备忘录中存在，直接从备忘录中取
    String key = String.format("%s_%s", i, j);
    if (memo.containsKey(key)) {return memo.get(key);}

    if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
        //  匹配
        if (j < n - 1 && p.charAt(j + 1) == '*') {
            //  * 匹配 0 次或多次
            res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j);
        } else {
            //  * 常规匹配 1 次
            res = dp(s, i + 1, p, j + 1);
        }
    } else {
        //  不匹配
        if (j < n - 1 && p.charAt(j + 1) == '*') {
            //  * 匹配 0 次
            res = dp(s, i, p, j + 2);
        } else {
            //  无法继续匹配
            res = false;
        }
    }

    //  将当前结果计入备忘录
    memo.put(key, res);

    return res;
}
```

## 参考文献

1. [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching)。
2. [东哥手写正则通配符算法，结构清晰，包教包会！](https://mp.weixin.qq.com/s/rnaFK05IcFWvNN1ppNf2ug)



<h1 style='page-break-before: always;'>1.1 二分查找</h1>

1.2 二分查找




<h1 style='page-break-before: always;'>1.1.0 二分查找框架</h1>

```java
package com.grayson.top;

import java.util.List;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/3/21 14:25
 * @Description 二分查找算法框架
 */
public class BinarySearch {

    /**
     * 二分查找算法
     * @param nums  原始数组
     * @param target    目标值
     * @return  目标值在原始数组中的位置
     */
    public static int binarySearch(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            //  为了防止 (left + right) 太大导致溢出
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {left = mid + 1;}
            else if (nums[mid] > target) {right = mid - 1;}
            //  直接返回
            else if (nums[mid] == target) {return mid;}
        }
        //  直接返回
        return -1;
    }

    /**
     * 寻找左侧边界的二分查找算法
     * @param nums  原始数组
     * @param target    目标值
     * @return  目标值在原始数组中的位置
     */
    public static Integer leftBond(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {left = mid + 1;}
            else if (nums[mid] > target) {right = mid - 1;}
            //  1.别返回，锁定左边界
            else if (nums[mid] == target) {right = mid - 1;}
        }
        //  2.最后要检查 left 越界的情况
        if (left >= nums.length || nums[left] != target) {return -1;}
        return left;
    }

    /**
     * 寻找右侧边界的二分查找算法
     * @param nums  原始数组
     * @param target    目标值
     * @return  目标值在原始数组中的位置
     */
    public static Integer rightBond(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {left = mid + 1;}
            else if (nums[mid] > target) {right = mid - 1;}
            //  1.别返回，锁定右边界
            else if (nums[mid] == target) {left = mid + 1;}
        }
        //  2.最后要检查 right 越界的情况
        if (right < 0 || nums[right] != target) {return -1;}
        return right;
    }

}
```




<h1 style='page-break-before: always;'>1.1.1 搜索旋转排序数组</h1>

## 1 题目

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

**示例 1：**

```txt
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```txt
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```txt
输入：nums = [1], target = 0
输出：-1
```

**提示：**

* 1 <= nums.length <= 5000
* -10^4 <= nums[i] <= 10^4
* nums 中的每个值都 独一无二
* 题目数据保证 nums 在预先未知的某个下标上进行了旋转
* -10^4 <= target <= 10^4

**进阶：** 你可以设计一个时间复杂度为 O(log n) 的解决方案吗？

## 2 解题思路

### 2.1 两段寻找

#### 2.1.1 问题分析

1. 这种方法的基本思想是**将数组分成两部分**，分别是**前面一部分的升序数组**和**后面一部分的升序数组**。
2. 首先**对前面一部分的升序数组进行遍历**，**找到两部分数组的边界**，在遍历的过程中，如果**找到了目标元素**，那么**直接返回对应的下标**即可。
3. 如果**前一部分没有找到目标元素**，并且**已经找到了两部分数组的边界**，此时直接**对后面一部分的数组进行二分查找**即可。

#### 2.1.2 参考代码

```java
/**
 * 对一个数组指定范围内的数据二分查找目标数据
 *
 * @param nums   数组
 * @param target 目标元素
 * @return 目标元素在数组中的位置
 */
public int binarySearch(int[] nums, int start, int end, int target) {
    int left = start, right = end;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            return mid;
        }
    }
    return -1;
}

/**
 * 33. 搜索旋转排序数组（版本 1：两段寻找）
 *
 * @param nums   数组
 * @param target 目标元素
 * @return 目标元素在数组中的位置
 */
public int searchV1(int[] nums, int target) {
    int len = nums.length;
    //  用于后面判断数组第一阶段升序范围
    int start = nums[0];
    int end = -1;
    if (start == target) {return 0;}
    //  首先判断数组的第一阶段升序范围，如果在这一范围内找到目标元素，则直接返回相应的下标
    for (int i = 1; i < len; i++) {
        if (nums[i] == target) {return i;}
        if (nums[i] < start) {
            end = i;
            break;
        }
        start = nums[i];
    }
    //  如果在数组第一阶段升序范围没有找到目标元素，则在后面一阶段升序范围采用二分查找法查找目标元素
    return end == -1 ? -1 : binarySearch(nums, end, len - 1, target);
}
```

### 2.2 二分查找

#### 2.2.1 问题分析

1. 这种方法的基本思想是**直接在原来的数组上进行二分查找**，但是由于**基本的二分查找算法只能用于升序数组上**，因此**需要对基本的二分查找算法进行改进**。
2. 主要改进的地方在于在遍历的过程中**先判断 $nums[mid]$ 位于左段还是右段**：
   1. 如果 $nums[mid] \ge nums[left]$，说明 $nums[mid]$ 位于**左段**，然后再**判断 $target$ 的位置**：
      1. 如果 $target \ge nums[left]$ 并且 $target \lt nums[mid]$，说明 $target$ 位于 $nums[mid]$**左边**，则 $right = mid - 1$。
         ![](../../media/202107/2021-07-05_221400.png)
      2. 否则，说明 $target$ 位于 $mid$**右边**，则 $left = mid + 1$。
         ![](../../media/202107/2021-07-05_221411.png)
   2. 如果 $nums[mid] \le nums[right]$，说明 $nums[mid]$ 位于**右段**，然后再**判断 $target$ 的位置**：
      1. 如果 $target \gt nums[mid]$ 并且 $target \le nums[right]$，说明 $target$ 位于 $nums[mid]$**右边**，则 $left = mid + 1$。
         ![](../../media/202107/2021-07-05_221452.png)
      2. 否则，说明 $target$ 位于 $mid$**左边**，则 $right = mid - 1$。
         ![](../../media/202107/2021-07-05_221420.png)

#### 2.2.2 参考代码

```java
/**
 * 33. 搜索旋转排序数组（版本 2：二分查找）
 *
 * @param nums   数组
 * @param target 目标元素
 * @return 目标元素在数组中的位置
 */
public int searchV2(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        //  判断 nums[mid] 位于左段还是右段
        if (nums[mid] >= nums[left]) {
            //  nums[mid] 位于左段
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else if (nums[mid] <= nums[right]) {
            //  nums[mid] 位于右段
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

## 3 参考文献

1. [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)。
2. [多思路完全攻略，🤷‍♀️ 必须秒懂！](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/duo-si-lu-wan-quan-gong-lue-bi-xu-miao-dong-by-swe)



<h1 style='page-break-before: always;'>1.2 链表</h1>

1.3 链表




<h1 style='page-break-before: always;'>1.2.0 反转链表</h1>

## 1 反转整个链表

> 题目来源：[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list)

### 1.1 题目

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://notebook.ricear.com/media/202206/2022-06-25_1107090.8604224978183835.png)

```txt
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![](https://notebook.ricear.com/media/202206/2022-06-25_1107180.5052359862891712.png)

```txt
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```txt
输入：head = []
输出：[]
```

**提示：**

* 链表中节点的数目范围是 [0, 5000]
* -5000 <= Node.val <= 5000

**进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 1.2 问题解析

1. 对于这种包含子问题的题目，我们可以采用**递归**的方法来解决：

   1. 首先定义一个递归函数 `reverse(ListNode head)`，用于**将链表反转并返回反转后链表的头部**。
   2. 对于 `reverse()` 函数的返回结果，我们用 `last` 来进行接收，即 `last = reverse(head.next);`。
   3. 接着**将反转后的节点与前面的节点进行连接**，即 `head.next.next = last; head.next = null;`。
   4. 通过以上操作，我们便可以将一个链表进行反转，同时需要注意一下边界条件，因为方法中涉及到 `head.next` 和 `head.next.next` 操作，所以我们需要**对 `head` 和 `head.next` 进行空值判断**：

      1. 当 `head == null` 时，说明头结点为空，其反转后的节点肯定也为空，所以直接返回 `null`。
      2. 当 `head.next == null` 时，说明只有这一个节点，反转后肯定还是这个节点，所以直接返回 `head`。

      > 上面两个判断条件可以合并为 `if (head == null || head.next == null) {return head;}`
      >
   5. 详细的步骤如下图所示。
      ![](https://notebook.ricear.com/media/202206/2022-06-23_162605_029486.gif)

### 1.3 参考代码

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {return head;}
    ListNode last = ReverseList(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```

## 2 反转链表的一部分

> 题目来源：[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii)

### 2.1 题目

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

**示例 1：**

![](https://notebook.ricear.com/media/202206/2022-06-23_193822_198011.png)

```txt
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```txt
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

* 链表中节点数目为 n
* 1 <= n <= 500
* -500 <= Node.val <= 500
* 1 <= left <= right <= n

  进阶： 你可以使用一趟扫描完成反转吗？

### 2.2 问题分析

1. 假设**以 `head` 为基点**，反转链表的一部分对应的函数为 `reverseBetween(head, m, n)`，则如果**以 `head.next` 为基点的话**，反转链表的一部分对应的函数为 `reverseBetween(head.next, m - 1, n - 1)`，因此当**m 减小到 1**时，可以转化为**反转链表的前 $N$ 个节点**，假设其对应的函数为 `reverseN(head, n)`，因此当我们**求出反转链表的前 $N$ 个节点后的链表**，然后**与开始反转的节点之前的一部分链表进行拼接便可得到最后的结果**，因此我们现在的重点就是求**反转链表的前 $N$ 个节点**：

   1. 反转前 $N$ 个节点与反转整个链表类似，不同的是**反转整个链表中最后作为尾节点的 $head$ 节点指向空节点**，而**反转链表前 $N$ 个节点最后作为局部尾节点的 $head$ 节点需要指向 $N + 1$ 个节点**。
      ![](https://notebook.ricear.com/media/202206/2022-06-23_200107_440593.png)
   2. 当 `reverse(head, n)` 中的 `n = 1` 时，此时 `head` 指向要**反转节点的最后一个节点**（这里指的是 4），因此后继节点 `sucessor` 等于 `head.next`，此时直接返回 `head` 即可。

      > 需要注意的是 `sucessor` 需要定义为**全局变量**，而不能放在 `reverseN()` 方法内部。
      >
   3. 反转链表的前 $N$ 个节点的详细解法如下图所示。
      ![](https://notebook.ricear.com/media/202206/2022-06-24_091709_683306.gif)
2. 反转链表的一部分的详细解法如下图所示。
   ![](https://notebook.ricear.com/media/202206/2022-06-24_092119_624442.gif)

### 2.3 参考代码

```java
public static ListNode sucessor = null;

/**
 * 92.反转链表 II
 *
 * @param head  单链表的头指针
 * @param left  起始位置
 * @param right 结束位置
 * @return 反转后的单链表
 */
public static ListNode reverseBetween(ListNode head, int left, int right) {
    //  如果 left == 1，则情况转变为反转前 N 个节点
    if (left == 1) {return reverseN(head, right);}
    //  前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, left - 1, right - 1);
    return head;
}

/**
 * 反转前 N 个节点
 * @param head  单链表的头指针
 * @return  反转后的单链表
 */
public static ListNode reverseN(ListNode head, int n) {
    //  如果输入的 head 为 null，则返回 null
    if (head == null) {return null;}
    //  记录第 n + 1 个节点
    if (n == 1) {
        sucessor = head.next;
        return head;
    }

    ListNode last = reverseN(head.next, n - 1);
    head.next.next = head;
    head.next = sucessor;
    return last;
}
```

## 3 K 个一组反转链表

> 题目来源：[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

### 3.1 题目

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

```txt
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

```txt
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**提示：**

- 链表中的节点数目为 n
- 1 <= k <= n <= 5000
- 0 <= Node.val <= 1000

**进阶：** 你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？

### 3.2 问题分析

1. 解答此题时我们按照如下思路进行：
   1. 首先**对这一组 $K$ 个链表进行反转**。
   2. 判断一下**这一次反转的链表的长度是否大于**$K$：

      1. 如果**大于**$K$ 的话，说明**后面还有元素**，因此**继续反转下一组**$K$**个链表**，并**将反转后的结果与上一组**$K$**个链表进行拼接**。
      2. 如果**小于**$K$ 的话，说明这一组是**链表最后的元素**，由于这一组链表**已经反转过了**，而题目要求的是如果**链表中剩余元素小于**$K$ 的话，需要**保持原来的顺序**，因此**需要对这一组链表进行再次反转**，这样才能保持原来的顺序，最后同样需要**将反转后的结果与上一组**$K$**个链表进行拼接**。
   3. 反转的关键步骤如下图所示。

      > **每一组反转后的头结点为**$target$，**尾节点为**$head$，**每次反转的时候直接返回当前头结点 $target$ 即可**，**最后返回的第一层 $target$ 即是最终的结果**。
      >

      1. 第一组反转前：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_113834_193774.png)
      2. 第一组反转后：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_113912_678097.png)
      3. 第二组反转前：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_113936_639374.png)
      4. 第二组反转后：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_114004_224175.png)
      5. 第三组反转前：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_114032_804868.png)
      6. 第三组反转后：
         ![](https://notebook.ricear.com/media/202206/2022-06-24_114053_194534.png)
      7. 最终结果：

         > 最终结果返回第一层的 $target$，即 $target_1$。
         >

         ![](https://notebook.ricear.com/media/202206/2022-06-24_114258_385866.png)
   4. 反转的详细步骤如下图所示。
      ![](https://notebook.ricear.com/media/202206/2022-06-24_114835_395136.gif)

### 3.3 参考代码

```java
/**
 * 25. K 个一组翻转链表
 * @param head  头结点
 * @param k 指定节点个数
 * @return  翻转后的链表
 */
public ListNode reverseKGroup(ListNode head, int k) {
    return reverseK(head, k, k+1);
}

/**
 * 翻转链表的前 k 个元素
 * @param head  头结点
 * @param k 指定节点个数
 * @param left  剩余节点个数
 * @return  反转后的链表
 */
public ListNode reverseK(ListNode head, int k, int left) {
    if (head == null || left <= k) {return head;}
    int num = 1;
    ListNode p = head, q = head, target = null;
    while (num <= k && p != null) {
        q = p;
        p = p.next;
        q.next = target;
        target = q;
        num++;
    }
    if (num <= k) {
        return reverse(target);
    } else {
        head.next = reverseK(p, k, num);
    }
    return target;
}
```

## 参考文献

1. [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)。
2. [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii)。
3. [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)。
4. [递归反转链表的一部分](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye/di-gui-fan-zhuan-lian-biao-de-yi-bu-fen)。



<h1 style='page-break-before: always;'>1.2.1 相交链表</h1>

## 1 题目

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

![](../../media/202105/2021-05-24_203625.png)

在节点 c1 开始相交。

**示例 1：**

![](../../media/202105/2021-05-24_203718.png)

```txt
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

![](../../media/202105/2021-05-24_203739.png)

```txt
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

![](../../media/202105/2021-05-24_203755.png)

```txt
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

**注意：**

* 如果两个链表没有交点，返回 null.
* 在返回结果后，两个链表仍须保持原有的结构。
* 可假定整个链表结构中没有循环。
* 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

## 2 解题思路

### 2.1 HashMap

#### 2.1.1 问题解析

1. 将一个链表中的所有节点信息存入到**HashMap**中：
   
   * **key**：当前节点的地址
   * **Value**：当前节点的父节点（头结点的父节点为**null**）
2. 然后依次遍历另一个链表：
   
   1. 如果**HashMap**中包含当前节点的**key**，同时其对应的**value**不等于当前节点的父节点，则当前节点即为两个链表相交的起始节点。
   2. 如果遍历到最后不存在的话，则直接返回**null**。

![](../../media/202105/2021-05-24_211658.png)

#### 2.1.2 参考代码

```java
/**
 * 160. 相交链表（版本 1：HashMap）
 * @param headA 第一个链表的头结点
 * @param headB 第二个链表的头结点
 * @return
 */
public ListNode getIntersectionNodeV1(ListNode headA, ListNode headB) {
    if (headA == headB) {return headA;}
    Map<ListNode, ListNode> map = new HashMap<>();
    ListNode p = headA, prev = null, res = null;
    while (p != null) {
        map.put(p, prev);
        prev = p;
        p = p.next;
    }
    p = headB;
    prev = null;
    while (p != null) {
        if (map.containsKey(p) && map.get(p) != prev) {
            res = p;
            break;
        }
        prev = p;
        p = p.next;
    }
    return res;
}
```

### 2.2 双指针

#### 2.2.1 问题解析

1. 开始时令指针**head1=headA**，**head2=headB**。
2. 然后两个指针分别从两个链表的起点开始遍历：
   1. 当其中一个指针到达链表的尾部时，则令其等于**另一个链表**的**头部**，然后继续开始遍历，例如**head1**遍历到**headA**的尾部时，令**head1=headB**。
3. 在两次遍历的过程中，因为两个指针最终走的路程一样，所以：
   1. 如果两个链表相交时，两个指针一定会在两个链表相交的节点相遇。
   2. 如果两个链表不相交时，最后两个指针一定会在链表的尾部相遇，即两个指针最后的值都为**null**。

![](../../media/202105/2021-05-24_204857.png)

将二者的路径拼接到一起进行展示：

![](../../media/202105/160-相交链表（解法二：双指针）（展示方法二）_1621860793.gif)

#### 2.2.2 参考代码

```java
/**
 * 160. 相交链表（版本 2：双指针）
 * @param headA 第一个链表的头结点
 * @param headB 第二个链表的头结点
 * @return
 */
public ListNode getIntersectionNodeV2(ListNode headA, ListNode headB) {
    //  如果 headA 或 headB 为 null，则两个链表肯定不相交，直接返回 null
    if (headA == null || headB == null) {return null;}
    ListNode head1 = headA, head2 = headB;
    //  两次遍历：
    //      如果两个链表有交点，则最后 head1 一定为二者的交点
    //      如果两个链表没有交点，则一定是在最后到尾节点的时候二者相遇，此时 head1 为 null
    while (head1 != head2) {
        if (head1 == null) {
            //  如果 head1 走到了尾节点，则令其等于 headB 的头结点
            head1 = headB;
        } else {
            //  否则的话，继续遍历即可
            head1 = head1.next;
        }

        if (head2 == null) {
            //  如果 head2 走到了尾节点，则令其等于 headA 的头结点
            head2 = headA;
        } else {
            //  否则的话，继续遍历即可
            head2 = head2.next;
        }
    }
    return head1;
}
```

## 3 参考文献

1. [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)。
2. [图解相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t)。




<h1 style='page-break-before: always;'>1.2.2 合并链表</h1>

> 下面的问题解析中的**为头结点 `head` 赋初始值是针对的牛客网上相应的题目**（[NC33 合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=117&tqId=37735&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D%25E9%2593%25BE%25E8%25A1%25A8%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=undefined&judgeStatus=undefined&tags=&title=%E9%93%BE%E8%A1%A8)），因为牛客网上的题目中 `ListNode`**没有空参构造函数**，所以**其实例中 `val` 不能为空**，而 Leetcode 上对应的题目（[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)）中 `ListNode` 有空参构造函数，所以其实例中 `val` 可以为空。

## 1. 合并两个排序的链表

> 题目来源：[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)

### 1.1 题目

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

![](https://notebook.ricear.com/media/202206/2022-06-25_110320_875719.png)

```txt
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```txt
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```txt
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

- 两个链表的节点数目范围是 [0, 50]
- -100 <= Node.val <= 100
- l1 和 l2 均按 非递减顺序 排列

### 1.2 问题解析

1. 解答此题时可以定义一个**头结点** `head`，头结点对应的 `val`**可以自定义**，因为后面返回最后结果时是从头结点的下一个节点开始，即 `head.next`，因此头结点的值对最终结果没有影响，同时定义一个**临时指针** `p`，用来**连接后面的节点**，其中 `p` 开始的时候**指向** `head`，即 `p = head`。
   ![](https://notebook.ricear.com/media/202206/2022-06-25_114548_778589.png)
2. 然后比较两个链表各自当前节点的值 `list1.val` 和 `list2.val`：
   1. 如果 `list1.val`**小于等于** `list2.val`，则**将 `p` 指向节点的指针指向** `list1`，同时**将 `p` 指向** `list1`，然后**将 `list1` 指向下一个节点**，即 `p.next = list1; p = list1; list1 = list1.next; `
      ![](https://notebook.ricear.com/media/202206/2022-06-25_114807_951268.gif)
   2. 如果 `list1.val`**大于** `list2.val`，则**将 `p` 指向节点的指针指向** `list2`，同时**将 `p` 指向** `list2`，然后**将 `list2` 指向下一个节点**，即 `p.next = list2; p = list2; list2 = list2.next; `
      ![](https://notebook.ricear.com/media/202206/2022-06-25_115009_838082.gif)
3. 最后将 `list1` 和 `list2` 中**不为空的部分链接到前面已经合并后的链表**：
   ![](https://notebook.ricear.com/media/202206/2022-06-25_115347_100070.gif)

### 1.3 参考代码

```java
/**
 * 合并两个有序链表
 * @param node1 第一个链表
 * @param node2 第二个链表
 * @return  合并后的链表
 */
public ListNode merge(ListNode list1,ListNode list2) {
    ListNode head = new ListNode(Integer.MIN_VALUE), p = head;
  
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            p.next = list1;
            p = list1;
            list1 = list1.next;
        } else {
            p.next = list2;
            p = list2;
            list2 = list2.next;
        }
    }
  
    if (list1 != null) {p.next = list1;}
    else if (list2 != null) {p.next = list2;}
  
    return head.next;
}
```

## 2 合并 k 个排序的链表

> 题目来源：[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)

### 2.1 题目

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

示例 1：

```txt
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

示例 2：

```txt
输入：lists = []
输出：[]
```

示例 3：

```txt
输入：lists = [[]]
输出：[]
```

**提示：**

- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] 按 升序 排列
- lists[i].length 的总和不超过 10^4

### 2.2 问题解析

1. 如果是**两个有序链表合并**，我们可能会利用**归并排序合并阶段**的思想：
   1. **准备双指针分别放在两个链表头**，**每次取出较小的一个元素加入新的大链表**，**将其指针后移**，**继续比较**，**这样我们出去的都是最小的元素**，**自然就完成了排序**。
2. 其实这道题我们也可以**两两比较**：
   1. **只要遍历链表数组**，**取出开头的两个链表**，**按照上述思路合并**，**然后新链表再与后一个链表继续合并**，**如此循环**，**直到全部合并完成**。
      但是这样做**太浪费时间**，**效率比较低**。
3. 既然都是归并的思想了，因此我们可以按照直接归并的分治来做，而不是顺序遍历合并链表，对于这 $k$**个链表**，就相当于**合并阶段的**$k$**个子问题**，需要**划分为链表数量更少的子问题**，直到**每一组合并时是两两合并**，这个过程基于**递归**：
   1. **终止条件**：**划分的时候直到左右区间相等**或**左边大于右边**。
   2. **返回值**：**每级返回已经合并好的子问题链表**。
   3. **本级任务**：**对半划分**，**将划分后的子问题合并成新的链表**。
4. 具体做法如下：
   1. 从链表数组的**首**和**尾**开始，每次划分**从中间开始划分**，**划分成两半**，得到**左边**$\frac{n}{2}$**个链表**和**右边**$\frac{n}{2}$**个链表**。
   2. 继续不断**递归划分**，直到**每部分链表数为 1**。
   3. **将划分好的相邻两部分链表**，**按照合并两个有序链表的方式合并**，**合并好的两部分继续往上合并**，**直到最终合并成一个链表**。
      ![](https://notebook.ricear.com/media/202206/2022-06-26_122419_605515.gif)

### 2.3 参考代码

```java
/*
 * 合并 k 个有序链表
 * @param lists 链表数组
 * @return  合并后的链表
 */
public ListNode mergeKLists(ArrayList<ListNode> lists) {
    return mergeK(lists, 0, lists.size() - 1);
}

/*
 * 递归合并 k 个有序链表
 * @param lists 链表数组
 * @left    合并链表的左下标
 * @right   合并链表的右下标
 */
public ListNode mergeK(ArrayList<ListNode> lists, int left, int right) {
    if (left > right) {return null;}
    if (left == right) {return lists.get(left);}    //  中间一个的情况，直接返回这个链表
  
    int mid = (left + right) / 2;
    return merge(mergeK(lists, left, mid), mergeK(lists, mid + 1, right));  //  从中间分成两段，再将合并好的两段合并
}
```

## 参考文献

1. [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)。
2. [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists)。
3. [合并 k 个已排序的链表](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=117&tqId=37747&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D%25E9%2593%25BE%25E8%25A1%25A8%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=undefined&judgeStatus=undefined&tags=&title=%E9%93%BE%E8%A1%A8)。



<h1 style='page-break-before: always;'>1.2.3 链表中倒数第k个节点</h1>

## 1 题目

输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

**示例：**

```txt
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
```

> 和该题目类似的题目还有：
> 
> 1. [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)。

## 2 解题思路

### 2.1 两次遍历

#### 2.1.1 问题分析

1. 先遍历一下链表，统计一下总的节点个数 $total$。
2. 然后再遍历一下链表，将指针 $p$ 向前移动 $total - k$ 步，此时 $p$ 指向的节点即为倒数第 $k$ 个节点。

#### 2.1.2 参考代码

```java
/**
 * 剑指 Offer 22. 链表中倒数第 k 个节点（版本 1：两次遍历）
 * @param head  头结点
 * @param k 倒数节点个数
 * @return  链表中倒数第 k 个节点
 */
public ListNode getKthFromEndV1(ListNode head, int k) {
    ListNode p = head;
    int total = 1, curr = 1;
    //  先遍历一下链表，统计一下链表总的节点个数
    while (p != null) {
        p = p.next;
        total++;
    }

    //  然后再遍历一下链表，将指针向前移动 total - k 步，此时指针指向的节点即为倒数第 k 个节点
    p = head;
    while (curr < total - k) {
        p = p.next;
        curr++;
    }
    return p;
}
```

### 2.2 双指针

#### 2.2.1 问题分析

1. 定义两个指针，分别为慢指针 $slow$ 和快指针 $fast$。
2. 让快指针先走 $k$ 步。
3. 然后快慢指针同时移动，以后快慢指针的距离都为 $k$ 步，直到快指针为空，此时慢指针 $slow$ 即为倒数第 $k$ 个节点。
   
   ![](../../media/202107/2021-07-13_222646.png)

#### 2.2.2 参考代码

```java
/**
 * 剑指 Offer 22. 链表中倒数第 k 个节点（版本 2：双指针）
 * @param head  头结点
 * @param k 倒数节点个数
 * @return  链表中倒数第 k 个节点
 */
public ListNode getKthFromEndV2(ListNode head, int k) {
    //  快慢指针
    ListNode slow = head, fast = head;
    //  让快指针先走 k 步
    while (k > 0) {
        fast = fast.next;
        k--;
    }
    //  然后快慢指针同时移动，以后快慢指针的距离都为 k 步，直到快指针为空，此时慢指针即为倒数第 k 个节点
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```

## 3 参考文献

1. [剑指 Offer 22. 链表中倒数第 k 个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof)。
2. [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)。
3. [面试题 22. 链表中倒数第 k 个节点（双指针，清晰图解）](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11)。




<h1 style='page-break-before: always;'>1.2.4 复制带随机指针的链表</h1>

## 1 题目

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

* val：一个表示 Node.val 的整数。
* random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

**示例 1：**
![](../../media/202201/2022-01-09_2130410.7261368158867781.png)

```txt
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**
![](../../media/202201/2022-01-09_2131130.7809220936814016.png)

```txt
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**
![](../../media/202201/2022-01-09_2131310.08080883298827601.png)

```txt
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```txt
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

**提示：**

* 0 <= n <= 1000
* -10000 <= Node.val <= 10000
* Node.random 为空（null）或指向链表中的节点。

## 2 问题解析

1. 首先，我们可以**忽略 `random` 指针**，然后**对原链表的每个节点进行复制**，**并追加到原节点的后面**，**将原链表和复制链表连在一起**：![](../../media/202201/2022-01-09_2132230.7640217615405901.png)
2. 然后，**从前往后遍历每一个原链表节点**，**对于有 `random` 指针的节点 `p`**，**我们让它 `p.next.random = p.random.next`**，**这样我们就完成了对原链表 `random` 指针的复刻**：![](../../media/202201/2022-01-09_2132350.36969955791205567.png)
3. 最后，**我们把原链表和复制链表拆分出来**，**并将原链表复原**：![](../../media/202201/2022-01-09_2132480.08964373357277822.png)

## 3 参考代码

```java
/**
 * 138. 复制带随机指针的链表
 * @param head  链表头结点
 * @return  原链表的复制链表
 */
public Node copyRandomList(Node head) {
    //  复制每个节点，并将原链表和复制链表连在一起
    for (Node p = head; p != null; p = p.next.next) {
        Node q = new Node(p.val);
        q.next = p.next;
        p.next = q;
    }

    //  复制 random 指针
    for (Node p = head; p != null; p = p.next.next) {
        if (p.random != null) {
            p.next.random = p.random.next;
        }
    }

    //  拆分两个链表，并复原原链表
    Node dummy = new Node(-1), cur = dummy;
    for (Node p = head; p != null; p = p.next) {
        Node q = p.next;
        cur.next = q;
        cur = cur.next;
        p.next = q.next;
    }

    //  返回原链表的复制链表
    return dummy.next;
}
```

## 参考文献

1. [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer)。
2. [复制带随机指针的链表 | 图解迭代和哈希两种做法 【c++/java 版本】](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-c2nvs)。




<h1 style='page-break-before: always;'>1.3 排序算法</h1>

1.4 排序算法




<h1 style='page-break-before: always;'>1.3.0 常见排序算法</h1>

## 1 简单选择排序

### 1.1 算法原理

1. 简单排序算法的基本思想为**每一趟从待排序的数据元素中选择最小（最大）的一个元素作为首元素，直到所有元素排完为止**。

### 1.2 参考代码

1. 在算法实现时，每一趟确定最小元素的时候会通过**不断地比较交换**来使得**首位置为当前最小**。
2. **交换是个比较耗时的操作**，其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。
3. 我们可以通过设置一个变量 `minInd`，每一次比较仅存储较小元素的数组下标，当这一轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/3 20:52
 * @Description 简单选择排序算法
 */
public class SimpleSelectionSort {
    public static void sort(int[] arr) {
        int m = arr.length;
        for (int i = 0; i < m - 1; i++) {
            int minInd = i;
            for (int j = minInd + 1; j < m; j++) {
                //  只记录最小元素的位置，而不是每一次比较都交换，减少交换的次数
                if (arr[minInd] > arr[j]) {minInd = j;}
            }
            if (minInd != i) {
                //  如果当前位置 i 不是这一次的最小元素，再交换元素的位置
                CommonUtils.swap(arr, i, minInd);
            }
        }
    }
}
```

### 1.3 算法分析

1. 简单排序算法无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动，在最差情况下，也就是数组倒序的时候，交换次数为 `n-1` 次，综合下来，时间复杂度为 $O(n^2)$。
2. 简单排序算法是**不稳定**的排序算法。

### 1.4 适用场景

1. 选择排序**实现也比较简单**，并且由于在各种情况下**复杂度波动较小**，因此一般是**优于冒泡排序**的。
2. 在所有的完全交换排序中，选择排序也是比较不错的一种算法，但是由于固有的 $O(n^2)$ 复杂度，选择排序在海量数据面前显得力不从心，因此，它**适用于简单数据排序**。

## 2 冒泡排序

### 2.1 算法原理

1. 冒泡排序的基本思想是**对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小（最大）的元素浮到顶端，最终达到完全有序**。

![](https://notebook.ricear.com/media/202105/2021-05-04_183505.png)

### 2.2 参考代码

1. 在冒泡排序过程中，如果某一趟执行完毕，没有做任何一次交换操作，这就说明剩下的序列已经是有序的，排序操作也就可以完成了。

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/3 21:10
 * @Description 冒泡排序算法
 */
public class BubbleSort {
    public static void sort(int[] arr) {
        int m = arr.length;
        for (int i = 0; i < m - 1; i++) {
            //  判断是否需要交换
            boolean exchange = false;
            for (int j = 0; j < m - i - 1; j++) {
                //  如果前面一个元素比后面一个元素大，则交换两个元素的位置，同时将 exchange 置为 true
                if (arr[j] > arr[j+1]) {
                    CommonUtils.swap(arr, j, j+1);
                    exchange = true;
                }
            }
            if (!exchange) {
                //  如果这一次冒泡没有发生交换，则说明前面的元素都已经有序了，没有必要再进行下一次冒泡了
                break;
            }
        }
    }
}
```

### 2.3 算法分析

1. 对于冒泡排序算法，若原数组本身就是有序的，仅需 $n-1$ 次比较即可完成；若是倒序，比较次数为 $(n-1) + (n-2) + ... + 1 = n(n-1)/2$，交换次数和比较次数等值，所以，时间复杂度依然为 $O(n^2)$。
2. 综合来看，冒泡排序性能还是稍差于上面的**简单选择排序**的。
3. 在相邻元素相等时，他们不会交换位置，所以，冒泡排序是**稳定排序**。

### 2.4 适用场景

1. 冒泡排序思路简单，代码也简单，特别**适合小数据的排序**，但是，由于**算法复杂度较高**，在**数据量大的时候不适用**。

## 3 直接插入排序

### 3.1 算法原理

1. 直接插入排序算法的基本思想是**每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止**。

![](https://notebook.ricear.com/media/202105/2021-05-04_195701.png)

### 3.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/3 21:28
 * @Description 直接插入排序算法
 */
public class DirectInsertionSort {
    public static void sort(int[] arr) {
        int m = arr.length;
        for (int i = 1; i < m; i++) {
            int j = i;
            while (j > 0 && arr[j - 1] > arr[j]) {
                CommonUtils.swap(arr, j - 1, j);
                j--;
            }
        }
    }
}
```

### 3.3 算法分析

1. 简单插入排序在**最好情况下**需要比较 $n-1$ 次，无需交换元素，**时间复杂度为 $O(n)$**；在最坏情况下，时间复杂度依然为 $O(n^2)$。
2. 但是，在**数组元素随机排列**的情况下，插入排序还是要**优于上面两种排序**的。
3. 由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是**稳定排序**。

### 3.4 适用场景

1. 简单插入排序由于 $O(n^2)$ 的复杂度，在数组较大时不适用，但是，当数据比较少的时候，是一个不错的选择，一般作为**快速排序的扩充**。
2. 例如，在 `JDK 7` 中的 `java.util.Arrays` 所用的 `sort` 方法的实现中，当待排序数组长度小于 47 时，会使用插入排序。

## 4 希尔排序

### 4.1 算法原理

1. 希尔排序也是一种**插入排序**，它是**简单插入排序**经过改进之后的一个更高效的版本，也称为**递减增量排序算法。**
2. 希尔排序的基本思想是**把记录按下标的一定增量分组，对每组使用直接插入算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止**。
3. **简单插入排序很循规蹈矩**，不管数组分布是怎样的，依然一步一步对元素进行比较、移动、插入，比如 $[5,4,3,2,1]$ 这种倒序序列，数组末端的 0 要回到首位是很费劲的，比较和移动元素均需 $n-1$ 次。
4. 而希尔排序在数组中采用**跳跃式分组**的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为 1。
5. 希尔排序通过这种策略使得整个数组**在初始阶段达到从宏观上看基本有序**，**小的基本在前**，大的基本在后，然后缩小增量，到增量为 1 时，大多数情况下只需微调即可，不会涉及过多的数据移动。
6. 希尔排序的具体排序过程如下：
   1. 假如有这样一组数 $[13,14,94,33,82,25,59,94,65,23,45,27,73,25,39,10]$，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好的描述算法：
      
      ```txt
      13 14 94 33 82
      25 59 94 65 23
      45 27 73 25 39
      10
      ```
   2. 然后我们对每列进行**直接插入排序**：
      
      ```txt
      10 14 73 25 23
      13 27 94 33 39
      25 59 94 65 82
      45
      ```
   3. 然后再以 3 为步长进行排序：
      
      ```txt
      10 14 73
      25 23 13
      27 94 33
      39 25 59
      94 65 82
      45
      ```
   4. 排序之后的结果为：
      
      ```txt
      10 14 13
      25 23 33
      27 25 59
      39 65 73
      45 94 82
      94
      ```
   5. 最后再以 1 为步长进行排序，此时就是简单排序了。

### 4.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/4 19:34
 * @Description 希尔排序
 */
public class ShellSort {
    public static void sort(int[] arr) {
        int len = arr.length;
        //  增量 gap，并不断缩小增量
        for (int gap = len / 2; gap >= 1; gap = gap / 2) {
            //  从第 gap 个元素开始，对每个组使用直接插入排序
            for (int i = gap; i < len; i++) {
                int j = i;
                int temp = arr[i];
                while (j - gap >= 0 && temp < arr[j - gap]) {
                    //  将元素向后移动 gap 位
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = temp;
            }
        }
    }
}
```

### 4.3 算法分析

1. 希尔排序算法中对**增量序列的选择**十分重要，直接影响到希尔排序的性能，当选择增量序列为 $n/2^i$ 时，其最坏时间复杂度依然为 $O(n^2)$。
2. 希尔排序是**不稳定排序算法**。

### 4.4 适用场景

1. 希尔排序虽然快，但是毕竟是插入排序，其数量级并**没有快速排序快**，在大量数据面前，希尔排序不是一个好的算法，但是**中小型规模的数据完全可以使用它**。

## 5 快速排序

### 5.1 算法原理

1. 快速排序是对**冒泡排序**的改进，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。
2. 快速排序的基本思想是：
   
   1. 在待排序的元素**任取一个元素作为基准**（通常选第一个元素），称为**基准元素**。
   2. 将待排序的元素进行**分区**，**比基准元素大的元素放在他的右边，比其小的放在他的左边**。
   3. **对左右两个分区重复以上的步骤直到所有元素都是有序的**。
3. 快速排序算法的具体过程如下图：
   
   ![](https://notebook.ricear.com/media/202206/2022-06-27_110211_290113.gif)

### 5.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/4 20:54
 * @Description 快速排序算法
 */
public class QuickSort {
    public static void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    /**
     * 快速排序算法
     * @param arr   数组
     * @param _left 左边界
     * @param _right 右边界
     */
    public static void quickSort(int[] arr, int _left, int _right) {
        int left = _left;
        int right = _right;
        int temp = 0;
        if (left <= right) {
            //  待排序的第一个元素作为基准元素
            temp = arr[left];
            //  从左到有交替扫描，直到 left = right
            while (left != right) {
                //  从右往左扫描，找到第一个比基准元素小的元素
                while (right > left && arr[right] >= temp) {right--;}
                //  找到这种元素 arr[right] 后与 arr[left] 交换
                arr[left] = arr[right];

                //  从左往右扫描，找到第一个比基准元素大的元素
                while (left < right && arr[left] <= temp) {left++;}
                //  找到这种元素 arr[left] 后与 arr[right] 交换
                arr[right] = arr[left];
            }
            //  基准元素归位
            arr[right] = temp;
            //  对基准元素左边的元素进行递归排序
            quickSort(arr, _left, left - 1);
            //  对基准元素右边的元素进行递归排序
            quickSort(arr, right + 1, _right);
        }
    }
}
```

### 5.3 算法分析

1. 当分区选取的基准元素为待排元素中的**最大或最小值**时，为**最坏的情况**，**时间复杂度**和直接插入排序的一样，移动次数达到最大值 $C_{max}=1+2+...+(n-1)=n*(n-1)/2=O(n^2)$。
2. 当分区选取的基准元素为待排序中的**中值**，为最好的情况，**时间复杂度为 $O(nlog_2n)$**。
3. 快速排序的**空间复杂度**为 $O(log_2n)$。
4. 当待排元素类似 $[6,1,3,7,3]$ 且基准元素为 6 时，经过分区，形成 $[1,3,3,6,7]$，两个 3 的相对位置发生了改变，所以快速排序是一种**不稳定排序算法**。

### 5.4 适用场景

1. 快速排序在**大多数情况下**都是**适用**的，**尤其在数据量大的时候**性能优越更加明显，但在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。

### 5.5 扩展题目

#### 5.5.1 单链表快速排序

##### 5.5.1.1 值交换

###### 5.5.1.1.1 问题分析

1. 快速排序的思想就是**找一个 `pivot`**，**把小于 `pivot` 分在一边**，**大于等于 `pivot` 的分在另一边**。
2. 这个过程也叫做 `partition` 分区，数组的分区很好做，左右两个指针，不断交换就可以了，链表因为只能单向遍历，所以要换一种 `partition` 方法，目的是**使得左边的值都小于 `pivot`**，**右边的值都不小于 `pivot`**，所以**用一个索引记录左边的坐标**，**遍历过程中**，**每次碰到比 `pivot` 小的**，**都要交换一下**，**放到左边**，**遍历完成后**，**再把 `pivot` 放到中间来**，**这样就达成了目的**。
   
   ![](https://notebook.ricear.com/media/202206/2022-06-27_170430_826067.gif)

###### 5.5.1.1.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/9/20 15:08
 * @Description 快速排序算法
 */
public class QuickSort {
    /**
     * 使用单链表实现快速排序算法（值交换）
     * @param head  单链表头结点
     * @return  排序后的单链表
     */
    public ListNode sortList(ListNode head) {
        quickSortWithValExchange(head, null);
        return head;
    }

    /**
     * 单链表快速排序算法（值交换）
     * @param head  单链表头结点
     * @param tail  单链表尾节点
     */
    private void quickSortWithValExchange(ListNode head, ListNode tail) {
        if (head == tail || head.next == tail) {return;}
        int pivot = head.val;
        ListNode left = head, cur = head.next;

        while (cur != tail) {
            if (cur.val < pivot) {
                left = left.next;
                swap(left, cur);
            }
            cur = cur.next;
        }

        swap(head, left);
        quickSortWithValExchange(head, left);
        quickSortWithValExchange(left.next, tail);
    }

    /**
     * 交换链表中两个节点的值
     * @param left  其中一个链表节点
     * @param cur   另外一个链表节点
     */
    private void swap(ListNode left, ListNode cur) {
        int temp = left.val;
        left.val = cur.val;
        cur.val = temp;
    }
}
```

##### 5.5.1.2 指针交换

###### 5.5.1.2.1 问题分析

1. 这道题目的解题方法如下：
   
   1. 首先**对链表进行划分**。
   2. 然后**递归调用**，**先重排右边的**，**然后把指针置空**，**再重排左边的**。
   3. 最后**将左半部分和右半部分进行拼接即可**。
   
   <iframe src="https://drive.google.com/file/d/1ScWJZLW8bkSPwiIQHzXc3y6QrLOEjRBc/preview" width="100%" height="480" allow="autoplay" allowfullscreen="true"></iframe>

###### 5.5.1.2.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/9/20 15:08
 * @Description 快速排序算法
 */
public class QuickSort {
    /**
     * 使用单链表实现快速排序算法（指针交换）
     * @param head  单链表头结点
     * @return  排序后的单链表
     */
    public ListNode sortList(ListNode head) {
        return quickSortWithPointerExchange(head);
    }

    /**
     * 单链表快速排序算法（指针交换）
     * @param head  单链表头结点
     * @return  排序后的单链表
     */
    private ListNode quickSortWithPointerExchange(ListNode head) {
        if (head == null || head.next == null) {return head;}

        int pivot = head.val;
        //  链表划分
        ListNode ls = new ListNode(-1), rs = new ListNode(-1);
        ListNode l = ls, r = rs, cur = head;

        while (cur != null) {
            if (cur.val < pivot) {l.next = cur; l = l.next;}
            else {r.next = cur; r = r.next;}
            cur = cur.next;
        }

        l.next = rs.next;
        r.next = null;

        //  递归调用，先重排右边的，然后把指针置空，再重排左边的
        ListNode right = quickSortWithPointerExchange(head.next);
        head.next = null;
        ListNode left = quickSortWithPointerExchange(ls.next);

        //  拼接左半部分和右半部分
        cur = left;
        while (cur.next != null) {cur = cur.next;}
        cur.next = right;

        return left;
    }
}
```

## 6 堆排序

### 6.1 算法原理

1. 堆是具有以下性质的完全二叉树：
   1. **每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆**。
   2. **每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆**。
      ![](https://notebook.ricear.com/media/202105/2021-05-05_203837.png)
2. 堆排序的基本思想为：
   1. **将待排序序列构造成一个大顶堆**（构造大顶堆的时候选取的初始值为**最后一个非叶子节点**），此时，整个序列的**最大**值就是**堆顶的根节点**。
   2. 将**堆顶的根节点与末尾元素进行交换**，此时**末尾元素就是最大值**。
   3. 将剩余的 $n - 1$ 个元素看作一个新堆，**原来根的孩子节点仍是大顶堆**，而**新的根节点可能会违背最大堆的性质**，因此我们需要采用上面构造大顶堆的方法来**调整堆**，使其**符合大顶堆的性质**。
   4. 然后重复上面交换新堆末尾元素和调整堆的过程，即可依次获取次小值，进而完成数据的排序。
   
   <iframe src="https://drive.google.com/file/d/1BFEQhmGgw7lHcFdTCPgKKS-HGYKQ0x9A/preview" width="100%" height="480" allow="autoplay" allowfullscreen="true"></iframe>

### 6.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/5 19:49
 * @Description 堆排序
 */
public class HeapSort {
    public static void sort(int[] arr) {
        //  1. 构建大顶堆：从第一个非叶子节点开始从下至上，从右至左调整结构
        int len = arr.length;
        //  第一个非叶子节点
        int beginIndex = (len >> 1) - 1;
        for (int i = beginIndex; i >= 0; i--) {
            adjustHeap(arr, i, len - 1);
        }

        //  2.调整堆结构:
        //      2.1 每次都是移出最顶层的根节点，与最尾部节点位置调换，同时遍历长度-1。
        //      2.2 然后重新整理被换到根节点的末尾元素，使其符合堆的特性。
        //      2.3 直到未排序的堆长度为 0
        for (int i = len - 1; i > 0; i--) {
            CommonUtils.swap(arr, 0, i);
            adjustHeap(arr, 0, i - 1);
        }
    }

    /**
     * 调整大顶推（仅是调整过程，建立在大顶堆已经构建的基础上）
     * @param arr   数组
     * @param index 需要堆化处理的数据的索引
     * @param length    未排序的数组的长度
     */
    public static void adjustHeap(int[] arr, int index, int length) {
        //  左子节点索引
        int left = (index << 1) + 1;
        //  右子节点索引
        int right = left + 1;
        //  子节点的最大索引，默认是左子节点
        int max = left;

        // 如果左子节点索引超出范围，则直接返回
        if (left > length) {return;}
        //  判断左右子节点哪个最大
        if (right <= length && arr[right] > arr[left]) {max = right;}
        //  判断是否需要交换子节点和父节点：
        //      如果需要的话，则交换相应的子节点和父节点，然后调整换下父节点后的堆使其符合堆的特性
        if (arr[max] > arr[index]) {
            CommonUtils.swap(arr, max, index);
            adjustHeap(arr, max, length);
        }
    }
}
```

### 6.3 算法分析

1. 堆排序算法**在最好和最坏情况下的时间复杂度都为 $O(nlog_2n)$**，**空间复杂度为 $O(1)$**。
2. 堆排序算法是**不稳定排序算法**。

### 6.4 适用场景

1. 堆排序在**建立堆**和**调整堆**的过程中会产生比较大的开销，在**元素少的时候**并**不适用**，但是**在元素比较多的时候**还**是一个不错的选择**。
2. **在解决诸如 `前 n 的数` 一类问题时**，几乎**是首选算法**。

### 6.5 扩展题目

#### 6.5.1 [数组中的第 K 个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

##### 6.5.1.1 问题分析

1. 我们可以构建一个大顶堆，然后在堆排序的过程中，每次调整大顶堆，我们都可以获取一个较大的元素，这样我们只需调整 $k$ 次，便可以将前 $k$ 大的元素排好位置，然后直接返回第 $arr.length - k$ 个元素即可。
2. 对于求**前 $k$ 大元素**的题目，一般用**堆排序**来解决。

##### 6.5.1.2 参考代码

```java
/**
 * 调整堆
 * @param arr   数组
 * @param index 需要堆化处理的数据的索引
 * @param length    未排序的数组的长度
 */
public static void adjustHeap(int[] arr, int index, int length) {
    int left = (index << 1) + 1;
    int right = left + 1;
    int max = left;
    if (left > length) return;
    if (right <= length && arr[right] > arr[left]) {max = right;}
    if (arr[max] > arr[index]) {
        CommonUtils.swap(arr, max, index);
        adjustHeap(arr, max, length);
    }
}

/**
 * 堆排序
 * @param arr   数组
 * @param k 前几个数
 */
public static void sort(int[] arr, int k) {
    //  1. 构造大顶堆
    int length = arr.length;
    int beginIndex = (length >> 1) - 1;
    for (int i = beginIndex; i >= 0; i--) {
        adjustHeap(arr, i, length - 1);
    }

    //  2. 调整大顶堆
    for (int i = length - 1; i >= length - k; i--) {
        CommonUtils.swap(arr, 0, i);
        adjustHeap(arr, 0, i - 1);
    }
}

/**
 * 215. 数组中的第 K 个最大元素（版本 2：堆排序）
 * @param nums  数组
 * @param k 前几个数
 * @return  第 K 个最大元素
 */
public int findKthLargestV2(int[] nums, int k) {
    sort(nums, k);
    return nums[nums.length - k];
}
```

#### 6.5.2 [数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof)

##### 6.5.2.1 问题分析

1. 我们可以**建立一个小顶堆 $A$ 和大顶堆 $B$**，**各保存列表的一半元素**，且规定：
   
   1. **$A$ 保存较大的一半**，**长度为 $\frac{N}2$**（$N$ 为偶数）**或 $\frac{N + 1}2$**（$N$ 为奇数）。
   2. **$B$ 保存较小的一半**，**长度为 $\frac{N}2$**（$N$ 为偶数）**或 $\frac{N - 1}2$**（$N$ 为奇数）。
2. 随后，**中位数可仅根据 $A、B$ 的堆顶元素计算得到**：
   
   ![Picture1.png](https://notebook.ricear.com/media/202202/2022-02-09_1419550.3791480604271996.png)
3. 算法流程如下：
   
   1. **设元素总数为 $N = m + n$**，**其中 $m$ 和 $n$ 分别为 $A$ 和 $B$ 中的元素个数**。
   2. `addNum(num)`**函数**：
      1. **当 $m = n$**（即 $N$**为偶数**）：**需向 $A$ 添加一个元素**，实现方法为**将新元素 $num$ 插入至 $B$**，**再将 $B$ 堆顶元素插入至 $A$**。
      2. **当 $m \ne n$**（即 $N$**为奇数**）：**需向 $B$ 添加一个元素**，实现方法为**将新元素 $num$ 插入至 $A$**，**再将 $A$ 堆顶元素插入至 $B$**。
         > 假设插入数字 $num$ 遇到情况 1，由于 $num$**可能属于较小的一半**（即属于 $B$），因此**不能将 $num$ 直接插入 $A$**，**而应先将 $num$ 插入 $B$**，**再将 $B$ 堆顶元素插入至 $A$**，**这样就可以始终保持 $A$ 保存较大一半**，$B$**保存较小一半**。
   3. `findMedian()`**函数**：
      1. **当 $m = n$**（即 $N$**为偶数**）：**则中位数为 $\frac{A 的堆顶元素 + B 的堆顶元素}2$**。
      2. **当 $m \ne n$**（即 $N$**为奇数**）：**则中位数为 $A$ 的堆顶元素**。

##### 6.5.2.2 参考代码

```java
/**
 * 剑指 Offer 41. 数据流中的中位数
 */
class MedianFinder {

    Queue<Integer> A, B;

    /** initialize your data structure here. */
    public MedianFinder() {
        A = new PriorityQueue<>();
        B = new PriorityQueue<>((x, y) -> (y - x));
    }

    public void addNum(int num) {
        if (A.size() != B.size()) {
            A.add(num);
            B.add(A.poll());
        } else {
            B.add(num);
            A.add(B.poll());
        }
    }

    public double findMedian() {
        int size = A.size() + B.size();
        if (size % 2 != 0) {
            return (double)A.peek();
        } else {
            return (double)(A.peek() + B.peek()) / 2;
        }
    }
}
```

## 7 归并排序

### 7.1 算法原理

1. 归并排序是**创建在归并操作上的一种有效的排序算法**。
2. 该算法是采用**分治法**（Divide and Conquer）的一种非常典型的应用，且各层递归可以同时进行。
3. 归并算法的具体过程如下（**分而治之**）：

![](https://notebook.ricear.com/media/202105/2021-05-05_212356.png)

4. **合并相邻有序子序列**的方法：

![](https://notebook.ricear.com/media/202105/2021-05-05_212635.png)

![](https://notebook.ricear.com/media/202105/2021-05-05_212646.png)

### 7.2 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/5/5 21:28
 * @Description 归并排序
 */
public class MergeSort {
    /**
     * 归并排序
     * @param arr   数组
     */
    public static void sort(int[] arr) {
        int length = arr.length;
        int[] temp = new int[length];
        sort(arr, 0, length - 1, temp);
    }

    /**
     * 归并排序（递归）
     * @param arr   数组
     * @param left  左边界
     * @param right 右边界
     * @param temp  临时数组
     */
    public static void sort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            //  左边归并排序，使得左子序列有序
            sort(arr, left, mid, temp);
            //  右边归并排序，使得右子序列有序
            sort(arr, mid + 1, right, temp);
            //  将两个有序子数组合并
            merge(arr, left, mid, right, temp);
        }
    }

    /**
     * 合并两个序列
     * @param arr   数组
     * @param left  左边界
     * @param mid   中间元素
     * @param right 右边界
     * @param temp  临时数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        //  左序列指针
        int i = left;
        //  右序列指针
        int j = mid + 1;
        //  临时数组指针
        int t = 0;

        //  开始遍历左右两个序列
        while (i <= mid && j <= right) {
            //  如果左边的元素小一些，则将左边的元素移动到 temp 数组中，同时左边的指针加 1
            if (arr[i] <= arr[j]) {temp[t++] = arr[i++];}
            //  如果右边的元素小一些，则将右边的元素移动到 temp 数组中，同时右边的指针加 1
            else if (arr[i] > arr[j]) {temp[t++] = arr[j++];}
        }

        //  将左边的剩余元素移动到 temp 中
        while (i <= mid) {temp[t++] = arr[i++];}
        //  将右边的剩余元素移动到 temp 中
        while (j <= right) {temp[t++] = arr[j++];}

        //  将 temp 中的元素全部拷贝到原数组中
        t = 0;
        while (left <= right) {arr[left++] = temp[t++];}
    }
}
```

### ![](https://notebook.ricear.com/media/202105/2021-05-06_191525.png)7.3 算法分析

1. 归并排序算法**在最好情况下和最坏情况下的时间复杂度均为 $O(nlog_2n)$，空间复杂度为 $O(n)$。**
2. 归并排序算法是一种**稳定排序算法**，同时也是一种十分高效的排序算法，其速度仅次于快速排序。

### 7.4 适用场景

1. 归并排序在**数据量比较大**的时候在**效率上**也**有较为出色的表现**。
2. 但是，其**空间复杂度**$O(n)$ 使得**在数据量特别大的时候**（例如 1000 万条数据）几乎**不可接受**，而且，考虑到有的机器内存本身就比较小，因此，**采用归并排序时一定要注意**。

### 7.5 扩展题目

#### 7.5.1 [数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof)

##### 7.5.1.1 问题分析

1. **[归并排序](#7-归并排序)与逆序对是息息相关的**，**归并排序体现了分而治之的思想**，**具体为**：
   
   1. **分**：**不断将数组从中点位置划分开**，**将整个数组的排序问题转化为子数组的排序问题**。
   2. **治**：**划分到子数组长度为 1 时**，**开始向上合并**，**不断将较短排序树组合并为较长排序树组**，**直至合并至原数组时完成排序**。
2. **合并阶段本质上是合并两个排序数组的过程**，**而每当遇到 $ 左子数组当前元素 \gt 右子数组当前元素 $ 时**，**意味着 $ 左子数组当前元素至末尾元素 $ 与 $ 右子数组当前元素 $ 构成了若干逆序对**。
3. **因此**，**考虑在归并排序的合并阶段统计逆序对数量**，**完成归并排序时**，**也随之完成所有逆序对的统计**。
   
   ![Picture2.png](https://notebook.ricear.com/media/202202/2022-02-10_1954210.9101305560938778.png)

##### 7.5.1.2 参考代码

```java
/**
 * 剑指 Offer 51. 数组中的逆序对
 * @param nums  数组
 * @return  数组中的逆序对的总数
 */
public int reversePairs(int[] nums) {
    int length = nums.length;
    int[] temp = new int[length];
    return sort(nums, 0, length - 1, temp);
}

/**
 * 归并排序（递归）
 * @param arr   数组
 * @param left  左边界
 * @param right 右边界
 * @param temp  临时数组
 * @return 数组中的逆序对的总数
 */
public int sort(int[] arr, int left, int right, int[] temp) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        //  左边归并排序，使得左子序列有序
        int res = sort(arr, left, mid, temp);
        //  右边归并排序，使得右子序列有序
        res += sort(arr, mid + 1, right, temp);
        //  将两个有序子数组合并
        return merge(arr, left, mid, right, temp, res);
    }
    return 0;
}

/**
 * 合并两个序列
 * @param arr   数组
 * @param left  左边界
 * @param mid   中间元素
 * @param right 右边界
 * @param temp  临时数组
 * @return 数组中的逆序对的总数
 */
public int merge(int[] arr, int left, int mid, int right, int[] temp, int res) {
    //  左序列指针
    int i = left;
    //  右序列指针
    int j = mid + 1;
    //  临时数组指针
    int t = 0;

    //  开始遍历左右两个序列
    while (i <= mid && j <= right) {
        //  如果左边的元素小一些，则将左边的元素移动到 temp 数组中，同时左边的指针加 1
        if (arr[i] <= arr[j]) {temp[t++] = arr[i++];}
        //  如果右边的元素小一些，则将右边的元素移动到 temp 数组中，同时右边的指针加 1，然后统计逆序对的数量
        else if (arr[i] > arr[j]) {
            temp[t++] = arr[j++];
            res += mid - i + 1;
        }
    }

    //  将左边的剩余元素移动到 temp 中
    while (i <= mid) {temp[t++] = arr[i++];}
    //  将右边的剩余元素移动到 temp 中
    while (j <= right) {temp[t++] = arr[j++];}

    //  将 temp 中的元素全部拷贝到原数组中
    t = 0;
    while (left <= right) {arr[left++] = temp[t++];}

    return res;
}
```

## 8 总结

### 8.1 算法分类

十种常见排序算法可以分为两大类：

* **比较类排序：** 通过**比较**来决定**元素间的相对次序**，由于其**时间复杂度不能突破 $O(nlogn)$**，因此也称为**非线性时间比较类排序**。
* **非比较类排序：不通过比较**来决定**元素间的相对次序**，他**可以突破基于比较排序的时间下界**，以线性时间运行，因此也称为**线性时间非比较类排序**。

![](https://notebook.ricear.com/media/202105/2021-05-06_184235.png)

### 8.2 算法复杂度

* **稳定：** 如果 `a` 原本在 `b` 前面，且 `a=b`，排序之后 `a` 仍然在 `b` 前面。
* **不稳定：** 如果 `a` 原本在 `b` 前面，且 `a=b`，排序之后 `a` 可能会在 `b` 的后面。
* **时间复杂度：** 对排序数据的**总的操作次数**，反映当 `n` 变化时呈现什么规律。
* **空间复杂度：** 指**算法在计算机内执行时所需存储空间的度量**，他也是数据规模 `n` 的函数。

![](https://notebook.ricear.com/media/202105/2021-05-06_191453.png)

#### 8.2.1 稳定性

**稳定**的算法有：**插（如排序）、冒（泡排序）、归（并排序）、计（数排序）、桶（排序）、基（数排序）**。

**不稳定**的算法有：其他的 4 种都为不稳定的排序算法。

#### 8.2.2 时间复杂度

平均时间复杂度为 $O(nlog_2n)$ 的有：**堆（排序）、快（速排序）、归（并排序）**。

平均时间复杂度为 $O(n^{1.3})$ 的有：**希（尔排序）**。

平均时间复杂度为 $O(n^2)$ 的有：**插（入排序）、选（择排序）、冒（泡排序）**。

#### 8.2.3 空间复杂度

空间复杂度为 $O(1)$ 的有：**插（入排序）、希（尔排序）、选（择排序）、堆（排序）、冒（泡排序）**。

空间复杂度为 $O(n)$ 的有：**归（并排序）**。

空间复杂度为 $O(nlog_2n)$ 的有：**快（速排序）**。

## 参考文献

1. [图解排序算法(一)之 3 种简单排序(选择，冒泡，直接插入)](https://www.cnblogs.com/chengxiao/p/6103002.html)。
2. [希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)。
3. [图解快速排序](https://www.cnblogs.com/MOBIN/p/4681369.html)。
4. [快速排序算法详解（原理、实现和时间复杂度）](http://data.biancheng.net/view/117.html)。
5. [图解排序算法(三)之堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)。
6. [堆排序](https://zh.wikipedia.org/zh-cn/%E5%A0%86%E6%8E%92%E5%BA%8F)。
7. [图解排序算法(四)之归并排序](https://www.cnblogs.com/chengxiao/p/6194356.html)。
8. [【算法】排序算法之归并排序](https://zhuanlan.zhihu.com/p/124356219)。
9. [[算法总结] 十大排序算法](https://weiweiblog.cn/10sort)。
10. [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)。
11. [ 面试官：你写个链表快排吧（不准交换节点的值哦）](https://leetcode-cn.com/problems/sort-list/solution/gui-bing-pai-xu-he-kuai-su-pai-xu-by-a380922457)。
12. [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof)。
13. [面试题 41. 数据流中的中位数（优先队列 / 堆，清晰图解）](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y)。
14. [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof)。
15. [剑指 Offer 51. 数组中的逆序对（归并排序，清晰图解）](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h)。




<h1 style='page-break-before: always;'>1.4 二叉树</h1>

1.5 二叉树




<h1 style='page-break-before: always;'>1.4.0 二叉树遍历</h1>

## 1 算法模板

二叉树遍历算法分为两种，一种是**深度优先遍历算法**，例如前序遍历、中序遍历、后序遍历，另一种是**广度优先遍历算法**，例如层序遍历。

### 1.1 深度优先遍历算法

#### 1.1.1 递归解法

##### 1.1.1.1 前序遍历

```java
/**
 * 前序遍历（递归解法）
 *
 * @param head 头结点
 */
public void preOrderRecur(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    //  访问根节点
    System.out.println(head.val);
    //  遍历左节点
    preOrderRecur(head.left);
    //  遍历右节点
    preOrderRecur(head.right);
}
```

##### 1.1.1.2 中序遍历

> **二叉搜索树的中序遍历为一个递增序列**。

```java
/**
 * 中序遍历（递归解法）
 *
 * @param head 头结点
 */
public void inOrderRecur(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    //  遍历左节点
    preOrderRecur(head.left);
    //  访问根节点
    System.out.println(head.val);
    //  遍历右节点
    preOrderRecur(head.right);
}
```

##### 1.1.1.3 后序遍历

```java
/**
 * 后序遍历（递归解法）
 *
 * @param head 头结点
 */
public void postOrderRecur(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    //  遍历左节点
    preOrderRecur(head.left);
    //  遍历右节点
    preOrderRecur(head.right);
    //  访问根节点
    System.out.println(head.val);
}
```

#### 1.1.2 迭代解法

##### 1.1.2.1 前序遍历

1. 初始时，将根节点入栈。
2. 判断栈是否为空，如果栈不为空：

   1. 弹出栈顶元素 $node$，并将 $node.val$ 输出。
   2. 如果 $node$ 的右子树不为空，则将其对应的右子树 $node.right$ 入栈。
   3. 如果 $node$ 的左子树不为空，则将其对应的左子树 $node.right$ 入栈。

![](https://notebook.ricear.com/media/202106/前序遍历（迭代解法）_1623760901.gif)

```java
/**
 * 前序遍历（迭代解法）
 *
 * @param head 头结点
 */
public void preOrderInter(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    //  用来模仿递归解法中的栈
    Stack<TreeNode> stack = new Stack<>();
    //  初始时将头结点入栈
    stack.push(head);
    while (!stack.empty()) {
        //  访问根节点
        TreeNode node = stack.pop();
        System.out.println(node.val);
        //  将右节点入栈（左节点会先出栈，所以等价于遍历左节点）
        if (node.right != null) {
            stack.push(node.right);
        }
        //  将左节点入栈（右节点会后出栈，所以等价于遍历右节点）
        if (node.left != null) {
            stack.push(node.left);
        }
    }
}
```

##### 1.1.2.2 中序遍历

1. 令当前指针 $cur=head$。
2. 判断栈和当前 $cur$ 是否为空，如果二者有一个不为空：
   1. 判断当前 $cur$ 是否为空，如果 $cur$ 不为空（**目的是尽量让当前节点的左子树入栈**）：
      1. 将 $cur$ 入栈。
      2. 令 $cur=cur.left$。
      3. 重复步骤 A，直到 $cur$ 为空。
   2. 弹出栈中的节点 $node$，并输出弹出节点的值 $node.val$。
   3. 如果 $node$ 的右子树不为空，则令 $cur=cur.right$。

![](https://notebook.ricear.com/media/202106/中序遍历（迭代解法）_1623761272.gif)

```java
/**
 * 中序遍历（迭代解法）
 *
 * @param head 头结点
 */
public void inOrderInter(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    TreeNode cur = head;
    //  用来模仿递归解法中的栈
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.empty() || cur != null) {
        //  尽可能将这个节点的左子树入栈，相当于访问左子树
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        //  相当于访问根节点
        TreeNode node = stack.pop();
        System.out.println(node.val);
        //  相当于访问右节点
        if (node.right != null) {
            cur = node.right;
        }
    }
}
```

##### 1.1.2.3 后序遍历

后序遍历和先序遍历类似，不过后序遍历是**左子树先入栈**，**右子树后入栈**。

```java
/**
 * 后序遍历（迭代解法）
 *
 * @param head 头结点
 */
public void postOrderInter(TreeNode head) {
    //  base case
    if (head == null) {
        return;
    }
    //  用来模仿递归解法中的栈
    Stack<TreeNode> stack = new Stack<>();
    //  用于将根节点的值入栈
    Stack<Integer> stack2 = new Stack<>();
    //  初始时将头结点入栈
    stack.push(head);
    while (!stack.empty()) {
        //  访问根节点
        TreeNode node = stack.pop();
        //  将根节点的值入栈
        stack2.push(node.val);
        //  将右节点入栈（左节点会先出栈，所以等价于遍历左节点）
        if (node.right != null) {
            stack.push(node.right);
        }
        //  将左节点入栈（右节点会后出栈，所以等价于遍历右节点）
        if (node.left != null) {
            stack.push(node.left);
        }
    }

    //  遍历第二个栈中的值
    while (!stack2.isEmpty()) {
        System.out.println(stack2.pop());
    }
}
```

### 1.2 广度优先遍历算法

#### 1.2.1 层序遍历

##### 1.2.1.1 输出一维数组

和前序遍历类似，不过层序遍历采用的是**队列**来存储相应的节点，因此是**左子树先加入队列**，这样在出队时就是**左子树先出对**。

```java
/**
 * 层序遍历（迭代解法，输出一维数组）
 *
 * @param head 头结点
 */
public void levelOrderInterV1(TreeNode head) {
    //  用户保存根节点
    Queue<TreeNode> queue = new ArrayDeque<>();
    //  初始时将根节点加入队列
    queue.add(head);
    while (!queue.isEmpty()) {
        //  将队列中的节点弹出，然后将其值加入到结果中
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if (node.left != null) {
            //  如果左子树非空，则将左子树加入到队列中
            queue.add(node.left);
        }
        if (node.right != null) {
            //  如果右子树非空，则将右子树加入到队列中
            queue.add(node.right);
        }
    }
}
```

##### 1.2.1.2 输出二维数组

1. 创建结果数组 $res$，
2. 初始时，将根节点加入队列。
3. 判断队列是否为空，如果队列不为空：
   1. 创建临时结果数组 $tempRes$，然后计算队列的大小为 $n$，然后将队列中的元素依次出队：
      1. 弹出队首元素 $node$，并将 $node.val$ 添加到 $tempRes$ 中。
      2. 如果 $node$ 的右子树不为空，则将其对应的右子树 $node.right$ 加入队列。
      3. 如果 $node$ 的左子树不为空，则将其对应的左子树 $node.left$ 加入队列。
   2. 将 $tempRes$ 添加到中 $res$。

![](https://notebook.ricear.com/media/202106/层序遍历（迭代解法：输出二维数组）_1623762105.gif)

```java
/**
 * 层序遍历（迭代解法，输出二维数组）
 *
 * @param head 头结点
 */
public List<List<Integer>> levelOrderInterV2(TreeNode head) {
    List<List<Integer>> res = new ArrayList<>();
    //  如果头结点为空，则直接返回 res
    if (head == null) {return res;}
    //  用户保存根节点
    Queue<TreeNode> queue = new ArrayDeque<>();
    //  初始时将根节点加入队列
    queue.add(head);
    while (!queue.isEmpty()) {
        //  一次性将同一层的节点都遍历一下
        List<Integer> tempRes = new ArrayList<>();
        int n = queue.size();
        for (int i = 0; i < n; i++) {
            //  将队列中的节点弹出，然后将其值加入到结果中
            TreeNode node = queue.poll();
            tempRes.add(node.val);
            if (node.left != null) {
                //  如果左子树非空，则将左子树加入到队列中
                queue.add(node.left);
            }
            if (node.right != null) {
                //  如果右子树非空，则将右子树加入到队列中
                queue.add(node.right);
            }
        }
        //  将当前层的遍历结果添加到最终结果中
        res.add(tempRes);
    }
    return res;
}
```

##### 1.2.1.3 输出锯齿形二维数组

1. 该方法是在输出二维数组的基础上加上一个当前遍历层数的判断，如果当前遍历的层数为**偶数层**，则将当前的结果进行**反转一下**，然后再添加到最后的结果中，这样便可以实现输出锯齿形二维数组，具体的演示过程可参考前面的[输出二维数组](#2-1-2-输出二维数组)解法。

```java
/**
 * 层序遍历（迭代解法，输出锯齿形二维数组）
 *
 * @param head 头结点
 */
public List<List<Integer>> zigzagLevelOrderInter(TreeNode head) {
    List<List<Integer>> res = new ArrayList<>();
    //  记录当前遍历的层数
    int level = 0;
    //  如果头结点为空，则直接返回 res
    if (head == null) {return res;}
    //  用户保存根节点
    Queue<TreeNode> queue = new ArrayDeque<>();
    //  初始时将根节点加入队列
    queue.add(head);
    //  遍历的层数加 1
    level++;
    while (!queue.isEmpty()) {
        //  一次性将同一层的节点都遍历一下
        List<Integer> tempRes = new ArrayList<>();
        int n = queue.size();
        for (int i = 0; i < n; i++) {
            //  将队列中的节点弹出，然后将其值加入到结果中
            TreeNode node = queue.poll();
            tempRes.add(node.val);
            if (node.left != null) {
                //  如果左子树非空，则将左子树加入到队列中
                queue.add(node.left);
            }
            if (node.right != null) {
                //  如果右子树非空，则将右子树加入到队列中
                queue.add(node.right);
            }
        }
        //  如果遍历的层数是偶数层，则将当前层的结果反转一下，变为从右往左遍历
        if (level % 2 == 0) {
            List<Integer> tempRes2 = new ArrayList<>();
            for (int i = tempRes.size() - 1; i >= 0; i--) {
                tempRes2.add(tempRes.get(i));
            }
            tempRes = tempRes2;
        }
        //  将当前层的遍历结果添加到最终结果中
        res.add(tempRes);
        level++;
    }
    //  遍历的层数加 1
    return res;
}
```

## 2 典型题目

### 2.1 翻转二叉树

> 题目内容详见[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree)。

#### 2.1.1 问题分析

1. 这道题目主要有两种解法，分别是**递归**（深度优先遍历）、**迭代**（广度优先遍历），分别套用前面的相应的模板即可。
2. 需要注意的是：
   1. **递归时需要定义一个临时变量来保存左子树的数据**，**然后再进行下面的递归**。
   2. **迭代时直接在原来访问根节点的地方添加节点替换逻辑即可**。

#### 2.1.2 参考代码

##### 2.1.2.1 递归

```java
/**
 * 226. 翻转二叉树（版本 1：递归）
 * @param root  根节点
 * @return  反转后的二叉树
 */
public TreeNode invertTreeV1(TreeNode root) {
    return dfs(root);
}

/**
 * 递归翻转二叉树
 * @param root  根节点
 * @return  反转后的二叉树
 */
public TreeNode dfs(TreeNode root) {
    if (root == null) {return null;}

    //  保留左子树的数据
    TreeNode leftTemp = root.left;
    root.left = dfs(root.right);
    root.right = dfs(leftTemp);

    return root;
}
```

##### 2.1.2.2 迭代

```java
/**
 * 226. 翻转二叉树（版本 2：层序遍历）
 * @param root  根节点
 * @return  反转后的二叉树
 */
public TreeNode invertTreeV2(TreeNode root) {
    if (root == null) {return null;}

    Queue<TreeNode> queue = new ArrayDeque<>();

    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode node = queue.poll();

        //  交换节点信息
        TreeNode leftTemp = node.left;
        node.left = node.right;
        node.right = leftTemp;

        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }

    return root;
}
```

### 2.2 对称二叉树

> 题目内容详见[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)。

#### 2.2.1 问题分析

1. 对于二叉树的题目，一般可通过**递归**和**迭代**两种方法来求解：

   1. 递归时一般需先**找出题目中蕴含的递归关系**，然后**确定递归函数的含义**，一般递归采用的都是**深度优先遍历**，**递归算法也是在原有的深度优先遍历算法上的改进**。
   2. 迭代时一般采用的是**广度优先遍历**，**迭代算法也是在原有的广度优先遍历算法上的改进**。
2. **如果一棵树的左子树和右子树对称**，**那么这个树是对称的**。
3. 因此，这个问题可以转化为**两棵树在什么情况下互为镜像**，如果同时满足下面的条件，两棵树互为镜像：

   1. 他们的**两个根节点具有相同的值**。
   2. **每个树的左子树都与另一个树的右子树镜像对称**。
   3. **每个树的右子树都与另一个树的左子树镜像对称**。
4. 我们可以实现这样一个递归函数，**通过同步移动两个指针的方法来遍历这棵树**：

   1. **$left$ 指针和 $right$ 指针一开始都指向这棵树的根**。
   2. **随后 $left$ 左移时**，$right$**右移**，$left$**右移时**，**$right$ 左移**。
   3. **每次检查当前 $left$ 和 $right$ 节点的值是否相等**，**如果相等再判断左右子树是否对称**。

   ![](https://notebook.ricear.com/media/202108/2021-08-05_223219.png)

#### 2.2.2 参考代码

##### 2.2.2.1 递归

```java
/**
 * 101. 对称二叉树（版本 1：递归）
 *
 * @param root 根节点
 * @return 二叉树是否镜像对称
 */
public boolean isSymmetricV1(TreeNode root) {
    if (root == null) {return true;}
    return dfs(root.left, root.right);
}

/**
 * 递归判断二叉树是否镜像对称
 *
 * @param left  左子树
 * @param right 右子树
 * @return 二叉树是否镜像对称
 */
public boolean dfs(TreeNode left, TreeNode right) {
    if (left == null && right == null) {return true;}
    if (left == null || right == null) {return false;}
    return left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left);
}
```

##### 2.2.2.2 迭代

```java
/**
 * 101. 对称二叉树（版本 2：迭代）
 *
 * @param root 根节点
 * @return 二叉树是否镜像对称
 */
public boolean isSymmetricV2(TreeNode root) {
    if (root == null) {return true;}

    //  使用一个队列模拟同时存在两棵相同的二叉树，然后判断这两棵二叉树是否镜像对称
    Queue<TreeNode> queue = new LinkedList<>();

    queue.offer(root);
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode left = queue.poll();
        TreeNode right = queue.poll();

        if (left == null && right == null) {continue;}
        if (left == null || right == null) {return false;}
        if (left.val != right.val) {return false;}

        queue.offer(left.left);
        queue.offer(right.right);

        queue.offer(left.right);
        queue.offer(right.left);
    }

    return true;
}
```

### 2.3 验证二叉搜索树

> 题目内容详见[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree)。

#### 2.3.1 问题分析

1. 对于二叉树的题目，我们一般可以考虑一下看是否能**利用二叉树的三种深度优先遍历和一种广度优先遍历方法来解决**。
2. 在该题目中，我们可以利用**中序遍历**，只要判断**每一个遍历的节点的值是否都大于前一个节点**，进而就可以判断该二叉树是否为二叉搜索树。

#### 2.3.2 参考代码

##### 2.3.2.1 递归

```java
long pre = Long.MIN_VALUE;

/**
 * 98. 验证二叉搜索树（版本 1：递归（中序遍历））
 * @param root  根节点
 * @return  是否为有效的二叉搜索树
 */
public boolean isValidBSTV1(TreeNode root) {
    if (root == null) {return true;}

    if (!isValidBSTV1(root.left)) {return false;} /*访问左子树：判断左子树是否为二叉搜索树*/
    if (root.val <= pre) {return false;}    /*访问根节点：判断根节点的值是否大于等于中序遍历的前一个节点的值*/
    pre = root.val; /*将当前节点保存为前一个节点*/
    return isValidBSTV1(root.right);  /*访问右子树：判断右子树是否为二叉搜索树*/
}
```

##### 2.3.2.2 迭代

```java
long pre = Long.MIN_VALUE;

/**
 * 98. 验证二叉搜索树（版本 2：迭代（中序遍历））
 * @param root  根节点
 * @return  是否为有效的二叉搜索树
 */
public boolean isValidBSTV2(TreeNode root) {
    if (root == null) {return true;}

    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;

    while (!stack.empty() || cur != null) {
        while(cur != null) {    /*尽可能将这个节点的左子树入栈，相当于访问左子树*/
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();    /*相当于访问根节点，然后判断根节点的值是否大于等于中序遍历的前一个节点的值*/
        if (node.val <= pre) {return false;}
        pre = node.val;
        if (node.right != null) {cur = node.right;} /*相当于访问右子树*/
    }

    return true;
}
```

### 2.4 二叉树的完全性检验

> 题目内容详见[958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree)。

#### 2.4.1 问题分析

1. 对于二叉树的题目，我们一般可以考虑一下看是否能**利用二叉树的三种深度优先遍历和一种广度优先遍历方法来解决**。
2. 该题目可以通过[层序遍历]()来解决，判断的依据就是，**如果一层中出现了一个为空的节点**，**并且后面还有节点，那么该二叉树就不是一个完全二叉树**，**如果后面没有节点**，**那么该二叉树就是一个完全二叉树**，因此，相比于层序遍历来说，该方法在**将当前节点的左节点和右节点添加到队列时不需要判断当前节点的左节点和右节点是否为空**。

#### 2.4.2 参考代码

```java
//  判断是否到达了二叉树末尾，只要层序遍历时遇到一个空节点，就认为到达了二叉树末尾
boolean reachEnd = false;

/**
 * 958. 二叉树的完全性检验（层序遍历）
 * @param root  根节点
 * @return  当前二叉树是否为完全二叉树
 */
public boolean isCompleteTree(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();

    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        //  如果到达了二叉树末尾，但后面还有非空节点，则该二叉树不是完全二叉树
        if (reachEnd && node != null) {
            return false;
        }
        //  只要层序遍历时遇到一个空节点，就认为到达了二叉树末尾，令 reachEnd 为 true，然后进行下一个节点的遍历
        if (node == null) {
            reachEnd = true;
            continue;
        }
        queue.add(node.left);
        queue.add(node.right);
    }

    return true;
}
```

### 2.5 二叉搜索树的第 k 大节点

> 题目内容详见[剑指 Offer 54. 二叉搜索树的第 k 大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof)。

#### 2.5.1 问题分析

1. 该题目解法基于**二叉树中序遍历为递增序列**这一性质，可以得到**二叉树中序遍历倒序为递减序列**。
2. 因此，**求二叉树第 $k$ 大的节点可以转化为求二叉树的中序遍历倒序的第 $k$ 个节点**。

#### 2.5.2 参考代码

```java
/**
 * 剑指 Offer 54. 二叉搜索树的第 k 大节点（中序遍历倒序）
 * @param root  根节点
 * @param k 最值序号
 * @return  二叉搜索树的第 k 大节点
 */
public int kthLargest(TreeNode root, int k) {
    //  base case
    if (root == null) {
        return -1;
    }
    TreeNode cur = root;
    //  用来模仿递归解法中的栈
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.empty() || cur != null) {
        //  尽可能将这个节点的右子树入栈，相当于访问右子树
        while (cur != null) {
            stack.push(cur);
            cur = cur.right;
        }
        //  相当于访问根节点
        TreeNode node = stack.pop();
        if (--k == 0) {return node.val;}
        //  相当于访问左节点
        if (node.left != null) {
            cur = node.left;
        }
    }

    return -1;
}
```

### 2.6 括号生成

> 题目内容详见[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses)。

#### 2.6.1 问题分析

1. 这一类问题是**在一棵隐式的树上求解**，**一般用**[深度优先遍历](https://notebook.ricear.com/project-21/doc-724/#1-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95)**来解决**。
2. 我们以 $n = 2$ 为例，画树形结构图，方法是**做减法**。![](https://notebook.ricear.com/media/202111/2021-11-13_2156250.32776863153577696.png)
   通过上图，我们可以得出如下结论：
   1. **当前左右括号的剩余个数都大于 0 时**，**才会产生分支**。
   2. **产生左分支的时候**，**只看当前是否还有左括号可以使用**。
   3. **产生右分支的时候**，**还受到左分支的限制**，**只有右括号的剩余个数严格大于左括号时**，**才可以产生分支**。
   4. **在左括号和右括号的剩余个数都等于 0 的时候结算**。

#### 2.6.2 参考代码

```java
/**
 * 22. 括号生成
 *
 * @param n 生成括号的对数
 * @return 能够生成所有可能的并且 有效的 括号组合
 */
public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    if (n == 0) {return res;}
    dfs("", n, n, res);
    return res;
}

/**
 * 采用深度优先遍历求能够生成指定括号对数的所有可能且有效的括号组合
 *
 * @param curStr 当前字符串
 * @param left   左括号剩余个数
 * @param right  右括号剩余个数
 * @param res    生成的括号组合
 */
public void dfs(String curStr, int left, int right, List<String> res) {
    //  当左边和右边剩余的括号数都等于 0 的时候结算
    if (left == 0 && right == 0) {
        res.add(curStr);
        return;
    }

    //  如果左括号剩余个数严格大于右括号剩余个数，则进行剪枝
    if (left > right) {
        return;
    }

    //  向左遍历
    if (left > 0) {dfs(curStr + "(", left - 1, right, res);}
    //  向右遍历
    if (right > 0) {dfs(curStr + ")", left, right - 1, res);}
}
```

### 2.7 二叉搜索树与双向链表

> 题目内容详见[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof)。

#### 2.7.1 问题分析

1. 本题主要包含三个要素：
   1. **排序链表**：**节点应从小到大排列**，由于**二叉搜索树的中序遍历为递增序列**，因此**可以使用中序遍历来访问树的节点**。
   2. **双向链表**：**在构建相邻接点的引用关系时**，**设前驱结点为 $pre$ 和当前节点 $cur$**，**不仅应构建 $pre.right = cur$**，**也应构建 $cur.left = pre$**。
   3. **循环链表**：**设链表头结点为 $head$ 和尾节点 $tail$**，**则应构建 $head.left = tail$ 和 $tail.right =  head$**。

#### 2.7.2 参考代码

```java
/**
 * 剑指 Offer 36. 二叉搜索树与双向链表
 * @param root  二叉树根节点
 * @return  二叉搜索树转化后得到的排序的循环双向链表
 */
public Node treeToDoublyList(Node root) {
    if (root == null) {return null;}
    dfs(root);
    head.left = pre;
    pre.right = head;
    return head;
}

/**
 * 二叉树中序遍历
 * @param cur   当前节点
 */
public void dfs(Node cur) {
    if (cur == null) {return;}
    dfs(cur.left);
    if (pre != null) {pre.right = cur;}
    else {head = cur;}
    cur.left = pre;
    pre = cur;
    dfs(cur.right);
}
```

### 2.8 二叉树最大宽度

> 题目内容详见[662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree)。

#### 2.8.1 问题分析

1. **对于一棵完全二叉树**，**如果按照从上至下**，**从左往右对所有节点从零开始顺序编号**，**假设父节点的序号为 $i$**，**则**：
   1. **左孩子节点的序号为 $ 2 * i + 1$**，**右孩子节点的序号为 $ 2 * i + 2$**。
   2. **假设每层的宽度为 $width$**，**每层最后一个节点的序号为 $r$**，**每层第一个节点的序号为 $l$**，则

      $$
      width = r - l + 1
      $$

#### 2.8.2 参考代码

```java
/*
 * 自定义树节点
 */
public class CustomTreeNode {
    TreeNode node;
    int position;
    public CustomTreeNode(TreeNode _node, int _position) {
        node = _node;
        position = _position;
    }
}

/*
 * 662. 二叉树最大宽度
 * @param root  二叉树根节点
 * @return  二叉树的最大宽度
 */
public int widthOfBinaryTree(TreeNode root) {
    if (root == null) {return 0;}
    int res = Integer.MIN_VALUE;
    Queue<CustomTreeNode> queue = new LinkedList<>();
    queue.offer(new CustomTreeNode(root, 1));
    while (!queue.isEmpty()) {
        int n = queue.size();
        CustomTreeNode left = new CustomTreeNode(null, 0); //  每一层最左边节点
        CustomTreeNode right = new CustomTreeNode(null, 0); //  每一层最右边节点
        for (int i = 0; i < n; i++) {
            CustomTreeNode node = queue.poll();
            if (i == 0) {left = node;}
            if (i == n - 1) {right = node;}
            if (node.node.left != null) {queue.offer(new CustomTreeNode(node.node.left, 2 * node.position));}
            if (node.node.right != null) {queue.offer(new CustomTreeNode(node.node.right, 2 * node.position + 1));}
        }
        res = Math.max(res, right.position - left.position + 1);
    }
    return res;
}
```

### 2.9 二叉树的序列化与反序列化

> 题目内容详见[297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)。

#### 2.9.1 问题分析

1. 这道题目可以采用[深度优先遍历](https://notebook.ricear.com/project-21/doc-724/#1-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95)的方法来求解：
   1. **序列化**：
      1. **递归遍历一棵树**，**重点关注当前节点**，**他的子树的遍历交给递归来完成**，即 `serialize`**函数**，**你帮我分别序列化我的左右子树**，**我等你返回的结果**，**再拼接一下**。
      2. **选择前序遍历**，**是因为 $ 根 \rightarrow 左 \rightarrow 右 $ 的打印顺序**，**在反序列化时更容易定位出根节点的值**。
      3. **遇到 `null` 节点也要翻译成特定符号**，**反序列化时才知道这里是 `null`**。![image.png](https://notebook.ricear.com/media/202201/2022-01-09_1736130.3886432153851599.png)
   2. **反序列化**：
      1. **反序列化一样**，**也是递归**。
      2. **前序遍历的序列化字符串**，**如下图所示**：![image.png](https://notebook.ricear.com/media/202201/2022-01-09_1738130.8641382032786079.png)
      3. **我们可以定义函数 `buildTree()` 用于还原二叉树**，**传入由序列化字符串转成的数组 $arr$**。
      4. **然后逐个遍历 $arr$ 中的元素**，**构建当前子树的根节点**，**顺着 $arr$**，**构建顺序是根节点**、**左子树**、**右子树**：
         1. **如果当前遍历的字符为 `X`**，**则返回 `null` 节点**。
         2. **如果弹出的字符是数字**，**则创建 `root` 节点**，**并递归构建 `root` 的左右子树**，**最后返回 `root`**。![image.png](https://notebook.ricear.com/media/202201/2022-01-09_1743510.06430358234861278.png)

#### 2.9.2 参考代码

```java
/**
 * 使用层序遍历对二叉树进行序列化
 * @param root  二叉树头结点
 * @return  二叉树序列化后的字符串
 */
public String serialize(TreeNode root) {
    if (root == null) {return "";}
    StringBuffer sb = new StringBuffer();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        if (node != null) {
            queue.offer(node.left);
            queue.offer(node.right);
            sb.append(node.val);
        } else {
            sb.append("X"); //  将空节点序列化为 X
        }
        sb.append(","); //  将不同节点之间添加分隔符
    }
    return sb.toString().substring(0, sb.length() - 1);
}
/**
 * 使用层序遍历对二叉树进行反序列化
 * @param data  二叉树序列化后的字符串
 * @return  反序列化后的二叉树的头结点
 */
public TreeNode deserialize(String data) {
    if (data.equals("")) {return null;}
    String[] split = data.split(",");
    int index = 0;  //  当前节点的位置
    TreeNode root = new TreeNode(Integer.parseInt(split[index]));
    Queue<TreeNode> queue = new LinkedList();
    queue.offer(root);
    while (index < split.length - 2) {
        TreeNode node = queue.poll();
        String leftVal = split[index + 1];  //  左节点
        String rightVal = split[index + 2]; //  右节点
        if (!leftVal.equals("X")) { //  左节点不为空，则反序列化左节点
            TreeNode leftNode = new TreeNode(Integer.parseInt(leftVal));
            node.left = leftNode;
            queue.offer(node.left);
        }
        if (!rightVal.equals("X")) {    //  右节点不为空，则反序列化又节点 
            TreeNode rightNode = new TreeNode(Integer.parseInt(rightVal));
            node.right = rightNode;
            queue.offer(node.right);
        }
        index += 2; //  每次反序列化两个节点
    }
    return root;
}
```

### 2.10 树的子结构

> 题目内容详见[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof)。

#### 2.10.1 问题分析

1. 这道题目可以采用[深度优先遍历](https://notebook.ricear.com/project-21/doc-724/#1-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95)的方法来求解：
   1. 如果**两棵树的顶点相同**，则**分别判断两棵树对应的左子树和右子树是否相同**。
   2. 如果**两棵树的顶点不相同**，则**分别判断 $B$ 是否为 $A$ 的左子树或右子树的子结构**。

#### 2.10.2 参考代码

```java
/**
 * 剑指 Offer 26. 树的子结构
 * @param A 第一个二叉树
 * @param B 第二个二叉树
 * @return  B 是否为 A 的子结构
 */
public boolean isSubStructure(TreeNode A, TreeNode B) {
    return (A != null && B != null) && (dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
}

/**
 * 判断在顶点相同的情况下 B 是否为 A 的子结构
 * @param A 第一个二叉树
 * @param B 第二个二叉树
 * @return  在顶点相同的情况下 B 是否为 A 的子结构
 */
public boolean dfs(TreeNode A, TreeNode B) {
    if (B == null) {return true;}
    if (A == null || A.val != B.val) {return false;}
    return dfs(A.left, B.left) && dfs(A.right, B.right);
}
```

### 2.11 平衡二叉树

> 题目内容详见[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)。

#### 2.11.1 问题分析

> 注：下面所说的高度指**距离子树底部的高度**。

1. 自底向上判断二叉树是否为平衡二叉树的基本思路为：
   1. 按照类似于**后序遍历**的方法判断**当前节点是否为平衡二叉树**，判断标准为：
      1. 当前节点的**左右子树均为平衡二叉树**。
      2. 当前节点的**左右子树高度差小于 2**。
   2. 如果当前节点**不是平衡二叉树**，则直接**返回-1**。
   3. 如果当前节点**是平衡二叉树**，则**当前节点的高度为左右子树高度的最大值加1**。
2. 算法的演示动画可参考[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution)。
3. 该算法**不存在自顶向下算法中的重复遍历问题**。

#### 2.11.2 参考代码

```java
/**
 * 110. 平衡二叉树（后序遍历）
 * @param root  根节点
 * @return  二叉树是否为平衡二叉树
 */
public boolean isBalanced(TreeNode root) {
    if (root == null) {return true;}
    return heightV2(root) != -1;
}

/**
 * 计算一个二叉树的高度
 * @param root  根节点
 * @return  二叉树的高度
 */
public int height(TreeNode root) {
    //  base case
    if (root == null) {return 0;}
    //  左子树高度
    int leftHeight = height(root.left);
    //  右子树高度
    int rightHeight = height(root.right);
    //  如果左子树不是平衡二叉树或者右子树不是平衡二叉树或者左右子树的高度差大于等于 2，则当前子树不是平衡二叉树
    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) >= 2) {
        return -1;
    }
    //  如果当前子树是平衡二叉树，则返回当前子树的高度
    return Math.max(leftHeight, rightHeight) + 1;
}
```

### 2.12 二叉树的最近公共祖先

> 题目内容详见[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)。

#### 2.12.1 问题分析

1. 首先创建相关变量：
   1. $stack$：存储根节点到遍历节点的遍历路径。
   2. $res$、$res2$：分别存储 $p$、$q$ 的遍历节点信息。
2. 然后对二叉树进行前序遍历：
   1. 将 $root$ 入栈。
   2. 如果 $root=p$：
      1. 将栈中的信息存入 $res$。
      2. 将 $res$ 中的信息存入 $stack$，用于后面的遍历。
   3. 如果 $root=q$：
      1. 将栈中的信息存入 $res2$。
      2. 将 $res2$ 中的信息存入 $stack$，用于后面的遍历。
   4. 递归遍历左子树。
   5. 递归遍历右子树。
   6. 如果栈的大小大于 0，则将栈中的元素弹出。
3. 获取 $res$ 和 $res2$ 长度的最小值 $size$。
4. 然后对 $size$ 从 $i=0$ 开始遍历：
   1. 如果 $res$ 的长度大于 $res2$：
      1. 如果 $res2$ 中第 $i$ 个元素等于 $res$ 中第 $res.size()-size+i$ 个元素，则返回 $res2$ 的第 $i$ 个元素。
   2. 如果 $res2$ 的长度大于 $res$：
      1. 如果 $res$ 中第 $i$ 个元素等于 $res2$ 中第 $res2.size()-size+i$ 个元素，则返回 $res$ 的第 $i$ 个元素。
5. 如果上面的条件都不成立，则最后返回 $null$。

![](https://notebook.ricear.com/media/202106/236-二叉树的最近公共祖先（解法一：前序遍历）_1624369019.gif)

#### 2.12.2 参考代码

```java
Stack<TreeNode> stack = new Stack<>();

/**
 * 236. 二叉树的最近公共祖先
 * @param root  二叉树根节点
 * @param o1    待查询的第一个节点的值
 * @param o2    待查询的第二个节点的值
 * @return  两个待查询的节点的最近公共祖先的值
 */
public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
    ArrayList<TreeNode> list1 = new ArrayList<>();
    ArrayList<TreeNode> list2 = new ArrayList<>();
    dfs(root, o1, o2, list1, list2);
    /**
     * 将两个 List 的元素的顺序调整为第一个元素为头结点的值，便于后面的比较
     */
    if (list1.get(0) != root) {
        for (int i = 0; i < list1.size() / 2; i++) {
        TreeNode temp = list1.get(i);
        list1.set(i, list1.get(list1.size() - 1 - i));
        list1.set(list1.size() - 1 - i, temp);
    }
    } if (list2.get(0) != root) {
        for (int i = 0; i < list2.size() / 2; i++) {
        TreeNode temp = list2.get(i);
        list2.set(i, list2.get(list2.size() - 1 - i));
        list2.set(list2.size() - 1 - i, temp);
    }
    }
    /**
     * 将两个 List 对齐后返回第一个相等的元素，即为两个节点的最近公共祖先
     */
    int minSize = Math.min(list1.size(), list2.size());
    for (int i = minSize - 1; i >= 0; i--) {
        if (list1.get(i).val == list2.get(i).val) {return list1.get(i).val;}
    }
    return 0;
}

/**
 * 递归获取二叉树两个指定节点的路径（前序遍历）
 * @param root  二叉树头结点
 * @param num1  待查询的第一个节点的值
 * @param num2  待查询的第二个节点的值
 * @param list1 存储二叉树中头结点到 num1 的路径
 * @param list2 存储二叉树中头结点到 num2 的路径
 */
public void dfs (TreeNode root, int num1, int num2, ArrayList<TreeNode> list1, ArrayList<TreeNode> list2) {
    if (root == null) {return;}
    stack.push(root);
    /**
     * 如果当前节点的值等于 num1 或 num2，则更新相应节点的路径，同时恢复栈原来的状态
     */
    if (root.val == num1) {
        while (!stack.empty()) {
            list1.add(stack.pop());
        }
        for (int i = list1.size() - 1; i >= 0; i--) {
            stack.push(list1.get(i));
        }
    } else if (root.val == num2) {
        while (!stack.empty()) {
            list2.add(stack.pop());
        }
        for (int i = list2.size() - 1; i >= 0; i--) {
            stack.push(list2.get(i));
        }
    }
    dfs(root.left, num1, num2, list1, list2);   //  遍历左子树
    dfs(root.right, num1, num2, list1, list2);  //  遍历右子树
    if (stack.size() > 0) {stack.pop();}    //  如果栈中元素的个数大于 0，则弹出栈中的元素
}
```

## 参考文献

1. [图解 二叉树的四种遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m)。
2. [BFS 的使用场景总结：层序遍历、最短路径问题](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l)。
3. [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)。
4. [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree)。
5. [动画演示 两种实现 226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua)。
6. [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)。
7. [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution)。
8. [958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree)。
9. [层序遍历](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/solution/ceng-xu-bian-li-by-dian-dao-de-hu-die-681d)。
10. [剑指 Offer 54. 二叉搜索树的第 k 大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof)。
11. [面试题 54. 二叉搜索树的第 k 大节点（中序遍历 + 提前返回，清晰图解）](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d)。
12. [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses)。
13. [回溯算法（深度优先遍历）+ 广度优先遍历（Java）](https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419)。
14. [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof)。
15. [剑指 Offer 36. 二叉搜索树与双向链表（中序遍历，清晰图解）](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5)。
16. [二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode)。
17. [BFS+ 完全二叉树性质（看完不会来揍我）](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/bfswan-quan-er-cha-shu-xing-zhi-kan-wan-qmguc)。
18. [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)。
19. [『手画图解』剖析 DFS、BFS 解法 | 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f)。
20. [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof)。
21. [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)。
22. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution)。
23. [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)。
24. [236. 二叉树的最近公共祖先（后序遍历 DFS ，清晰图解）](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu)。
25. [【C++ 经典递归】思路非常好理解 时间复杂度 O(n), 空间复杂度 O(n)](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-jing-dian-di-gui-si-lu-fei-chang-hao-li-jie-shi-)。



<h1 style='page-break-before: always;'>1.4.1 岛屿问题</h1>

## 1 前言

1. 我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的，而我们今天要讨论的 DFS 问题，是在一种【网格】结构中进行的，**岛屿问题是这类网格 DFS 问题的典型代表**。
2. 网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。
3. 本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。

## 2 网格问题的基本概念

1. 我们首先要明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。
2. 网格问题是由 $m \times n$ 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。
3. 岛屿问题是一类典型的网格问题，每个格子中的数字可能是 0 或者 1，我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。

![岛屿问题示例](/media/202107/2021-07-03_211007.png)

4. 在这样一个设定下，就出现了各种岛屿问题的变种，包括**岛屿的数量**、**面积**、**周长**等，不过这些问题，基本都可以用 DFS 遍历来解决。

## 3 网格 DFS 的基本结构

### 3.1 基本结构

1. 网格结构要比二叉树结构稍微复杂一些，他其实是一种**简化版的图结构**，要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历，我们写的[二叉树 DFS 遍历](https://notebook.ricear.com/project-21/doc-724/#1-1-1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86)一般是这样的：

   ```java
   void traverse(TreeNode root) {
       // 判断 base case
       if (root == null) {
           return;
       }
       // 访问两个相邻结点：左子结点、右子结点
       traverse(root.left);
       traverse(root.right);
   }
   ```
2. 可以看到，二叉树的 DFS 遍历有两个要素，分别为**判断 base case**和**访问相邻接点**：

   1. 第一个要素是**判断 base case：**
      1. 一般来说，二叉树遍历的 `base case` 是 `root == null`，这样一个条件判断其实有两个含义：
         1. 一方面，这表示 `root`**指向的子树为空**，**不需要再往下遍历了**。
         2. 另一方面，**在 `root == null` 的时候及时返回**，**可以让后面的 `root.left` 和 `root.right` 操作不会出现空指针异常**。
   2. 第二个要素是**访问相邻接点：**
      1. **二叉树的相邻接点**非常简单，**只有左子树和右子树两个**。
      2. 二叉树本身就是一个**递归定义**的结构：**一棵二叉树**，**他的左子树和右子树也是一棵二叉树**，那么我们的 DFS 遍历只需要**递归调用左子树和右子树即可**。
3. 对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：

   1. 首先，**网格 DFS 中的** `base case` 从二叉树的 `base case` 对应过来，应该**是网格中不需要继续遍历**、$grid[r][c]$**会出现数组下标越界异常的格子**，也就是那些**超出网格范围的格子**：![网格 DFS 的 base case](/media/202107/2021-07-03_213404.png)
   2. 其次，网格结构中的格子**有上下左右四个相邻的节点**，对于格子 $(r,c)$ 来说（$r$ 和 $c$ 分别代表行坐标和列坐标），四个相邻的格子分别是：

      1. **上：$(r+1,c)$。**
      2. **下：**$(r-1,c)$。
      3. **左：$(r,c-1)$。**
      4. **右：$(r,c+1)$。**

      ![网格结构中四个相邻的格子](/media/202107/2021-07-03_213829.png)
4. 这样，我们得到了网格 DFS 遍历的框架代码：

   ```java
   /**
    * 判断是否在方格范围内
    * @param grid  方格数组
    * @param r 横坐标
    * @param c 纵坐标
    * @return  (r, c) 是否在方格范围内
    */
   public boolean inArea(int[][] grid, int r, int c) {
       return r >= 0 && r < grid.length
               && c >= 0 && c < grid[0].length;
   }

   /**
    * 方格 DFS 遍历算法（版本 1：未加重复遍历的判断）
    * @param grid  方格数组
    * @param r 横坐标
    * @param c 纵坐标
    */
   public void dfsV1(int[][] grid, int r, int c) {
       //  base case
       //  如果坐标 (r, c) 超出了网格范围，直接返回
       if (!inArea(grid, r, c)) {
           return;
       }

       //  访问上、下、左、右四个相邻接点
       dfsV1(grid, r + 1, c);
       dfsV1(grid, r - 1, c);
       dfsV1(grid, r, c - 1);
       dfsV1(grid, r, c + 1);
   }
   ```

### 3.2 完善后的结构（避免重复遍历）

1. 网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于**遍历中可能遇到遍历过的节点**，这是因为**网格结构本质上是一个图**，**我们可以把每个格子看成图中的节点**，**每个节点有上下左右的四条边**，**在图中遍历时**，**自然可能遇到重复遍历节点**，这时候，DFS 可能会不停地兜圈子，永远停不下来，如下图所示：![DFS 遍历可能会兜圈子（动图）](/media/202107/2021-07-04_190815.png)
2. 我们可以通过**标记已经遍历过的格子**来避免重复遍历问题，以岛屿问题为例：

   1. 我们需要在所有值为 1 的陆地格子上做 DFS 遍历。
   2. 每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。
   3. 也就是说，每个格子可能取三个值：
      1. **0**：**海洋格子**。
      2. **1**：**陆地格子（未遍历过）**。
      3. **2**：**陆地格子（已遍历过）**。
3. 我们在框架中加入避免重复遍历的语句，具体如下：

   ```java
   /**
    * 判断是否在方格范围内
    * @param grid  方格数组
    * @param r 横坐标
    * @param c 纵坐标
    * @return  (r, c) 是否在方格范围内
    */
   public boolean inArea(int[][] grid, int r, int c) {
       return r >= 0 && r < grid.length
               && c >= 0 && c < grid[0].length;
   }

   /**
    * 方格 DFS 遍历算法（版本 2：加入重复遍历的判断）
    * @param grid  方格数组
    * @param r 横坐标
    * @param c 纵坐标
    */
   public void dfsV2(int[][] grid, int r, int c) {
       //  base case
       //  如果坐标 (r, c) 超出了网格范围，直接返回
       if (!inArea(grid, r, c)) {
           return;
       }

       //  如果这个格子不是 未遍历过的陆地，则直接返回
       if (grid[r][c] != 1) {
           return;
       }
       //  将当前陆地标记为 已遍历过
       grid[r][c] = 2;

       //  访问上、下、左、右四个相邻接点
       dfsV2(grid, r + 1, c);
       dfsV2(grid, r - 1, c);
       dfsV2(grid, r, c - 1);
       dfsV2(grid, r, c + 1);
   }
   ```
4. 加入重复遍历的判断之后的示意图如下所示：

   ![标记已遍历的格子](/media/202107/2021-07-04_192439.png)
5. 这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法，以下所讲的几个例题，其实都只需要在 DFS 遍历框架上稍加修改而已。

## 4 相关题目

### 4.1 岛屿数量

#### 4.1.1 题目

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```txt
输入：grid = [
["1","1","1","1","0"],
["1","1","0","1","0"],
["1","1","0","0","0"],
["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```txt
输入：grid = [
["1","1","0","0","0"],
["1","1","0","0","0"],
["0","0","1","0","0"],
["0","0","0","1","1"]
]
输出：3
```

**提示：**

* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 300
* grid[i][j] 的值为 '0' 或 '1'

#### 4.1.2 问题分析

1. 这个直接根据模板进行修改一下即可，同时需要注意的是：
   1. **只要当遍历到的点是陆地的话才会开始执行 `dfs()` 函数**，因此**每当遍历一个陆地的点**，**岛屿数量看定会加 1**。
   2. **在 `dfs()` 函数中**，**会将已经遍历过的陆地标记为已遍历**，因此**下一次遍历到这块已遍历过的陆地时**，**会直接返回**。

#### 4.1.3 参考代码

```java
/**
 * 200. 岛屿数量
 * @param grid  网格
 * @return  网格中岛屿的数量
 */
public int numIslands(char[][] grid) {
    int res = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;  /*将当前岛屿数量加 1*/
            }
        }
    }
    return res;
}

/**
 * 判断点 (r, c) 是否在网格范围内
 * @param grid  网格
 * @param r 横坐标
 * @param c 纵坐标
 * @return  (r, c) 是否在网格范围内
 */
public boolean inArea(char[][] grid, int r, int c) {
    return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;
}

/**
 * 网格深度优先遍历
 * @param grid  网格
 * @param r 横坐标
 * @param c 纵坐标
 */
public void dfs(char[][] grid, int r, int c) {
    if (!inArea(grid, r, c)) {return;}

    if (grid[r][c] != '1') {return;}

    grid[r][c] = '2';

    dfs(grid, r + 1, c);
    dfs(grid, r - 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
```

### 4.2 岛屿的最大面积

#### 4.2.1 题目

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

**示例 1:**

```txt
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

**示例 2:**

```txt
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 0。

**注意:** 给定的矩阵 grid 的长度和宽度都不超过 50。

#### 4.2.2 问题分析

1. 这道题目只需**对每个岛屿做 DFS 遍历**，**求出每个岛屿的面积**就可以了。
2. 求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加 1：

   ```java
   /**
    * 采用 DFS 遍历求陆地所在岛屿的面积
    * @param grid  岛屿数组
    * @param r 陆地横坐标
    * @param c 陆地纵坐标
    * @return  陆地所在岛屿的面积
    */
   public int dfs(int[][] grid, int r, int c) {
       //  base case
       //  如果坐标（r, c）超出岛屿范围，直接返回 0
       if (!inArea(grid, r, c)) {
           return 0;
       }

       //  如果当前格子不是 未遍历陆地，则直接返回 0
       if (grid[r][c] != 1) {
           return 0;
       }
       //  将当前陆地标记为 已遍历陆地
       grid[r][c] = 2;

       //  访问上、下、左、右四个相邻接点
       return 1 + dfs(grid, r - 1, c)
               + dfs(grid, r + 1, c)
               + dfs(grid, r, c - 1)
               +dfs(grid, r, c + 1);
   }
   ```

#### 4.2.3 参考代码

```java
/**
 * 判断陆地是否超出岛屿范围
 * @param grid  岛屿数组
 * @param r 陆地横坐标
 * @param c 陆地纵坐标
 * @return  陆地是否超出岛屿范围
 */
public boolean inArea(int[][] grid, int r, int c) {
    return r >= 0 && r < grid.length
            && c >= 0 && c < grid[0].length;
}

/**
 * 采用 DFS 遍历求陆地所在岛屿的面积
 * @param grid  岛屿数组
 * @param r 陆地横坐标
 * @param c 陆地纵坐标
 * @return  陆地所在岛屿的面积
 */
public int dfs(int[][] grid, int r, int c) {
    //  base case
    //  如果坐标（r, c）超出岛屿范围，直接返回 0
    if (!inArea(grid, r, c)) {
        return 0;
    }

    //  如果当前格子不是 未遍历陆地，则直接返回 0
    if (grid[r][c] != 1) {
        return 0;
    }
    //  将当前陆地标记为 已遍历陆地
    grid[r][c] = 2;

    //  访问上、下、左、右四个相邻接点
    return 1 + dfs(grid, r - 1, c)
            + dfs(grid, r + 1, c)
            + dfs(grid, r, c - 1)
            +dfs(grid, r, c + 1);
}

/**
 * 695. 岛屿的最大面积
 * @param grid  岛屿数组
 * @return  岛屿的最大面积
 */
public int maxAreaOfIsland(int[][] grid) {
    int res = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == 1) {
                int a = dfs(grid, i, j);
                res = Math.max(res, a);
            }
        }
    }
    return res;
}
```

#### 4.2.4 扩展题目

##### 4.2.4.1 [最大正方形](https://leetcode-cn.com/problems/maximal-square)

###### 4.2.4.1.1 问题分析

1. 该题目也属于**网格中寻找最值**类型的题目，可以用**DFS**来实现，也可以用**动态规划**来实现，本文选择的是动态规划的方式来实现。
2. 该题目中 $dp$ 数组的含义为 $dp[i][j]$**表示以点 $matrix[i][j]$ 为起点的只包含 `'1'` 的最大正方形的面积**，且：

   $$
   dp\lbrack i\rbrack\lbrack j\rbrack=\left\{\begin{array}{lc}0&matrix\lbrack i\rbrack\lbrack j\rbrack='0'\\min(dp\lbrack i\rbrack\lbrack j\;+\;1\rbrack,\;dp\lbrack i\;+\;1\rbrack\lbrack j\;+\;1\rbrack,\;dp\lbrack i\;+\;1\rbrack\lbrack j\rbrack)&matrix\lbrack i\rbrack\lbrack j\rbrack='1'\end{array}\right.
   $$

###### 4.2.4.1.2 参考代码

```java
/**
 * 221. 最大正方形
 *
 * @param matrix 二维矩阵
 * @return 二维矩阵中只包含 '1' 的最大正方形的面积
 */
public int maximalSquare(char[][] matrix) {
    int m = matrix.length;
    int n = (m >= 1 ? matrix[0].length : 0);
    //  dp 数组，其中 dp[i][j] 表示以 matrix[i][j] 为起点的只包含 '1' 的最大正方形的面积
    int[][] dp = new int[m + 1][n + 1];
    int res = 0;

    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            //  base case
            //  对矩阵右下角的元素进行初始化
            if (matrix[i][j] == '0') {
                dp[i][j] = 0;
            } else if (
                    (i == m - 1 && j == n - 1) ||
                    (i == m - 2 && j == n - 1) ||
                    (i == m - 1 && j == n - 2)
            ) {dp[i][j] = 1;}
            else {

                //  分别以当前点 matrix[i][j] 的左边（matrix[i][j + 1]）、对角线（matrix[i + 1][j + 1]）、下边（matrix[i + 1][j]）为起点的只包含 '1' 的最大正方形的面积的的最小值
                int min = Math.min(
                        Math.min(dp[i][j + 1], dp[i + 1][j + 1]),
                        dp[i + 1][j]
                );
                //  dp[i][j] 等于上面求得的最大面积的最小值对应边长加 1 后对应的正方形的面积
                dp[i][j] = (int) Math.pow(Math.sqrt(min) + 1, 2);
            }

            //  res 等于 dp[i][j] 中的最大值
            res = Math.max(res, dp[i][j]);
        }
    }

    //  返回最后结果
    return res;
}
```

### 4.3 填海造陆问题

#### 4.3.1 题目

给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

** 示例 1:**

```txt
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格 0 变成 1，最终连通两个小岛得到面积为 3 的岛屿。
```

**示例 2:**

```txt
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格 0 变成 1，岛屿的面积扩大为 4。
```

**示例 3:**

```txt
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有 0 可以让我们变成 1，面积依然为 4。
```

**提示：**

* n == grid.length
* n == grid[i].length
* 1 <= n <= 500
* grid[i][j] 为 0 或 1

#### 4.3.2 问题分析

1. 这道题是[岛屿最大面积问题](#4-1-岛屿的最大面积)的升级版，现在我们有填海造陆的能力，可以**把一个海洋格子变成陆地格子**，进而**让两块岛屿连成一块**，然后求出**填海造陆之后最大可能构成的岛屿的最大面积**。
2. 我们可以**先计算出所有岛屿的面积**，**然后在所有的格子上标记出岛屿的最大面积**，**最后搜索出哪个海洋格子相邻的两个岛屿面积最大**。
3. 例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出他变成陆地之后可以连接成的岛屿面积为 7 + 1 + 2 = 10。![一个海洋格子连接起两个岛屿](/media/202107/2021-07-04_201432.png)
4. 然而，这种做法可能遇到一个问题，如下图中红色方框内的海洋格子，他的上边、左边都与岛屿相邻，这时候连接成的岛屿面积并不是 7 + 1 + 7，因为**这两个 7 来自同一个岛屿**，所以填海造陆之后得到的岛屿面积应该只有 7 + 1 = 8。![一个海洋格子与同一个岛屿有两个边相邻](/media/202107/2021-07-04_201718.png)
5. 可以看到，要让算法正确，我们需要**区分一个海洋格子相邻的 7 是不是来自同一个岛屿**，那么我们可以**不在方格中标记岛屿的面积**，**而应该标记岛屿的索引**（下标），另外**用一个数组记录每个岛屿的面积**，如下图所示，这样我们就可以发现**红色方框内的海洋格子的两个相邻岛屿实际上是一个**。![标记每个岛屿的索引（下标）](/media/202107/2021-07-04_202139.png)
6. 可以看到，这道题实际上**对网络做了两遍 DFS**：
   1. **第一遍 DFS 遍历陆地格子**，**计算每个岛屿的面积并标记岛屿**。
   2. **第二遍 DFS 遍历海洋格子**，**观察每个海洋格子相邻的陆地格子**。
7. 这道题的基本思路就是这样，具体的代码还有一些需要注意的细节，但和本文的主题已经联系不大，这个会在后面有时间的时候在完善具体的代码实现。

### 4.4 岛屿的周长

#### 4.4.1 题目

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

**示例 1：**

![](../../media/202108/2021-08-15_1935140.4830911464461979.png)

```txt
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
```

**示例 2：**

```txt
输入：grid = [[1]]
输出：4
```

**示例 3：**

```txt
输入：grid = [[1,0]]
输出：4
```

**提示：**

* row == grid.length
* col == grid[i].length
* 1 <= row, col <= 100
* grid[i][j] 为 0 或 1

#### 4.4.2 问题分析

1. 实际上，**岛屿的周长是计算岛屿全部的边缘**，而**这些边缘就是我们在 DFS 遍历中 `dfs` 函数返回的位置**。
2. 我们可以将岛屿的周长分为两类：

   1. **与网格边界相邻的周长：**`dfs` 函数因为**坐标 $(r,c)$ 超出网格范围而返回的时候就经过了一条相应的边**。
   2. **与海洋格子相邻的周长：**`dfs` 函数因为**当前格子是海洋格子而返回的时候就经过了一条相应的边**。![将岛屿周长中的边分为两类](/media/202108/2021-08-15_1936420.45840867566908317.png)
3. 这样，我们就**把岛屿周长和 DFS 遍历联系起来了**，具体的代码如下：

   ```java
   /**
    * 采用 DFS 遍历求陆地所在岛屿的周长
    * @param grid  岛屿数组
    * @param r 陆地横坐标
    * @param c 陆地纵坐标
    * @return  陆地所在岛屿的面积
    */
   public int dfs(int[][] grid, int r, int c) {
       //  base case
       //  坐标（r, c）超出岛屿范围，对应一条 与网格边界相邻的边
       if (!inArea(grid, r, c)) {
           return 1;
       }

       //  当前格子是 海洋格子，对应一条 与海洋格子相邻的边
       if (grid[r][c] == 0) {
           return 1;
       }

       //  当前格子是 已遍历陆地，与 周长 无关
       if (grid[r][c] != 1) {
           return 0;
       }
       //  将当前陆地标记为 已遍历陆地
       grid[r][c] = 2;

       //  访问上、下、左、右四个相邻接点
       return dfs(grid, r - 1, c)
               + dfs(grid, r + 1, c)
               + dfs(grid, r, c - 1)
               +dfs(grid, r, c + 1);
   }
   ```

#### 4.4.3 参考代码

```java
/**
 * 判断陆地是否超出岛屿范围
 * @param grid  岛屿数组
 * @param r 陆地横坐标
 * @param c 陆地纵坐标
 * @return  陆地是否超出岛屿范围
 */
public boolean inArea(int[][] grid, int r, int c) {
    return r >= 0 && r < grid.length
            && c >= 0 && c < grid[0].length;
}

/**
 * 采用 DFS 遍历求陆地所在岛屿的周长
 * @param grid  岛屿数组
 * @param r 陆地横坐标
 * @param c 陆地纵坐标
 * @return  陆地所在岛屿的面积
 */
public int dfs(int[][] grid, int r, int c) {
    //  base case
    //  坐标（r, c）超出岛屿范围，对应一条 与网格边界相邻的边
    if (!inArea(grid, r, c)) {
        return 1;
    }

    //  当前格子是 海洋格子，对应一条 与海洋格子相邻的边
    if (grid[r][c] == 0) {
        return 1;
    }

    //  当前格子是 已遍历陆地，与 周长 无关
    if (grid[r][c] != 1) {
        return 0;
    }
    //  将当前陆地标记为 已遍历陆地
    grid[r][c] = 2;

    //  访问上、下、左、右四个相邻接点
    return dfs(grid, r - 1, c)
            + dfs(grid, r + 1, c)
            + dfs(grid, r, c - 1)
            +dfs(grid, r, c + 1);
}

/**
 * 463. 岛屿的周长
 * @param grid  岛屿
 * @return  岛屿的周长
 */
public int islandPerimeter(int[][] grid) {
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            if (grid[i][j] == 1) {
                //  题目限制只有一个岛屿，计算一个即可
                return dfs(grid, i, j);
            }
        }
    }
    return -1;
}
```

### 4.5 [单词搜索](https://leetcode-cn.com/problems/word-search)

#### 4.5.1 题目

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![](../../media/202108/2021-08-28_1951260.6416354552062601.png)

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![](../../media/202108/2021-08-28_1951340.03564141591250025.png)

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![](../../media/202108/2021-08-28_1951460.9733885442865199.png)

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

**提示：**

* m == board.length
* n = board[i].length
* 1 <= m, n <= 6
* 1 <= word.length <= 15
* board 和 word 仅由大小写英文字母组成

**进阶：** 你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？

#### 4.5.2 问题分析

1. 该题目为**网格搜索**类题目，可以利用**网格 DFS**的框架来解决。
2. 需要注意的是，该题目在遍历的时候**涉及到回退的操作**，因此**需要建立一个数组**，用来**标记当前节点是否使用过**，**如果使用过则直接跳过**，但是最后**如果当前遍历得到的字符串和原来的字符串不相等**，**需要进行回退**，**把刚才标记为使用过的节点标记为未使用**，**相当于原来的节点没有使用**。

#### 4.5.3 参考代码

```java
//  最后结果
boolean res = false;

/**
 * 79. 单词搜索
 * @param board 二维字符网格
 * @param word  字符串单词
 * @return  字符串单词是否存在于二维字符网络中
 */
public boolean exist(char[][] board, String word) {
    int index = 0;

    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[i].length; j++) {
            int[][] used = new int[board.length][board[i].length];
            dfs(board, word, i, j, index, used);
            if (res) {return true;}
        }
    }

    return false;
}

/**
 * 深度优先遍历判断字符串单词是否存在于二维字符网络中
 * @param board 二维字符网格
 * @param word  字符串单词
 * @param i 当前遍历的二维字符网络中字符的横坐标
 * @param j 当前遍历的二维字符网络中字符的纵坐标
 * @param index 当前遍历的字符串单词的下标
 * @param used  当前遍历的二维字符网络中字符是否使用过
 */
public void dfs(char[][] board, String word, int i, int j, int index, int[][] used) {
    if (!inArea(board, word, i, j, index, used)) {return;}

    if (index == word.length() - 1 && board[i][j] == word.charAt(index) && used[i][j] != -1) {
        res = true;
        return;
    }

    //  标记当前字符为已经使用过
    used[i][j] = -1;

    if (!res) {dfs(board, word, i, j + 1, index + 1, used);}
    if (!res) {dfs(board, word, i + 1, j, index + 1, used);}
    if (!res) {dfs(board, word, i, j - 1, index + 1, used);}
    if (!res) {dfs(board, word, i - 1, j, index + 1, used);}
    if (!res) {
        //  如果字符串单词不在于二维字符网络中，则撤销原来的标记
        used[i][j] = 0;
    }
}

/**
 * 判断当前遍历的二维字符网络中字符是否在边界内
 * @param board 二维字符网格
 * @param word  字符串单词
 * @param i 当前遍历的二维字符网络中字符的横坐标
 * @param j 当前遍历的二维字符网络中字符的纵坐标
 * @param index 当前遍历的字符串单词的下标
 * @param used  当前遍历的二维字符网络中字符是否使用过
 * @return  判断当前遍历的二维字符网络中字符是否在边界内
 */
public boolean inArea(char[][] board, String word, int i, int j, int index, int[][] used) {
    if ((i < 0 || i >= board.length || j < 0 || j >= board[i].length)) {return false;}
    if (index < 0 || index >= word.length()) {return false;}
    if (used[i][j] == -1) {return false;}
    if (board[i][j] != word.charAt(index)) {return false;}
    return true;
}
```

### 4.6 [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof)

#### 4.6.1 题目

地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

```txt
输入：m = 2, n = 3, k = 1
输出：3
```

**示例 2：**

```txt
输入：m = 3, n = 1, k = 0
输出：1
```

**提示：**

* 1 <= n,m <= 100
* 0 <= k <= 20

#### 4.6.2 问题分析

1. 该题目为**网格搜索**类题目，可以利用**网格 DFS**的框架来解决。

#### 4.6.3 参考代码

```java
/**
 * 计算机器人当前位置的横纵坐标数位之和
 * @param i 横坐标
 * @param j 纵坐标
 * @return  机器人当前位置的横纵坐标数位之和
 */
public int calculate(int i, int j) {
    String tmp = String.valueOf(i) + String.valueOf(j);
    char[] arr = tmp.toCharArray();
    int sum = 0;
    for (char c: arr) {
        sum += c - '0';
    }
    return sum;
}

/**
 * 判断机器人是否在方格内
 * @param grid  方格
 * @param i 横坐标
 * @param j 纵坐标
 * @param k 横坐标和列坐标的最大数位之和
 * @return  机器人是否在方格内
 */
public boolean inArea(int[][] grid, int i, int j, int k) {
    return i >= 0 && i < grid.length && j >= 0 && j < grid[i].length && calculate(i, j) <= k;
}

/**
 * 深度优先遍历计算机器人在当前位置能够到达的最大格子数
 * @param grid  方格
 * @param r 机器人的横坐标
 * @param c 机器人的纵坐标
 * @param k 横坐标和列坐标的最大数位之和
 * @param used  当前位置是否遍历过
 * @return  机器人在当前位置能够到达的最大格子数
 */
public int dfs(int[][] grid, int r, int c, int k, boolean[][] used) {
    if (!inArea(grid, r, c, k)) {return 0;}
    if (used[r][c]) {return 0;}

    //  标记当前位置已经使用过
    used[r][c] = true;

    return 1 + dfs(grid, r - 1, c, k, used) + dfs(grid, r, c + 1, k, used) + dfs(grid, r + 1, c, k, used) + dfs(grid, r, c - 1, k, used);
}

/**
 * 剑指 Offer 13. 机器人的运动范围
 * @param m 行数
 * @param n 列数
 * @param k 横坐标和列坐标的最大数位之和
 * @return  机器人能够到达的最大格子数
 */
public int movingCount(int m, int n, int k) {
    int[][] grid = new int[m][n];
    boolean[][] used = new boolean[m][n];
    int res = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            res = Math.max(res, dfs(grid, i, j, k, used));
        }
    }
    return res;
}
```

## 参考文献

1. [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands)。
2. [岛屿类问题的通用解法、DFS 遍历框架](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-)。
3. [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island)。
4. [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island)。
5. [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter)。
6. [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square)。
7. [79. 单词搜索](https://leetcode-cn.com/problems/word-search)。



<h1 style='page-break-before: always;'>1.4.2 二叉树路径问题</h1>

## 1 问题分类

二叉树路径的问题大致可以分为两类，分别是**自顶向下**和**非自顶向下**。

### 1.1 自顶向下

#### 1.1.1 概述

1. 自顶向下就是**从某一个节点**（不一定是根节点）**出发**，**从上向下寻找路径**，**到某一个节点**（不一定是叶节点）**结束**，继续细分的话，还可以分为**一般路径**和**定和路径**。
2. 这类题**通常用**[**深度优先搜索**](https://notebook.ricear.com/project-21/doc-724/#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95)（DFS）和[**广度优先搜索**](https://notebook.ricear.com/project-21/doc-724/#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95)（BFS）解决，BFS 一般比 DFS 更为繁琐，这里为了简洁只展现 DFS 代码。
3. 这类题型需要注意以下几点：
   1. 如果是**找路径和等于给定 $target$ 的路径**的，那么**可以不用新增一个临时变量来判断当前路径和**，**只需要用给定和 $target$ 减去节点值**，**最终结束条件判断 $target == 0$ 即可**。
   2. **二叉树的问题大部分是不需要回溯的**，因为：
      1. **二叉树的递归部分**（`dfs(root -> left)`、`dfs(root -> right)`）**已经把可能的路径穷尽了**，因此**到任意节点的路径只可能有一条**，绝对**不可能出现另外的路径也到这个满足条件的叶节点的**。
      2. **而对比二维数组**（例如[岛屿问题](https://notebook.ricear.com/project-21/doc-751)）**的 DFS**，`for`**循环向四个方向查找每次只能朝向一个方向**，并**没有穷尽路径**，因此**某一个满足条件的点可能是多条路径到该点的**，并且 `visited`**数组标记已经走过的路径是会受到另外路径是否访问的影响**，这时候**必须回溯**。
   3. **至于找到路径后是否需要 `return`**，这**取决于是否要求找到叶节点满足条件的路径**：
      1. 如果**必须找到叶节点**，那么**就要 `return`**。
      2. 如果是**到任意节点都可以**，那么必**不能 `return`**，因为**这条路径下面还可能有更深的路径满足条件**，**还要在此基础上继续递归**。
   4. **至于是否需要双重递归**（即调用根节点的 `dfs` 函数后，继续调用根左右节点的 `pathsum` 函数），**需要看题目是要求从根节点开始**，**还是从任意节点开始**。

#### 1.1.2 解题模板

##### 1.1.2.1 一般路径

```java
/**
 * 自顶向下（版本 1：一般路径）
 * @param root
 * @param path
 */
public void dfsFromTopToBottomV1(TreeNode root, List<Integer> path) {
    //  根节点为空直接返回
    if (root == null) {return;}

    //  做出选择（将节点的值添加到路径中）
    List<Integer> pathTemp = new ArrayList<>(path);
    pathTemp.add(root.val);

    //  叶节点（左子树和右子树均为空），将路径添加到结果中，然后返回
    if (root.left == null && root.right == null) {
        res.add(path);
        return;
    }

    //  遍历左子树
    dfsFromTopToBottomV1(root.left, pathTemp);
    //  遍历右子树
    dfsFromTopToBottomV1(root.right, pathTemp);
}
```

##### 1.1.2.2 给定和的路径

```java
/**
 * 自顶向下（版本 2：给定和的路径）
 * @param root
 * @param path
 */
public void dfsFromTopToBottomV2(TreeNode root, int sum, List<Integer> path) {
    //  根节点为空直接返回
    if (root == null) {return;}

    //  做出选择（将 sum 值减去当前节点的值，然后将当前节点的值添加到路径中）
    sum -= root.val;
    List<Integer> pathTemp = new ArrayList<>(path);
    pathTemp.add(root.val);

    //  叶节点（左子树和右子树均为空），且满足给定的路径和，将路径添加到结果中，然后返回
    if (root.left == null && root.right == null && sum == 0) {
        res.add(path);
        return;
    }

    //  遍历左子树
    dfsFromTopToBottomV1(root.left, pathTemp);
    //  遍历右子树
    dfsFromTopToBottomV1(root.right, pathTemp);
}
```

### 1.2 非自顶向下

#### 1.2.1 概述

1. 非自顶向下就是**从任意节点到任意节点的路径**，**不需要自顶向下**。
2. 这类题目的一般解题思路如下：
   
   1. **设计一个辅助函数 `maxPath()`**，**调用自身求出以一个节点为根节点的左侧最长路径 $left$ 和右侧最长路径 $right$**，**那么经过该节点的最长路径就是 $left + right$**。
   2. **接着只需要从根节点开始 DFS**，**不断更新比较全局变量即可**。
3. 这类题型 DFS 需要注意的地方：
   
   1. **$left$ 和 $right$ 代表的含义要根据题目所求设置**，比如最长路径、最大路径和等等。
   2. **全局变量 $res$ 的初值是 0 还是 `INT_MIN` 要看题目节点是否存在负值**，**如果存在就用 `INT_MIN`**，**否则就是 0**。

#### 1.2.2 解题模板

```java
Integer resInt = 0;
public int maxPath(TreeNode root) { /*以 root 为路径起始点的最长路径*/
    if (root == null) {return 0;}

    int left = maxPath(root.left);
    int right = maxPath(root.right);
    resInt = Math.max(resInt, left + right + root.val); /*更新全局变量*/
    return Math.max(left, right) + root.val;   /*返回左右路径较长者*/
}
```

## 2 题目分析

### 2.1 自顶向下

#### 2.1.1 一般路径

##### 2.1.1.1 [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths)

###### 2.1.1.1.1 问题分析

1. 该题目属于[自顶向下](#1-1-自顶向下)类型中的[一般路径](#1-1-2-1-一般路径)，直接套用[相应模板](#1-1-2-1-一般路径)即可。
2. 该题目有两点需要注意的地方：
   1. 在 `dfs()` 方法中**新建一个变量存储当前路径的值**，**防止对原来路径的值造成影响**。
   2. **添加前缀时在遍历左子树和右子树前面添加**，**这样可以把前缀的处理变得更为简单**。

###### 2.1.1.1.2 参考代码

```java
//  路径列表
List<String> path = new ArrayList();

/**
 * 257. 二叉树的所有路径
 * @param root  根节点
 * @return  二叉树的所有路径
 */
public List<String> binaryTreePaths(TreeNode root) {
    dfs(root, "");
    return path;
}

/**
 * 深度优先遍历查找当前节点到叶子节点的所有路径
 * @param root  当前节点
 * @param subPath   当前节点到叶子节点的路径
 */
public void dfs(TreeNode root, String subPath) {
    //  base case
    if (root == null) {return;}

    //  新建一个变量存储 subPath 的值，防止对原来 subPath 的值造成影响
    StringBuffer subPathBuffer = new StringBuffer(subPath);
    subPathBuffer.append(root.val);

    if (root.left == null && root.right == null) {
        //  遍历到了叶子节点，将当前节点到叶子节点的路径添加到结果路径列表中
        path.add(subPathBuffer.toString());
        return;
    }

    //  添加前缀
    subPathBuffer.append("->");
    //  遍历左子树
    dfs(root.left, subPathBuffer.toString());
    //  遍历右子树
    dfs(root.right, subPathBuffer.toString());
}
```

##### 2.1.1.2 [从叶结点开始的最小字符串](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf)

###### 2.1.1.2.1 问题分析

1. 该题目属于[自顶向下](#1-1-自顶向下)类型中的[一般路径](#1-1-2-1-一般路径)，直接套用[相应模板](#1-1-2-1-一般路径)即可。

###### 2.1.1.2.2 参考代码

```java
//  最小字符串
String res = "";

/**
 * 988. 从叶结点开始的最小字符串
 * @param root  根节点
 * @return  从叶结点开始的最小字符串
 */
public String smallestFromLeaf(TreeNode root) {
    dfs(root, "");
    return res;
}

/**
 * 深度优先遍历查找从叶结点开始的最小字符串
 * @param root  当前节点
 * @param path  从叶节点到当前节点的最小字符串
 */
public void dfs(TreeNode root, String path) {
    if (root == null) {return;}

    StringBuffer newPath = new StringBuffer(path);
    newPath.append(String.valueOf((char)(root.val - 0 + 'a')));

    if (root.left == null && root.right == null) {
        String pathReverseStr = newPath.reverse().toString();
        if (res == "") {
            res = pathReverseStr;
        } else {
            res = (res.compareTo(pathReverseStr) <= 0 ? res : pathReverseStr);
        }
        return;
    }

    dfs(root.left, newPath.toString());
    dfs(root.right, newPath.toString());
}
```

#### 2.1.2 给定路径和的路径

##### 2.1.2.1 [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

###### 2.1.2.1.1 问题分析

1. 该题目属于[自顶向下](#1-1-自顶向下)类型中的[给定路径和的路径](#1-1-2-2-给定和的路径)，直接套用[相应模板](#1-1-2-2-给定和的路径)即可。

###### 2.1.2.1.2 参考代码

```java
//  路径列表
List<List<Integer>> res = new ArrayList<>();

/**
 * 113. 路径总和 II
 * @param root  根节点
 * @param targetSum 目标路径和
 * @return  所有从根节点到叶子节点路径总和等于给定目标和的路径
 */
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<Integer> path = new ArrayList<>();
    dfs(root, targetSum, path);
    return res;
}

/**
 * 深度优先遍历查找所有从根节点到叶子节点路径总和等于给定目标和的路径
 * @param root
 * @param targetSum
 * @param path
 */
public void dfs(TreeNode root, int targetSum, List<Integer> path) {
    if (root == null) {return;}

    targetSum -= root.val;
    List<Integer> pathTemp = new ArrayList<>(path);
    pathTemp.add(root.val);

    if (root.left == null && root.right == null && targetSum == 0) {
        res.add(pathTemp);
        return;
    }

    dfs(root.left, targetSum, pathTemp);
    dfs(root.right, targetSum, pathTemp);
}
```

##### 2.1.2.2 [路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

###### 2.1.2.2.1 问题分析

1. 该题目属于[自顶向下](#1-1-自顶向下)类型中的[给定路径和的路径](#1-1-2-2-给定和的路径)，可以**采用双重递归来实现**：
   1. **先调用 `dfs()` 函数从 `root` 开始查找路径和等于给定值的路径**。
   2. **然后再调用 `pathSum()` 函数从 `root` 左右子树开始查找**。
2. 需要注意的是：
   1. 在 `dfs()` 函数中**当 $sum = 0$ 时不要直接 $return$**，**因为题目中不要求到叶子节点结束**，**所以一条路径下面可能还有另外一条**。

###### 2.1.2.2.2 参考代码

```java
//  路径数目
    int count = 0;

    /**
     * 437. 路径总和 III
     * @param root  根节点
     * @param targetSum 目标值
     * @return  二叉树里节点值之和等于 targetSum 的 路径 的数目
     */
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {return 0;}

        //  查找以当前节点为起点，路径和等于给定值的路径
        dfs(root, targetSum);

        //  查找当前节点的左子树节点值之和等于 targetSum 的路径的数目
        pathSum(root.left, targetSum);
        //  查找当前节点的右子树节点值之和等于 targetSum 的路径的数目
        pathSum(root.right, targetSum);
        return count;
    }

    /**
     * 深度优先遍历查找所有从根节点到叶子节点路径总和等于给定目标和的路径
     * @param root
     * @param targetSum
     */
    public void dfs(TreeNode root, int targetSum) {
        if (root == null) {return;}

        targetSum -= root.val;

        if (targetSum == 0) {count++;}

        dfs(root.left, targetSum);
        dfs(root.right, targetSum);
    }
```

### 2.2 非自顶向下

#### 2.2.1 [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)

##### 2.2.1.1 问题分析

1. 该题目属于[非自顶向下](#1-2-非自顶向下)类型，直接套用[相应模板](#1-2-2-解题模板)即可。
2. 需要注意的是：
   1. **最大路径和小于 0**，意味着**该路径和对总路径和做负贡献**，因此**不要计入到总路径中**，**将他设置为 0**。

##### 2.2.1.2 参考代码

```java
//  二叉树中的最大路径和
int res = Integer.MIN_VALUE;

/**
 * 124. 二叉树中的最大路径和
 * @param root  根节点
 * @return  二叉树中的最大路径和
 */
public int maxPathSum(TreeNode root) {
    dfs(root);
    return res;
}

/**
 * 当前节点的最大贡献值
 * @param root  当前节点
 * @return  当前节点的最大贡献值
 */
public int dfs(TreeNode root) {
    //  base case
    if (root == null) {return 0;}

    //  计算左右子树的最大贡献值
    //  只有最大贡献值大于 0 时，才会选择对应子节点
    int leftGain = Math.max(dfs(root.left), 0);
    int rightGain = Math.max(dfs(root.right), 0);

    //  当前节点的路径和，当其比已有最大路径和大时更新最大路径和为当前节点的路径和
    //  当前节点的路径和 = 当前节点的值 + 左子树的最大贡献值 + 右子树的最大贡献值
    res = Math.max(res, root.val + leftGain + rightGain);

    //  返回当前节点的最大贡献值
    //  当前节点的最大贡献值 = 当前节点值 + 左右子树中最大的最大贡献值
    return Math.max(leftGain, rightGain) + root.val;
}
```

#### 2.2.2 [最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

##### 2.2.2.1 问题分析

1. 该题目属于[非自顶向下](#1-2-非自顶向下)类型，直接套用[相应模板](#1-2-2-解题模板)即可。
2. 需要注意的是：
   1. **对当前节点的值和其左右子节点的值的对比应该放在递归遍历完左右子树后进行**。

##### 2.2.2.2 参考代码

```java
//  同值路径的最大长度
int res = 0;

/**
 * 687. 最长同值路径
 * @param root  根节点
 * @return  同值路径的最大长度
 */
public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return res;
}

/**
 * 深度优先遍历求同值路径的最大长度
 * @param root  当前节点
 * @return  同值路径的最大长度
 */
public int dfs(TreeNode root) {
    if (root == null) {return 0;}

    int left = dfs(root.left);
    int right = dfs(root.right);

    //  如果存在左子节点，并且当前节点的值和左子节点的值相同，则更新左最长路径，否则，令左最长路径为 0
    if (root.left != null && root.val == root.left.val) {
        left++;
    } else {
        left = 0;
    }
    //  如果存在右子节点，并且当前节点的值和右子节点的值相同，则更新右最长路径，否则，令右最长路径为 0
    if (root.right != null && root.val == root.right.val) {
        right++;
    } else {
        right = 0;
    }

    res = Math.max(res, left + right);
    return Math.max(left, right);
}
```

#### 2.2.3 [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

##### 2.2.3.1 问题分析

1. 该题目属于[非自顶向下](#1-2-非自顶向下)类型，直接套用[相应模板](#1-2-2-解题模板)即可。

##### 2.2.3.2 参考代码

```java
//  二叉树的直径
int res = 0;

/**
 * 543. 二叉树的直径
 * @param root  根节点
 * @return  二叉树的直径
 */
public int diameterOfBinaryTree(TreeNode root) {
    dfs(root);
    return res;
}

/**
 * 深度优先遍历求二叉树的直径
 * @param root  当前节点
 * @return  二叉树的直径
 */
public int dfs(TreeNode root) {
    if (root == null) {return 0;}

    int left = dfs(root.left);
    int right = dfs(root.right);

    res = Math.max(res, left + right);

    return Math.max(left, right) + 1;
}
```

## 参考文献

1. [一篇文章解决所有二叉树路径问题（问题分析 + 分类模板 + 题目剖析）](https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63)。
2. [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths)。
3. [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii)。
4. [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii)。
5. [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path)。
6. [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree)。




<h1 style='page-break-before: always;'>1.4.3 构造二叉树</h1>

## 1 根据前序遍历和中序遍历构造二叉树

### 1.1 题目

给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。

**示例 1:**

![](../../media/202108/2021-08-03_2119220.5945844554796387.png)

```txt
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```txt
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

**提示:**

* 1 <= preorder.length <= 3000
* inorder.length == preorder.length
* -3000 <= preorder[i], inorder[i] <= 3000
* preorder 和 inorder 均无重复元素
* inorder 均出现在 preorder
* preorder 保证为二叉树的前序遍历序列
* inorder 保证为二叉树的中序遍历序列

### 1.2 解题思路

#### 1.2.1 递归

##### 1.2.1.1 问题分析

1. 对于任意一棵树而言，前序遍历的形式总是：
   
   $$
   [根节点, [左子树的前序遍历结果],[右子树的前序遍历结果]]
   $$
   
   即**根节点总是前序遍历中的第一个节点**，而中序遍历的形式总是：
   
   $$
   [[左子树的中序遍历结果], 根节点, [右子树的中序遍历结果]]
   $$
2. 只要我们**在中序遍历中定位到根节点**，那么我们就**可以分别知道左子树和右子树的节点数目**，由于**同一棵子树的前序遍历和中序遍历的长度是相同的**，因此我们就**可以对应到前序遍历的结果中**，**对上述形式中的所有左右括号进行定位**，这样以来，我们就**知道了左子树的前序遍历和中序遍历结果**，**以及右子树的前序遍历和中序遍历结果**，我们就**可以递归地构造出左子树和右子树**，再**将这两棵子树接到根节点的左右位置**。
3. 在中序遍历中对根节点进行定位时，一种简单的方法是**直接扫描整个中序遍历的结果并找出根节点**，但这样做的**时间复杂度较高**，我们可以考虑**使用哈希表来帮助我们快速地定位根节点**，对于哈希映射中的每个键值对，**键表示一个元素**（节点的值），**值表示其在中序遍历中出现的位置**，在构造二叉树的过程之前，我们就可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希树，在此后构造二叉树的过程中，我们就只需要 $O(1)$ 的时间对根节点进行定位了。
   
   ![](../../media/202202/2022-02-07_174548_664531.png)

##### 1.2.1.2 参考代码

```java
/**
 * 105. 从前序与中序遍历序列构造二叉树
 * @param preorder  前序遍历序列
 * @param inorder   中序遍历序列
 * @return  根据前序遍历序列和后续遍历序列构造的二叉树
 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    //  存储前序遍历中每个元素在中序遍历中的位置
    Map<Integer, Integer> inOrderIndexMap = new HashMap<>();
    int m = inorder.length;
    for (int i = 0; i < m; i++) {
        inOrderIndexMap.put(inorder[i], i);
    }
    return myBuildTree(preorder, inorder, 0, m - 1, 0, m - 1, inOrderIndexMap);
}

/**
 * 根据前序遍历序列和中序遍历序列递归构建二叉树
 * @param preorder  前序遍历序列
 * @param inorder   中序遍历序列
 * @param preOrderLeft  前序遍历序列左边界
 * @param preOrderRight 前序遍历序列右边界
 * @param inOrderLeft   中序遍历序列左边界
 * @param inOrderRight  中序遍历序列右边界
 * @param inOrderIndexMap   前序遍历序列中元素在中序遍历序列中的位置映射
 * @return  根据前序遍历序列和后续遍历序列构造的二叉树
 */
public TreeNode myBuildTree(int[] preorder, int[] inorder, int preOrderLeft, int preOrderRight, int inOrderLeft, int inOrderRight, Map<Integer, Integer> inOrderIndexMap) {
    //  base case
    if (preOrderLeft > preOrderRight) {return null;}

    //  前序遍历中的第一个节点就是根节点
    int preOrderRoot = preorder[preOrderLeft];
    //  在中序遍历中定位根节点
    int inOrderRoot = inOrderIndexMap.get(preOrderRoot);
    //  根节点左子树中节点的数目
    int inOrderLeftSubtreeSize = inOrderRoot - inOrderLeft;

    //  创建根节点
    TreeNode root = new TreeNode(preOrderRoot);
    //  递归构建左子树，并连接到根节点
    //  先序遍历中【从 左边界 +1 开始的 inOrderLeftSubtreeSize 个元素】就对应了中序遍历中【从 左边界 开始到 根节点定位-1 的元素】
    root.left = myBuildTree(preorder, inorder, preOrderLeft + 1, preOrderLeft + inOrderLeftSubtreeSize, inOrderLeft, inOrderRoot - 1, inOrderIndexMap);
    //  递归构建右子树，并连接到根节点
    //  先序遍历中【从 左边界 +1+inOrderLeftSubtreeSize 开始到 右边界 的元素】就对应了中序遍历中【从 根节点定位 +1 开始到 右边界 的元素】
    root.right = myBuildTree(preorder, inorder, preOrderLeft + inOrderLeftSubtreeSize + 1, preOrderRight, inOrderRoot + 1, inOrderRight, inOrderIndexMap);

    //  返回根节点
    return root;
}
```

## 参考文献

1. [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)。
2. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9)。




<h1 style='page-break-before: always;'>1.5 回溯算法</h1>

1.6 回溯算法




<h1 style='page-break-before: always;'>1.5.0 回溯算法解题框架</h1>

## 1 含义

1. 回溯算法**建立在 DFS 基础之上**，与 DFS 的主要不同在于：

   1. DFS 是**一个劲的往某一个方向搜索**，**等到到达一个方向的终点时**，才**恢复状态**，**回溯上一层**。
   2. 回溯算法在**达到结束条件后**，就**恢复状态**，**回溯上一层**。
2. 当**问题需要回头**，**以此来查出所有的解的时候**，**使用回溯算法**，即**满足结束条件或者发现不是正确路径的时候**（走不通），**要撤销选择**，**回退到上一个状态**，**继续尝试**，**直到找出所有解为止**。
3. 解决一个回溯算法时主要按照以下步骤：

   1. **画出递归树**，**找到状态变量**（回溯函数的参数），这一部非常重要。
   2. **根据题意**，**确定结束条件**。
   3. **找准选择列表**（与函数参数相关），与第一步紧密关联。
   4. **判断是否需要剪枝**。
   5. **做出选择**，**递归调用**，**进入下一层**。
   6. **撤销选择**。
4. 回溯算法的核心就是**for 循环里面的递归**，即**在递归调用之前【做选择】**，**在递归调用之后【撤销选择】**，解题框架如下：

   ```python
   result = []
   def backtrack(路径, 选择列表):
       if 满足结束条件:
           result.add(路径)
           return

       for 选择 in 选择列表:
           做选择
           backtrack(路径, 选择列表)
           撤销选择
   ```

## 2 应用场景

回溯算法的应用场景主要包括以下几个方面：

1. [子集、组合](#2-1-子集-组合)（$i$**从 $start$ 开始**）：
   1. **子集**：
      1. **数组中的元素互不相同**（没有结束条件）。
      2. **数组中包含重复元素**（先**排序**，然后**当 $i > 0 \space \&\& \space nums[i] == nums[i - 1]$ 时跳过**）。
   2. **组合**：
      1. **数组中的元素可以重复使用**，**数字之和等于目标和**（**递归时依然从 $i$ 开始**）。
2. [全排列](#2-2-1-全排列)（$i$ 从 0 开始，同时添加 $used$ 数组）：
   1. **数组中的元素互不相同**（处理方式与子集类似）。
   2. **数组中包含重复元素**（处理方式与子集类似）。
3. 搜索。

> 需要注意的是，**子集**、**组合与排列是不同性质的概念**，**子集**、**组合是无关顺序的**，而**排列是和元素顺序有关的**，例如 `[1, 2]` 和 `[2, 1]` 是同一个组合（子集），但是是两种不一样的排列，因此被分为两类问题。

### 2.1 子集、组合

#### 2.1.1 [子集](https://leetcode-cn.com/problems/subsets)

##### 2.1.1.1 问题分析

1. **递归树**：![子集问题递归树.png](/media/202108/2021-08-20_1948440.2591370108797909.png)
   1. 观察上图可得**选择列表里的数**，**都是选择路径**（红色框）**后面的数**，比如 `[1]` 这条路径，他后面的选择列表只有 `2、3`，`[2]` 这条路径后面只有 3 这个选择，那么**这个时候**，就**应该使用一个参数 `start`**，**来标识当前的选择列表的起始位置**，**也就是标识每一层的状态**，因为被形象的称为**状态变量**，**最终函数签名如下**：

      ```java
      // nums 为题目中给的数组
      // track 为路径结果，要把每一条 path 加入结果集
      public void backtrack(int[] nums, LinkedList<Integer> track, int start)
      ```
2. **找结束条件**：
   1. **此题非常特殊**，**所有路径都应该加入结果集**，所以**不存在结束条件**。
   2. **当 `start` 参数越过数组边界的时候**，**程序就自己跳过下一层递归了**，因此**不需要手写结束条件**，**直接加入结果集**：

      ```java
      // res 为结果集，是全局变量，到时候需要返回
      LinkedList list = new LinkedList<>(track);
      res.add(list);
      ```
3. **找选择列表**：
   1. 在 1 中已经提过，**子问题的选择列表**，**是上一条选择路径之后的数**，即

      ```java
      for (int i = start; i < nums.length; i++)
      ```
4. **判断是否需要剪枝**：
   1. **从递归树中看到**，**路径没有重复的**，**也没有不符合条件的**，所以**不需要剪枝**。
5. **做出选择**：
   1. 即**将节点添加到路径中**：

      ```java
      track.add(nums[i]);
      ```
6. **撤销选择**：
   1. 即**将节点从路径中移除**：

      ```java
      track.removeLast();
      ```

##### 2.1.1.2 参考代码

```java
//  最后结果
List<List<Integer>> res = new ArrayList<>();

/**
 * 78. 子集
 * @param nums  数组
 * @return  该数组所有可能的子集
 */
public List<List<Integer>> subsets(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track, 0);
    return res;
}

/**
 * 回溯法求解子集问题
 * @param nums  数组
 * @param track 路径
 * @param start 起始位置
 */
public void backtrack(int[] nums, LinkedList<Integer> track, int start) {
    //  将路径添加到结果列表中
    LinkedList list = new LinkedList<>(track);
    res.add(list);
    for (int i = start; i < nums.length; i++) {
        //  做选择：将节点添加到路径中
        track.add(nums[i]);
        backtrack(nums, track, i + 1);
        //  撤销选择：将节点从路径中移除
        track.removeLast();
    }
}
```

#### 2.1.2 [子集 II](https://leetcode-cn.com/problems/subsets-ii)

##### 2.1.2.1 问题分析

1. **递归树**：![在这里插入图片描述](/media/202108/2021-08-20_2007080.467171720456268.png)
   1. 从图中可以发现，**树中出现了大量重复的集合**，找结束条件和选择列表与[2.1.1 子集](#2-1-1-子集)一样，不再赘述，我们直接看判断是否需要剪枝。
2. **判断是否需要剪枝**
   1. 因为**数组中有重复元素**，而**这些重复元素可能并不在一起**（**回溯算法中时通过数组中前后元素是否一致来判断子集是否重复的**），从而**可能导致后面结果出现重复的子集**，因此**需要先对子集进行排序**，**使得重复的元素都在一起**：

      ```java
      Arrays.sort(nums);
      ```
   2. 我们**需要取出重复的集合**，即**需要剪枝**，**把递归树上的某些分支减掉**，观察上图不难发现，**应该去除当前选择列表中**，**与上一个数重复的那个数**，**引出的分支**，如 `2、2` 这个选择列表，第二个 `2` 是最后重复的，应该去除这个 `2` 引出的分值，即下图中红色大框中的分支：

      ![在这里插入图片描述](/media/202108/2021-08-20_2015040.40159480363834765.png)
   3. 因此，在遍历时需要对当前遍历的节点进行判断，如果 $i > start$ 并且 $nums[i] == nums[i - 1]$，那么就需要进行下一个遍历：

      ```java
      if (i > start && nums[i] == nums[i - 1]) {continue;}
      ```
3. 做出选择和撤销选择与[2.1.1 子集](#2-1-1-子集)一样，这里不再赘述。

##### 2.1.2.2 参考代码

```java
//  最后结果
List<List<Integer>> res = new ArrayList<>();

/**
 * 90. 子集 II
 * @param nums  数组
 * @return  该数组所有可能的子集
 */
public List<List<Integer>> subsetsWithDup(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    //  因为数组中有重复元素，而这些重复元素可能并不在一起（回溯算法中时通过数组中前后元素是否一致来判断子集是否重复的），从而可能导致后面结果出现重复的子集，因此需要先对子集进行排序，使得重复的元素都在一起
    Arrays.sort(nums);
    backtrack(nums, track, 0);
    return res;
}

/**
 * 回溯法解决子集问题
 * @param nums  数组
 * @param track 路径
 * @param start 起始位置
 */
public void backtrack(int[] nums, LinkedList<Integer> track, int start) {
    LinkedList list = new LinkedList<>(track);
    res.add(list);
    for (int i = start; i < nums.length; i++) {
        if (i > start && nums[i] == nums[i - 1]) {continue;}
        //  做选择：将节点添加到路径中
        track.add(nums[i]);
        backtrack(nums, track, i + 1);
        //  撤销选择：将节点从路径中移除
        track.removeLast();
    }
}
```

#### 2.1.3 [组合总和](https://leetcode-cn.com/problems/combination-sum)

##### 2.1.3.1 问题分析

1. **递归树**（绿色箭头上面的是路径，红色框的为结果，黄色框的为选择列表）：![在这里插入图片描述](/media/202108/2021-08-20_2036250.1406137970451541.png)

   1. 从上面可以看出，**组合问题和子集问题一样**，`1、2` 和 `2、1` 是同一个组合，因此**需要引入 `start` 参数标识**，**表示每个状态中选择列表的起始位置**，另外，**每个状态还需要一个 `sum` 变量**，**来记录当前路径的和**，函数签名如下：

      ```java
      public void backtrack(int[] candidates, LinkedList<Integer> track, int start, int sum, int target)
      ```
2. **找结束条件**：

   1. 由题意可得，**当路径总和等于 `target` 的时候**，就应该**把路径加入结果集**，**并返回**，**当路径总和大于 `target` 的时候**，**直接返回**：

      ```java
      if (sum == target) {
          LinkedList<Integer> list = new LinkedList<>(track);
          res.add(list);
          return;
      }
      if (sum > target) {
          return;
      }
      ```
3. **找选择列表**：

   ```java
   for (int i = start; i < candidates.length; i++)
   ```
4. **判断是否需要剪枝**：

   1. 从 1 中的递归树中发现，**当前状态的 `sum` 大于 `target` 的时候**，**就应该剪枝**，**不用再递归下去了**：

      ```java
      if (sum > target) {
          return;
      }
      ```
5. **做出选择**：

   1. 题目中说**可以无限次被选择**，那么 `i`**就不用 `+1`**，即**下一层的选择列表**，**从自身开始**，并且**需要更新当前状态的 `sum`**：

      ```java
      track.add(candidates[i]);
      backtrack(candidates, track, i, sum + candidates[i], target);
      ```
6. **撤销选择**：

   ```java
   track.removeLast();
   ```

##### 2.1.3.2 参考代码

```java
//  最后结果
List<List<Integer>> res = new ArrayList<>();

/**
 * 39. 组合总和
 *
 * @param candidates 数组
 * @param target     目标和
 * @return candidates 中所有可以使数字和为目标数 target 的唯一组合
 */
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    LinkedList<Integer> list = new LinkedList<>();
    backtrack(candidates, list, 0, 0, target);
    return res;
}

/**
 * 回溯法求解组合总和问题
 *
 * @param candidates 数组
 * @param track      路径
 * @param start      起始位置
 * @param sum        路径中的元素和
 * @param target     目标和
 */
public void backtrack(int[] candidates, LinkedList<Integer> track, int start, int sum, int target) {
    /**
     * 判断结束条件:
     *  如果当前路径中元素和与目标和相等，则将路径添加到结果列表中
     *  如果当前路径中元素和大于目标和，则直接返回
     */
    if (sum == target) {
        LinkedList<Integer> list = new LinkedList<>(track);
        res.add(list);
        return;
    }
    if (sum > target) {
        return;
    }

    for (int i = start; i < candidates.length; i++) {
        //  做选择：将节点添加到路径中
        track.add(candidates[i]);
        backtrack(candidates, track, i, sum + candidates[i], target);
        //  撤销选择：将节点从路径中移除
        track.removeLast();
    }
}
```

#### 2.1.4 [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses)

##### 2.1.4.1 问题分析

1. **递归树**：![「力扣」第 93 题：复原 IP 地址-1.png](/media/202111/2021-11-09_2146160.4472708671924466.png)

   1. 观察上图可知，**选择列表里的数**，**都是选择路径后面的数**，比如[255.255.11]这条路径，他后面的选择列表只有1、3、5，[255.255.111]这条路径，他后面的选择列表只有3、5，那么这个时候，**需要使用一个参数 `start`**，**来标识当前的选择列表的起始位置**。
   2. 同时，由于**整个ip字符串只能切分4段**（**有段数限制**），因此，还**需要一个参数 `split`**，**来标识当前字符串切分的次数**。
   3. 最终函数签名如下：

      ```java
      /**
       * 回溯算法求解复原 IP 地址问题
       * @param s 字符串
       * @param split 字符串切分次数
       * @param track 路径
       * @param start 每一次切分的起始位置
       */
      public void backtrack(String s, int split, LinkedList<String> track, int start)
      ```
2. **找结束条件**：

   1. 如果**当前切分的起始位置等于字符串的长度**，就应该**直接返回**，而且如果**当前字符串切分次数刚好 4 次**，则**将路径按照 `.`进行拼接后**，**添加到结果列表中**：

      ```java
      int len = s.length();
      if (start == len) {
          if (split == 4) {
              res.add(String.join(".", track));
          }
          return;
      }
      ```
   2. 如果**剩下的字符串不够了或者超过剩余切分次数所需要字符串的最大限制**，则**直接返回**：

      ```java
      int left = len - start;
      if (left < (4 - split) || left > 3 * (4 - split)) {return;}
      ```
3. **找选择列表**：

   ```java
   for (int i = 0; i < 3; i++)
   ```
4. **判断是否需要剪枝**：

   1. 如果在**从选择列表中选择元素时超过字符串长度**，则**直接返回**：

      ```java
      if (start + i >= len) {return;}
      ```
5. **做出选择**：

   1. **将切分的节点添加到路径中**，并且**将切分的次数加1**，然后**从下一个字符开始截切分**：

      ```java
      track.add(ipSegment + "");
      backtrack(s, split + 1, track, start + i + 1);
      ```
6. **撤销选择**：

   ```java
   track.removeLast();
   ```

##### 2.1.4.2 参考代码

```java
//  最后结果
List<String> res = new ArrayList<>();

/**
 * 93. 复原 IP 地址
 * @param s 字符串
 * @return  所有可能从 s 获得的 有效 IP 地址
 */
public List<String> restoreIpAddresses(String s) {
    //  开始进行回溯
    LinkedList<String> track = new LinkedList<>();
    //  字符串切分次数
    int split = 0;
    //  每一次切分的起始位置
    int start = 0;
    backtrack(s, split, track, start);
    return res;
}

/**
 * 回溯算法求解复原 IP 地址问题
 * @param s 字符串
 * @param split 字符串切分次数
 * @param track 路径
 * @param start 每一次切分的起始位置
 */
public void backtrack(String s, int split, LinkedList<String> track, int start) {
    /**
     * 判断结束条件:
     *  1. 如果当前切分的起始位置等于字符串的长度，就应该直接返回，而且如果当前字符串切分次数刚好 4 次，则将路径按照 . 进行拼接后，添加到结果列表中
     *  2. 如果剩下的字符串不够了或者超过剩余切分次数所需要字符串的最大限制，则直接返回
     */
    int len = s.length();
    if (start == len) {
        if (split == 4) {
            res.add(String.join(".", track));
        }
        return;
    }

    int left = len - start;
    if (left < (4 - split) || left > 3 * (4 - split)) {return;}

    for (int i = 0; i < 3; i++) {
        //  如果超过字符串长度，则直接返回
        if (start + i >= len) {return;}

        int ipSegment = judgeIfIpSegment(s, start, start + i);
        if (ipSegment != -1) {
            //  做选择：将节点添加到路径中
            track.add(ipSegment + "");
            backtrack(s, split + 1, track, start + i + 1);
            //  撤销选择：将节点从路径中移除
            track.removeLast();
        }
    }
}

/**
 * 判断截取的 ip 段是否符合要求
 * @param s 字符串
 * @param left  ip 段截取的起始位置
 * @param right ip 段截取的结束位置
 * @return  截取的 ip 段是否符合要求，如果符合，则返回截取的 ip 段，否则返回 -1
 */
public int judgeIfIpSegment(String s, int left, int right) {
    int len = right - left + 1;
    //  大于 1 位的时候，不能以 0 开头
    if (len > 1 && s.charAt(left) == '0') {return -1;}

    //  转成 int 类型，并判断是否大于 255
    int res = 0;
    for (int i = left; i <= right; i++) {
        res = res * 10 + s.charAt(i) - '0';
    }
    if (res > 255) {return -1;}

    return res;
}
```

### 2.2 全排列

#### 2.2.1 [全排列](https://leetcode-cn.com/problems/permutations)

##### 2.2.1.1 问题分析

1. **递归树**（最下面的叶子节点，红色框中的就是要求的结果）：![在这里插入图片描述](/media/202108/2021-08-22_1951100.19782743043057216.png)

   1. 绘制递归树的过程中，**如果我们选择了某个数**，**那么他的下一层的选择列表就是除去这个数以外的其他数**，比如，第一次选择了 2，那么他的下一层的选择列表只有 1 和 3；如果选择了 3，那么他的下一层的选择列表只有 1 和 2，那么这个时候就要**引入一个 `used` 数组来记录使用过的数字**，算法签名如下：

      ```java
      public void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used)
      ```
2. **找结束条件**：

   ```java
   if (nums.length == track.size()) {
       res.add(new LinkedList<>(track));
       return;
   }
   ```
3. **找准选择列表**：

   ```java
   for (int i = 0; i < nums.length; i++)
   ```
4. **判断是否需要剪枝**：

   1. 如果当前节点已经使用过，则直接遍历下一个节点：

      ```java
      if (used[i]) {
          continue;
      }
      ```
5. **做出选择**：

   ```java
   track.add(nums[i]);
   used[i] = true;
   backtrack(nums, track, used);
   ```
6. **撤销选择**：

   ```java
   track.removeLast();
   used[i] = false;
   ```

##### 2.2.1.2 参考代码

```java
//  最后结果
List<List<Integer>> res = new LinkedList<>();

/**
 * 回溯算法解决全排列问题
 *  @param nums 数组
 * @param track 路径
 * @param used  是否使用过标识
 */
public void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
    if (nums.length == track.size()) {
        res.add(new LinkedList<>(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        /**
         * 剪枝：
         *  1. 如果使用过，则遍历下一个节点
         */
        if (used[i]) {
            continue;
        }
        track.add(nums[i]);
        used[i] = true;
        backtrack(nums, track, used);
        track.removeLast();
        used[i] = false;
    }
}

/**
 * 46. 全排列
 *
 * @param nums 数组
 * @return 数组元素的全排列
 */
public List<List<Integer>> permute(int[] nums) {
    //  记录【路径】
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used = new boolean[nums.length];
    backtrack(nums, track, used);
    return res;
}
```

#### 2.2.2 [全排列 II](https://leetcode-cn.com/problems/permutations-ii)

##### 2.2.2.1 问题分析

1. **递归树**：![在这里插入图片描述](/media/202108/2021-08-22_2010350.651348149784578.png)
   1. 可以看到，有两组是重复的，这是因为在**选了第二个 2 后**，**又选了第一个 2**，从而**导致最右边整条分支都是重复的**：![在这里插入图片描述](/media/202108/2021-08-22_2013540.367251238752221.png)
   2. 找结束条件和选择列表和前面差不多，这里不再赘述。
2. **判断是否需要剪枝**：
   1. 有了前面[子集、组合](#2-1-子集-组合)问题的判重经验，同样首先**要对题目中给出的 $nums$ 数组排序**，**让重复的元素并列排在一起**，在 `if(i > start && nums[i]==nums[i-1])` 基础上修改为 `if(i > 0 && nums[i]==nums[i-1] && !used[i-1])`，语义为**当 $i$ 可以选第一个元素之后的元素时**，**判断当前元素是否和上一个元素相同**，**如果相同**，**再判断上一个元素是否能用**，**如果上一个元素不能用**，那么**该分支一定是重复的**，**应该剪去**：

      ```java
      if (i > 0 && nums[i] == nums[i - 1] && used[i - 1]) {
      		continue;
      }
      ```
   2. 做出选择和撤销选择和上面类似，这里不再赘述。

##### 2.2.2.2 参考代码

```java
//  最终结果
List<List<Integer>> res = new ArrayList<>();

/**
 * 47. 全排列 II
 *
 * @param nums 数组
 * @return 所有不重复的全排列
 */
public List<List<Integer>> permuteUnique(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used = new boolean[nums.length];
    //  因为数组中有重复元素，而这些重复元素可能并不在一起（回溯算法中时通过数组中前后元素是否一致来判断子集是否重复的），从而可能导致后面结果出现重复的子集，因此需要先对子集进行排序，使得重复的元素都在一起
    Arrays.sort(nums);
    backtrack(nums, track, used);
    return res;
}

/**
 * 回溯法解决全排列问题
 *
 * @param nums  数组
 * @param track 路径
 * @param used  是否使用过标识
 */
public void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
    if (track.size() == nums.length) {
        List<Integer> list = new LinkedList<>(track);
        res.add(list);
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        /**
         * 剪枝：
         *  1. 如果使用过，则遍历下一个节点
         *  2. 如果当前节点和上一个节点的值相等，且上一个节点已经使用过，则当前排列全排列一定为重复的全排列，直接遍历下一个节点
         */
        if (used[i]) {
            continue;
        }
        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1]) {
            continue;
        }
        track.add(nums[i]);
        used[i] = true;
        backtrack(nums, track, used);
        used[i] = false;
        track.removeLast();
    }
}
```

##### 2.2.2.3 扩展题目

###### 2.2.2.3.1 [字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof)

1. 这个题目和[全排列 II](#2-2-2-全排列-II)类似，需要注意的是**字符串转数组**和**List 转数组**的问题：
   1. **字符串转数组**：

      ```java
      char[] arr = s.toCharArray();
      ```
   2. **List 转数组**：

      ```java
      List<String> res = new ArrayList<>();
      res.toArray(new String[res.size()]);
      ```
2. 参考代码：
   ```java
   //  最后结果
   List<String> res = new ArrayList<>();

   /**
    * 剑指 Offer 38. 字符串的排列
    *
    * @param s 字符串
    * @return 字符串中字符的所有排列
    */
   public String[] permutation(String s) {
       StringBuffer buffer = new StringBuffer();
       boolean[] used = new boolean[s.length()];
       //  因为数组中有重复元素，而这些重复元素可能并不在一起（回溯算法中时通过数组中前后元素是否一致来判断子集是否重复的），从而可能导致后面结果出现重复的子集，因此需要先对子集进行排序，使得重复的元素都在一起
       char[] arr = s.toCharArray();
       Arrays.sort(arr);
       backtrack(arr, buffer, used);
       return res.toArray(new String[res.size()]);
   }

   /**
    * 回溯法解决字符串的排列问题
    *
    * @param arr    数组
    * @param buffer 路径
    * @param used   是否使用过标识
    */
   public void backtrack(char[] arr, StringBuffer buffer, boolean[] used) {
       if (buffer.length() == arr.length) {
           res.add(buffer.toString());
           return;
       }

       for (int i = 0; i < arr.length; i++) {
           /**
            * 剪枝：
            *  1. 如果使用过，则遍历下一个节点
            *  2. 如果当前节点和上一个节点的值相等，且上一个节点已经使用过，则当前排列全排列一定为重复的全排列，直接遍历下一个节点
            */
           if (used[i]) {
               continue;
           }
           if (i > 0 && arr[i] == arr[i - 1] && used[i - 1]) {
               continue;
           }
           buffer.append(arr[i]);
           used[i] = true;
           backtrack(arr, buffer, used);
           used[i] = false;
           buffer.deleteCharAt(buffer.length() - 1);
       }
   }
   ```

## 参考文献

1. [回溯算法解题套路框架](https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban)。
2. [C++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)](https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-)。
3. [78. 子集](https://leetcode-cn.com/problems/subsets)。
4. [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii)。
5. [39. 组合总和](https://leetcode-cn.com/problems/combination-sum)。
6. [46. 全排列](https://leetcode-cn.com/problems/permutations)。
7. [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii)。
8. [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof)。
9. [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses)。
10. [ 回溯算法（画图分析剪枝条件）](https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by)。



<h1 style='page-break-before: always;'>1.5.1 N皇后</h1>

## 1 题目

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

![](../../media/202106/2021-06-27_194424.png)

```txt
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```txt
输入：n = 1
输出：[["Q"]]
```

**提示：**

* 1 <= n <= 9
* 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。

## 2 解题思路

### 2.1 回溯算法

#### 2.1.1 问题分析

1. N 皇后的问题本质上跟[全排列](https://notebook.ricear.com/project-21/doc-738)问题差不多，决策树的每一层表示棋盘的每一行，每个节点可以做出的选择是在该行的任意一列放置一个皇后。
2. 函数 `backtrack` 依然像个在决策树上游走的指针，通过 `row` 和 `col` 就可以表示函数遍历到的位置，通过 `isValid` 函数可以将不符合条件的情况进行剪枝。![](../../media/202106/2021-06-27_195120.png)

#### 2.1.2 参考代码

```java
/**
 * 将字符数组转化为字符串
 * @param array 字符数组
 * @return  字符数组对应的字符串
 */
public static String charArrayToString(char[] array) {
    return Arrays.toString(array).replaceAll("[\\[\\]\\s,]", "");
}

/**
 * 判断是否可以在 track[row][col] 放置皇后
 *
 * @param track 路径
 * @param row   行
 * @param col   列
 * @return 是否可以在 track[row][col] 放置皇后
 */
private boolean isValid(ArrayList<String> track, int row, int col) {
    int rowLen = track.size();
    char[] rowArr = track.get(row).toCharArray();

    //  检查所在行是否有冲突
    for (int i = 0; i < rowArr.length; i++) {
        if (i != col && rowArr[i] == 'Q') {
            return false;
        }
    }

    //  检查所在列是否有冲突
    for (int i = 0; i < rowLen; i++) {
        if (i != row && track.get(i).charAt(col) == 'Q') {
            return false;
        }
    }

    //  判断左上角所对应的斜线上是否有冲突
    //  左上
    int rowTemp = row, colTemp = col;
    while (rowTemp >= 0 && colTemp >= 0) {
        if (rowTemp != row && colTemp != col && track.get(rowTemp).charAt(colTemp) == 'Q') {
            return false;
        }
        rowTemp--;
        colTemp--;
    }
    //  右下
    rowTemp = row;
    colTemp = col;
    while (rowTemp < rowLen && colTemp < rowLen) {
        if (rowTemp != row && colTemp != col && track.get(rowTemp).charAt(colTemp) == 'Q') {
            return false;
        }
        rowTemp++;
        colTemp++;
    }

    //  判断右上角所对应的斜线上是否有冲突
    //  右上
    rowTemp = row;
    colTemp = col;
    while (rowTemp >= 0 && colTemp < rowLen) {
        if (rowTemp != row && colTemp != col && track.get(rowTemp).charAt(colTemp) == 'Q') {
            return false;
        }
        rowTemp--;
        colTemp++;
    }
    //  左下
    rowTemp = row;
    colTemp = col;
    while (rowTemp < rowLen && colTemp >= 0) {
        if (rowTemp != row && colTemp != col && track.get(rowTemp).charAt(colTemp) == 'Q') {
            return false;
        }
        rowTemp++;
        colTemp--;
    }

    return true;
}

/**
 * 回溯算法
 * 【路径】：track 中小于 row 的那些行都已经成功放置了皇后
 * 【选择列表】：第 row 行的所有列都是放置皇后的选择
 * 【结束条件】：row 超过 track 的最后一行
 *  @param row
 * @param track
 * @param res
 */
public void backtrack(int row, ArrayList<String> track, List<List<String>> res) {
    //  触发结束条件
    if (row == track.size()) {
        ArrayList<String> trackTemp = new ArrayList<>();
        trackTemp.addAll(track);
        res.add(trackTemp);
        return;
    }

    int rowLen = track.get(row).length();
    for (int col = 0; col < rowLen; col++) {
        //  排除不合法选择
        if (!isValid(track, row, col)) {
            continue;
        }
        //  做选择
        char[] array = track.get(row).toCharArray();
        array[col] = 'Q';
        track.set(row, charArrayToString(array));
        //  进入下一行决策
        backtrack(row + 1, track, res);
        //  撤销选择
        array[col] = '.';
        track.set(row, charArrayToString(array));
    }
}

/**
 * 51. N 皇后
 *
 * @param n 皇后个数
 * @return 所有不同的 n 皇后问题 的棋子放置方案
 */
public List<List<String>> solveNQueens(int n) {
    List<List<String>> res = new ArrayList<>();
    //  初始化棋盘，“.”表示空，“Q”表示皇后
    ArrayList<String> track = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        track.add(String.join("", Collections.nCopies(n, ".")));
    }
    backtrack(0, track, res);
    return res;
}
```

## 参考文献

1. [51. N 皇后](https://leetcode-cn.com/problems/n-queens)。
2. [回溯算法解题套路框架](https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban)。




<h1 style='page-break-before: always;'>1.6 数组</h1>

1.7 数组




<h1 style='page-break-before: always;'>1.6.0 删除有序数组中的重复项</h1>

## 1 题目

给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```java
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

示例 1：

```txt
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

示例 2：

```txt
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

类似的题目还有：

1. [80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)。
2. [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)。
3. [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)。

## 2 解题思路

### 2.1 快慢指针

#### 2.1 问题分析

1. **对于数组相关的算法问题，有一个通用的技巧：要尽量避免在中间删除元素，而是想办法把这个元素换到最后去。** 这样的话，最终待删除的元素都拖在数组尾部，一个一个 `pop` 掉就行了，每次操作的时间复杂度也就降低到 `O(1)` 了。
2. 按照这个思路，又可以衍生出解决类似需求的通用方式：双指针技巧。具体一点说，应该是快慢指针：
   1. 我们让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。
   2. 这样当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]`**就是不重复元素，之后的所有元素都是重复元素。**

#### 2.2 参考代码

```java
/**
 * 26.删除有序数组中的重复项
 *
 * @param nums 数组
 * @return 删除后数组的新长度
 */
public static int removeDuplicates(int[] nums) {
    int slow = 0, fast = slow + 1;
    while (fast < nums.length) {
        if (nums[fast] != nums[fast - 1]) {
            slow++;
            nums[slow] = nums[fast];
        }
        fast++;
    }
    return slow + 1;
}
```

#### 2.3 扩展题目

##### 2.3.1 [删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)

###### 2.3.1.1 问题分析

1. 该题目也可以采用快慢指针的方法来解决，其中 $nums[0..slow]$**表示的不含重复次数超过最大限制的元素**，**之后的所有元素都是重复次数超过最大限制的元素**。
2. 整体的计算逻辑为**使用快慢指针对数组中的元素进行遍历**，其中**初始时 $slow = 0$**，$fast = slow + 1$，$count = 0$：
   1. **如果 $nums[slow] == nums[fast]$**：
      1. **将元素出现的次数计数器 $count$ 的值加 1**。
      2. **如果一个元素出现的次数达到了最大限制**，并且**后面还有元素**，则：
         1. **将 $nums[slow + 1]$ 赋值为 $nums[fast + 1]$**。
         2. **将 $fast$ 加 1**。
         3. **进行下一个循环**。
   2. 如果 $nums[slow] != nums[fast]$，则：
      1. **令元素出现的次数计数器 $count$ 为 0**。
   3. **将 $nums[slow + 1]$ 的值赋值为 $nums[fast]$**，**同时将两个指针依次向前移动一位**。

###### 2.3.1.2 参考代码

```java
/**
 * 80. 删除有序数组中的重复项 II
 * @param nums  有序数组
 * @return  删除重复项后有序数组的新长度
 */
public int removeDuplicates(int[] nums) {
    return process(nums, 2);
}

/**
 * 删除有序数组中的重复元素，使每个元素最多出现 k 次
 * @param nums  有序数组
 * @param k 每个元素最多出现的次数
 * @return  删除重复项后有序数组的新长度
 */
public int process(int[] nums, int k) {
    int m = nums.length;
    int slow = 0, fast = slow + 1, count = 0;
    //  用于解决类似于 [1,1,1] 的问题
    boolean except = false;

    while (fast < m) {
        if (nums[slow] == nums[fast]) {
            count++;
            if (count >= k) {
                if (fast + 1 < m) {
                    //  如果 nums[slow] == nums[fast]，并且一个元素出现的次数达到了最大限制，并且后面还有元素，则
                    //      1. 将 nums[slow + 1] 赋值为 nums[fast + 1]
                    //      2. 将 fast 加 1
                    //      3. 进行下一个循环
                    nums[slow + 1] = nums[fast + 1];
                    fast++;
                    continue;
                } else {
                    except = true;
                }
            }
        } else {
            //  如果 nums[slow] != nums[fast]，则：
            //      1. 重置元素出现的次数计数器
            count = 0;
        }
        //  将 nums[slow + 1] 的值赋值为 nums[fast]
        nums[slow + 1] = nums[fast];
        //  将两个指针依次向前移动一位
        fast++;
        slow++;
    }

    //  返回删除重复元素后数组的长度：
    //      1. 如果是类似于 [1,1,1] 的情况，则 返回 slow
    //      2. 否则，返回 slow + 1
    return except ? slow : slow + 1;
}
```

#### 2.3.2 [删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)

##### 2.3.2.1 问题分析

1. 该题目也可以采用快慢指针来解决，其中$slow$为慢指针，$pre$为$slow$的前驱结点，$fast$为快指针，同时也为$slow$的后继节点，$same$ 表示当前操作的两个元素是否相等，$firstSame$ 表示头结点是否和其后继节点相同，主要为了解决 $[1, 1, *]$ 的特殊情况
2. 在一个循环中：
   1. 如果$slow$和$fast$节点的值相等：
      1. 将 $fast$ 节点后移，同时将 $slow$ 节点指向 $fast$ 节点，保证 $fast$ 节点始终是 $slow$ 节点的后继节点。
      2. 更新$same$的值为 `true`。
   2. 如果 $slow$ 和 $fast$ 节点的值不相等:
      1. 判断上一个操作中 $slow$ 和 $fast$ 的值是否相等:         1. 如果上一个操作中 $slow$ 和 $fast$ 的值相等，说明 $slow$ 节点也是相同节点的一部分，需要删除，因此将 $pre$ 指向 $slow$ 节点的下一个节点。
      2. 如果上一个操作中 $slow$ 和 $fast$ 的值不相等，则将 $pre$ 更新为 $slow$ 节点，后面再将 $slow$ 节点后移，使得 $pre$ 节点始终为 $slow$ 节点的前驱结点。
      3. 将 $slow$ 和 $fast$ 节点均后移。
      4. 更新 $same$ 的值为 `false`。
3. 如果$same$为 `true`，则将$pre$指向$slow$的下一个节点，以解决 $[*, 1, 1]$ 的特殊情况。
4. 最后如果首节点是相同节点的一部分，则将首节点删除，返回首节点的下一个节点，否则，返回首节点。

##### 2.3.2.2 参考代码

```java
/**
 * 82. 删除排序链表中的重复元素 II
 * @param head  排序链表的头结点
 * @return  删除重复元素后的排序链表
 */
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {return head;}   //  如果头结点为空或者只有一个节点，则直接返回头结点
    ListNode pre = head, slow = head, fast = head.next; //  pre 为 slow 的前驱结点，fast 为 slow 的后继节点
    boolean same = false, firstSame = (slow.val == fast.val);   //  same 表示当前操作的两个元素是否相等，firstSame 表示头结点是否和其后继节点相同，主要为了解决 [1, 1, *] 的特殊情况
    while (fast != null) {
        /**
         * 如果 slow 和 fast 节点的值相等:
         *  1. 将 fast 节点后移，同时将 slow 节点指向 fast 节点，保证 fast 节点始终是 slow 节点的后继节点
         *  2. 更新 same 的值为 true
         */
        if (slow.val == fast.val) {
            fast = fast.next;
            slow.next = fast;
            same = true;
        } else {
            /**
             * 如果 slow 和 fast 节点的值不相等:
             *  1. 判断上一个操作中 slow 和 fast 的值是否相等:
             *      1.1 如果上一个操作中 slow 和 fast 的值相等，说明 slow 节点也是相同节点的一部分，需要删除，因此将 pre 指向 slow 节点的下一个节点
             *      1.2 如果上一个操作中 slow 和 fast 的值不相等，则将 pre 更新为 slow 节点，后面再将 slow 节点后移，使得 pre 节点始终为 slow 节点的前驱结点
             *  2. 将 slow 和 fast 节点均后移
             *  3. 更新 same 的值为 false
             */
            if (same) {pre.next = slow.next;}
            else {pre = slow;}
            slow = slow.next;
            fast = fast.next;
            same = false;
        }
    }
    if (same) {pre.next = slow.next;}   //  解决 [*, 1, 1] 的特殊情况
    return firstSame ? head.next : head;    //  如果首节点是相同节点的一部分，则将首节点删除，返回首节点的下一个节点，否则，返回首节点
}
```

## 参考文献

1. [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)。
2. [80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)。
3. [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)。
4. [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)。
5. [如何去除有序数组的重复元素](https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye-2/yuan-di-xiu-gai-shu-zu)。



<h1 style='page-break-before: always;'>1.6.1 滑动窗口最大值</h1>

## 1 题目

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**

```txt
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```txt
输入：nums = [1], k = 1
输出：[1]
```

**示例 3：**

```txt
输入：nums = [1,-1], k = 1
输出：[1,-1]
```

**示例 4：**

```txt
输入：nums = [9,11], k = 2
输出：[11]
```

**示例 5：**

```txt
输入：nums = [4,-2], k = 2
输出：[4]
```

**提示：**

* 1 <= nums.length <= 105
* -104 <= nums[i] <= 104
* 1 <= k <= nums.length

## 2 问题分析

1. 这道题不复杂，难点在于**如何在 $O(1)$ 时间算出每个【窗口】中的最大值**，**使得整个算法在线性时间完成**，**在一堆数字中**，**已知最值**，**如果给这堆数添加一个数**，**那么比较一下就可以很快算出最值**，**但如果减少一个数**，**就不一定能很快得到最值了**，**而要遍历所有数重新找最值**。
2. 回到这道题的场景，**每个窗口前进的时候**，**要添加一个数同时减少一个数**，**所以想在 $O(1)$ 的时间得出新的最值**，**就需要【单调队列】这种特殊的数据结构来辅助了**：
   1. 整个单调队列的结构如下：

      ```java
      class MonotonicQueue {
          //  底层使用双端队列存储数据
          private Deque<Integer> data = new ArrayDeque<>();

          // 在队尾添加元素 n
          void push(int n);
          // 返回当前队列中的最大值
          int max();
          // 队头元素如果是 n，删除它
          void pop(int n);
      }
      ```

      1. `push(int n)` 方法：
         1. 这个方法中的 $n$**代表我们要添加的元素**。
         2. 我们可以把加入数字的大小**类比于人的体重**，**把前面体重不足的都压扁了**，**直到遇到更大的量级才停住**。
         3. **如果每个元素被加入时都这样操作**，**最终单调队列中的元素就会保持一个单调递减的顺序**，即**队首的元素最大**，**队尾的元素最小**。![无效的图片地址](/media/202111/2021-11-21_2239570.38904421963548796.png)
         4. 该方法的具体实现为：

            ```java
            void push(int n) {
                while (data.size() != 0 && data.peekLast() < n) {
                    data.pollLast();
                }
                data.offerLast(n);
            }
            ```
      2. `max()` 方法：
         1. **由于每次添加元素时会把小于添加元素的元素弹出**，**因此每次添加元素后的队列都是一个单调递减队列**，**队首的元素即为队列中的最大元素**，**直接返回即可**。
         2. 该方法的具体实现为：

            ```java
            int max() {
                return data.peekFirst();
            }
            ```
      3. `pop(int n)`：
         1. 这个方法中的 $n$**代表我们要弹出的元素**。
         2. **之所以要判断 `data.peekFirst() == n`**，**是因为我们想删除的对头元素 $n$ 可能已经被【压扁】了**，**这时候就不用删除了**。![无效的图片地址](/media/202111/2021-11-21_2246440.5904891752502391.png)

## 3 参考代码

```java
/**
 * 自定义单调递增队列
 */
class MonotonicQueue {
    //  底层使用双端队列存储数据
    private Deque<Integer> data = new ArrayDeque<>();

    /**
     * 插入数据
     * @param n 插入的数据
     */
    void push(int n) {
        while (data.size() != 0 && data.peekLast() < n) {
            //  如果队尾的元素比插入的数据小，则直接将队尾的元素弹出
            data.pollLast();
        }
        //  将元素插入队尾
        data.offerLast(n);
    }

    /**
     * 返回队列中的最大值
     * @return  队列中的最大值
     */
    int max() {
        //  由于在插入元素的时候保证双端队列是递增的，因此队首元素即为双端队列中的最大元素
        return data.peekFirst();
    }

    /**
     * 弹出元素
     * @param n 弹出的元素
     */
    void pop(int n) {
        //  因为我们想删除的对头元素可能已经在其他元素插入的时候被弹出了，这时候就不用删除了
        if (data.size() != 0 && data.peekFirst() == n) {
            data.pollFirst();
        }
    }
}

/**
 * 239. 滑动窗口最大值
 * @param nums  整数数组
 * @param k 滑动窗口大小
 * @return  滑动窗口中的最大值
 */
public int[] maxSlidingWindow(int[] nums, int k) {
    MonotonicQueue window = new MonotonicQueue();
    int[] res = new int[nums.length - k + 1];
    int index = 0;

    for (int i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            //  先填满窗口的前 k - 1
            window.push(nums[i]);
        } else {
            //  窗口向前滑动
            window.push(nums[i]);
            res[index++] = window.max();
            window.pop(nums[i - k + 1]);
        }
    }

    return res;
}
```

## 参考文献

1. [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum)。
2. [单调队列解题详解](https://leetcode-cn.com/problems/sliding-window-maximum/solution/dan-diao-dui-lie-by-labuladong)。



<h1 style='page-break-before: always;'>1.6.2 调整数组顺序使奇数位于偶数前面</h1>

## 1 题目

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

**示例：**

```txt
输入：nums = [1,2,3,4]
输出：[1,3,2,4]
注：[3,1,2,4] 也是正确的答案之一。
```

**提示：**

* 0 <= nums.length <= 50000
* 0 <= nums[i] <= 10000

## 2 问题分析

1. 本题可以采用**双指针**的方法来解答。
2. **考虑定义双指针**$i$、$j$**分列数组左右两端**，**循环执行**：

   1. **指针$i$从左向右寻找偶数**。
   2. **指针$j$从右向左寻找奇数**。
   3. **将偶数$nums[i]$与奇数$nums[j]$交换**。
3. 这样可始终**保证指针$i$左边都是奇数**，**指针$j$右边都是偶数**。

   ![Picture1.png](/media/202201/2022-01-15_1513560.3786184599326553.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
 * @param nums  数组
 * @return  调整后的数组
 */
public int[] exchange(int[] nums) {
    int i = 0, j = nums.length - 1, temp;
    while (i < j) {
        while (i < j && nums[i] % 2 != 0) {i++;}
        while (i < j && nums[j] % 2 == 0) {j--;}
        temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    return nums;
}
```

## 参考文献

1. [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof)。
2. [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面（双指针，清晰图解）](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/mian-shi-ti-21-diao-zheng-shu-zu-shun-xu-shi-qi-4)。



<h1 style='page-break-before: always;'>1.6.3 螺旋矩阵</h1>

## 1 题目

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

**示例 1：**

![](../../media/202107/2021-07-01_193627.png)

```txt
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![](../../media/202107/2021-07-01_193635.png)

```txt
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：**

* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 10
* -100 <= matrix[i][j] <= 100

## 2 问题分析

1. 解决这个问题的基本思路是将整个矩阵划分为**四个区域**，然后**分区域**来进行**输出**，为了减少考虑的情况，拟将矩阵划分为如下图所示的区域：

   ![](../../media/202206/2022-06-02_111817_004461.png)
2. 从上面划分的区域中我们可以看出，**上下**和**左右**对应的区域分别是**对称**的，因此只要将其中两个区域写好之后，另外两个区域就是其相反的输出，假设需要进行的圈数为$round$，矩阵的宽为$m$，长为$n$，则：

   1. 上区域输出的代码为：

      ```java
      for (int j = i; j <= n - i - 1; j++) {res.add(matrix[i][j]);}
      ```

      因此对应的下区域输出的代码为：

      ```java
      for (int j = n - i - 1; j >= i; j--) {res.add(matrix[m - i - 1][j]);}
      ```
   2. 左区域输出的代码为：

      ```java
      for (int j = m - i - 2; j > i; j--) {res.add(matrix[j][i]);}
      ```

      因此对应的右区域输出的代码为：

      ```java
      for (int j = i + 1; j <= m - i - 2; j++) {res.add(matrix[j][n - i - 1]);}
      ```
3. 但同时我们还需要考虑两种特殊情况，这两种特殊情况可能会造成**元素的重复输出**：

   1. **纵轴单独**：

      ![](../../media/202206/2022-06-02_112556_511419.png)

      这种情况其实我们只要**将这个单独的纵轴放在右侧区域**即可（因为按照**顺时针旋转**，**右侧区域相比于左侧区域先进行遍历**），也就是**让左侧遍历的纵轴小于右侧**即可，即 `i < n - i - 1`，其中当前遍历的元素坐标为 `matrix[j][i]`。
   2. **横轴单独**：

      ![](../../media/202206/2022-06-02_113115_724284.png)

      这种情况与纵轴单独类似，只要**将单独的横轴放在上侧区域**即可（因为按照**顺时针旋转**，**上侧区域相比于下侧区域先进行遍历**），也就是**让下侧遍历的横轴大于上侧**即可，即 `i < m - i - 1`，其中当前遍历的元素坐标为 `matrix[m - i - 1][j]`。
4. 因此区域完整的输出代码为：

   ```java
   for (int i = 0; i < round; i++) {
       //  上
       for (int j = i; j <= n - i - 1; j++) {res.add(matrix[i][j]);}
       //  右
       for (int j = i + 1; j <= m - i - 2; j++) {res.add(matrix[j][n - i - 1]);}
       //  下
       for (int j = n - i - 1; j >= i && i < m - i - 1; j--) {res.add(matrix[m - i - 1][j]);}
       //  左
       for (int j = m - i - 2; j > i && i < n - i - 1; j--) {res.add(matrix[j][i]);}
   }
   ```
5. 还有一个关键的问题是需要进行的圈数$round$如何确定，通过观测我们可以发现**需要进行的圈数和矩阵的长度和宽度的最小值有关**，假设$min = Math.min(m, n)$，则：

   ```java
   round = (min % 2 == 0) ? min / 2 : min / 2 + 1;
   ```

## 3 参考代码

```java
/**
 * 54. 螺旋矩阵
 * @param matrix    矩阵
 * @return  按照顺时针螺旋顺序，返回矩阵中的所有元素
 */
public List<Integer> spiralOrder(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length, min = Math.min(m, n);
    int round = (min % 2 == 0) ? min / 2 : min / 2 + 1;
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < round; i++) {
        //  上
        for (int j = i; j <= n - i - 1; j++) {res.add(matrix[i][j]);}
        //  右
        for (int j = i + 1; j <= m - i - 2; j++) {res.add(matrix[j][n - i - 1]);}
        //  下
        for (int j = n - i - 1; j >= i && i < m - i - 1; j--) {res.add(matrix[m - i - 1][j]);}
        //  左
        for (int j = m - i - 2; j > i && i < n - i - 1; j--) {res.add(matrix[j][i]);}
    }
    return res;
}
```

## 4 参考文献

1. [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)。



<h1 style='page-break-before: always;'>1.6.4 多数元素</h1>

## 1 题目

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```txt
输入：[3,2,3]
输出：3
```

**示例 2：**

```txt
输入：[2,2,1,1,1,2,2]
输出：2
```

**进阶：**

* 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

## 2 解题思路

### 2.1 计数

#### 2.1.1 问题分析

1. 最原始的思路是**通过一个 $map$**，其中 $key$**为数组中的元素**，$value$**为对应元素出现的次数**，**添加完元素后**，**如果当前元素的出现次数大于 $\frac{n}{2}$**，则**该元素即为多数元素**，**直接返回即可**。

#### 2.1.2 参考代码

```java
/**
 * 169. 多数元素（版本 1：计数）
 * @param nums  数组
 * @return  数组中出现次数 大于 ⌊ n/2 ⌋ 的元素
 */
public int majorityElementV1(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    int m = nums.length;

    if (m == 1) {return nums[0];}

    for (int i = 0; i < m; i++) {
        int key = nums[i];
        if (!map.containsKey(key)) {
            map.put(key, 1);
        } else {
            int value = map.get(key);
            value++;
            if (value > m / 2) {
                return key;
            } else {
                map.put(key, value);
            }
        }
    }

    return -1;
}
```

### 2.2 排序

#### 2.2.1 问题分析

1. 对数组中的元素进行**升序排序**，因为**多数元素的个数大于 $\frac{n}{2}$**，因此**排序后数组的中间位置的元素即为多数元素**。

#### 2.2.2 参考代码

```java
/**
 * 169. 多数元素（版本 2：排序）
 * @param nums  数组
 * @return  数组中出现次数 大于 ⌊ n/2 ⌋ 的元素
 */
public int majorityElementV2(int[] nums) {
    Arrays.sort(nums);
    //  因为多数元素在数组中出现的次数大于 n / 2，因此位于中间位置的元素一定是中位数
    return nums[nums.length >> 1];
}
```

### 2.3 摩尔排序

#### 2.3.1 问题分析

1. **开始时将投票人 $voteItem$ 初始化为 0**，**票数 $voteNum$ 初始化为 0**，然后**对数组 $nums$ 进行遍历**，假设当前遍历到的元素 $nums[i]$ 为
   1. 如果 $voteNum = 0$：则令 $voteItem = nums[i], voteNum = 1$。
   2. 如果 $voteItem != nums[i]$，则 $voteNum = voteNum - 1$。
   3. 如果 $voteItem = nums[i]$，则 $voteNum = voteNum + 1$。
2. 这种方法之所以行得通是因为**投票法是遇到相同的则票数 +1**，**遇到不同的则票数-1**，且**多数元素的个数 $> ⌊\frac{n}{2}⌋$**，**其余元素的个数总和 $\le ⌊\frac{n}{2}⌋$**，因此**多数元素的个数 - 其余元素的个数总和的结果一定 $\ge1$**，这就**相当于每个多数元素和其他元素的两两相互抵消**，**抵消到最后肯定还剩余至少 1 个多数元素**。

#### 2.3.2 参考代码

```java
/**
 * 169. 多数元素（版本 3：摩尔投票）
 * @param nums  数组
 * @return  数组中出现次数 大于 ⌊ n/2 ⌋ 的元素
 */
public int majorityElementV3(int[] nums) {
    int voteItem = 0, voteNum = 0;

    for (int i = 0; i < nums.length; i++) {
        if (voteNum == 0) {
            voteItem = nums[i];
            voteNum = 1;
        }
        else if (voteItem == nums[i]) {
            voteNum++;
        } else {
            voteNum--;
        }
    }

    return voteItem;
}
```

## 参考文献

1. [169. 多数元素](https://leetcode-cn.com/problems/majority-element)。
2. [ Java-3 种方法(计数法/排序法/摩尔投票法)](https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2)。




<h1 style='page-break-before: always;'>1.6.5 最大数</h1>

## 1 题目

给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。

**示例 1：**

```
输入：nums = [10,2]
输出："210"
```

**示例 2：**

```
输入：nums = [3,30,34,5,9]
输出："9534330"
```

**示例 3：**

```
输入：nums = [1]
输出："1"
```

**示例 4：**

```
输入：nums = [10]
输出："10"
```

**提示：**

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 109

## 2 解题思路

### 2.1 互换位置

#### 2.1.1 问题分析

1. 可以先遍历整个数组，然后比较两个数字组成字符串对应的数字的大小，然后将二者互换位置，将较大的数字放在数组前面。
2. 在对数字组成字符串对应的数字进行比较时，**可以通过将两个数字互换位置，然后比较组成的两个数字字符串的大小即可**，在对两个数字字符串进行比较时需要注意，如果直接将其转换位数字来比较的话可能会越界，所以需要按照字符串的格式**从高位到低位逐位比较，直到可以区分两个字符串的大小即可**。
3. 当所有数字比较完成后，需要判断一下是否所有数字全部为 0，因为如果都为 0 的话，按照正常的逻辑，后面生成的字符串为 `"000..."` 的格式，这样是不正确的，所以需要判断一下是否所有数字都为 0，如果都为 0 的话，直接返回 `"0"` 即可。
   1. 判断时只需要判断比较完的数组的第一个元素是否为 0 即可，因为如果第一个元素为 0 的话，后面的元素一定全部为 0。

#### 2.1.2 参考代码

```java
/**
 * 比较两个数所包含元素的最大值的大小
 *
 * @param a 一个数
 * @param b 另一个数
 * @return 两个数所包含元素的最大值的大小
 */
public int compare(int a, int b) {
    String combineAB = a + "" + b;
    String combineBA = b + "" + a;
    for (int i = 0; i < combineAB.length(); i++) {
        int ab = combineAB.charAt(i);
        int ba = combineBA.charAt(i);
        if (ab != ba) {return ab - ba;}
    }
    return 0;
}

/**
 * 179. 最大数
 *
 * @param nums 数组
 * @return 数组中的元素组合成的最大整数
 */
public String largestNumber(int[] nums) {
    String s = "";
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (compare(nums[i], nums[j]) < 0) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }

    boolean allZero = true;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {allZero = false;}
        s += nums[i];
    }
    return allZero ? "0" : s;
}
```

## 3 参考文献

1. [179. 最大数](https://leetcode-cn.com/problems/largest-number)。



<h1 style='page-break-before: always;'>1.6.6 和为s的两个数字</h1>

## 1 题目

输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。

**示例 1：**

```txt
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**示例 2：**

```txt
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```

**限制：**

* 1 <= nums.length <= 10^5
* 1 <= nums[i] <= 10^6

## 2 问题分析

1. 本题**利用 `HashMap` 可以通过遍历数组找到数字组合**，**时间和空间复杂度均为 $O(N)$**，因为**本题的 $nums$ 是排序数组**，**因此可使用双指针法将空间复杂度降低至 $O(1)$**。
2. 具体的算法流程如下：
   1. **初始化**：

      1. **双指针 $i, j$ 分别指向数组 $nums$ 的左右两端**。
   2. **循环搜索**：

      1. **计算和 $s = nums[i] + nums[j]$**。
      2. **比较 $s$ 和 $target$ 的值**：
         1. **若 $s \lt target$**，**则指针 $i$ 向右移动**，**即 $i++$**。
         2. **若 $s \gt target$**，**则指针 $j$ 向左移动**，**即 $j--$**。
         3. **若 $s = target$**，**则返回数组 $[nums[i], nums[j]]$**。
      3. **返回空数组**，**代表无和为 $target$ 的数字组合**。

      ![](../../media/202206/2022-06-03_151853_433534.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 57. 和为 s 的两个数字
 * @param nums  递增排序树组
 * @param target    目标和
 * @return  和为 target 的两个数字
 */
public int[] twoSum(int[] nums, int target) {
    int i = 0, j = nums.length - 1;
    while (i < j) {
        int s = nums[i] + nums[j];
        if (s < target) {i++;}
        else if (s > target) {j--;}
        else if (s == target) {return new int[]{nums[i], nums[j]};}
    }
    return new int[]{};
}
```

## 4 扩展题目

### 4.1 [和为 s 的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof)

#### 4.1.1 问题分析

1. **滑动窗口可以看成数组中框起来的一部分**，**在一些数组类题目中**，**我们可以用滑动窗口来观察可能的候选结果**，**当滑动窗口从数组的左边滑到了右边**，**我们就可以从所有的候选结果中找到最优的结果**。
2. **对于这道题来说**，**数组就是正整数序列**$[1, 2, 3,..., n]$，**我们设滑动窗口的左边界为 $i$**，**右边界为 $j$**，**则滑动窗口框起来的是一个左闭右闭区间 $[i, j]$**：
   1. **在一开始**，$i = 1, j = 1$，**滑动窗口位于序列的最左侧**，**窗口大小为 0**。
   2. **然后比较滑动窗口中所有数的和 $sum$ 和目标和 $sum$ 的大小**：
      1. **如果 $sum \lt target$**，**滑动窗口的右边界向右移动**，**即 $j++$**，**此时窗口中多了一个数字 $j$**，**窗口的和 $sum$ 也要加上 $j$**。
      2. **如果 $sum \gt target$**，**滑动窗口的左边界向右移动**，**即 $i++$**，**此时窗口中少了一个数字 $i$**，**窗口的和 $sum$ 也要减去 $i$**。
      3. **如果 $sum = target$**，**我们需要记录此时的结果**，**然后将窗口的右边界向右移动**。

         ![](../../media/202206/2022-06-03_151942_977167.png)

#### 4.1.2 参考代码

```java
/**
 * 剑指 Offer 57 - II. 和为 s 的连续正数序列
 * @param target    目标和
 * @return  所有和为 target 的连续正整数序列
 */
public int[][] findContinuousSequence(int target) {
    //  滑动窗口的左右边界及滑动窗口内的元素和
    int i = 1, j = 1, sum = 1;
    List<int[]> res = new ArrayList<>();

    while (i <= target / 2) {
        if (sum < target) {
            //  如果滑动窗口内的元素和小于目标和，则将右边界向右滑动，同时将滑动窗口内的元素和加上新添加的右边界元素
            j++;
            sum += j;
        }
        else if (sum > target) {
            //  如果滑动窗口内的元素和大于目标和，则将滑动窗口内的元素和减去要移除的左边界元素，同时将左边界向右滑动
            sum -= i;
            i++;
        }
        else if (sum == target) {
            //  如果滑动窗口内的元素和等于目标和，则将滑动窗口内的元素放到数组中，然后合并到最终结果中
            int[] tmp = new int[j - i + 1];
            for (int k = i; k <= j; k++) {
                tmp[k - i] = k;
            }
            res.add(tmp);
            j++;
            sum += j;
        }
    }

    //  将最终结果变换后返回
    return res.toArray(new int[res.size()][]);
}
```

## 参考文献

1. [剑指 Offer 57. 和为 s 的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof)。
2. [面试题 57. 和为 s 的两个数字（双指针 + 证明，清晰图解）](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-)。
3. [剑指 Offer 57 - II. 和为 s 的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof)。
4. [什么是滑动窗口，以及如何用滑动窗口解这道题（C++/Java/Python）](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h)。



<h1 style='page-break-before: always;'>1.6.7 构建乘积数组</h1>

## 1 题目

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

**示例:**

```txt
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

**提示：**

* 所有元素乘积之和不会溢出 32 位整数
* a.length <= 100000

## 2 问题分析

1. 本题的难点在于**不能使用除法**，**即需要只用乘法生成数组 $B$**，根据题目对 $B[0]$ 的定义，可列表格，如下图所示：

   ![Picture1.png](/media/202202/2022-02-12_2019200.9463664101953027.png)
2. **根据表格的主对角线**，**可将表格分为上三角和下三角两部分**，**分别迭代计算下三角和上三角两部分的乘积**，**即可不使用除法就获得结果**。
3. 具体的算法流程如下：

   1. **初始化数组 $B$**，**其中 $B[0] = 1$**，**辅助变量 $tmp = 1$**。
   2. **计算 $B[i]$ 的下三角各元素的乘积**，**直接乘入 $B[i]$**。
   3. **计算 $B[i]$ 的上三角各元素的乘积**，**记为 $tmp$**，**并乘入 $B[i]$**。
   4. **返回 $B$**。
4. 具体实例如下：

   ![](../../media/202202/2022-02-12_2025230.5272470853708524.png)

   ![](../../media/202202/2022-02-12_2025320.10326173710311681.png)

   ![](../../media/202202/2022-02-12_2025410.18310975695976917.png)

   ![](../../media/202202/2022-02-12_2025550.7393083412792657.png)

   ![](../../media/202202/2022-02-12_2026050.4833823810572384.png)

   ![](../../media/202202/2022-02-12_2026130.48557956469393615.png)

   ![](../../media/202202/2022-02-12_2026210.7118277981678661.png)

   ![](../../media/202202/2022-02-12_2026280.31684487445222287.png)

   ![](../../media/202202/2022-02-12_2026380.9920881939848459.png)

   ![](../../media/202202/2022-02-12_2026450.7798305326990969.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 66. 构建乘积数组
 * @param a 原始数组
 * @return  根据原始数组构建的乘积数组
 */
public int[] constructArr(int[] a) {
    int len = a.length, tmp = 1;
    int[] res = new int[len];

    Arrays.fill(res, 1);

    //  计算下三角各元素的乘积
    for (int i = 1; i < len; i++) {
        res[i] = res[i - 1] * a[i - 1];
    }

    //  计算上三角各元素的乘积
    for (int i = len - 2; i >= 0; i--) {
        tmp *= a[i + 1];
        res[i] *= tmp;
    }

    return res;
}
```

## 参考文献

1. [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof)。
2. [ 剑指 Offer 66. 构建乘积数组（表格分区，清晰图解）](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe)。



<h1 style='page-break-before: always;'>1.6.8 两数之和</h1>

## 1 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```txt
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```txt
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```txt
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

* 2 <= nums.length <= 103
* -109 <= nums[i] <= 109
* -109 <= target <= 109
* 只会存在一个有效答案

## 2 解题思路

### 2.1 问题解析

1. HashMap 的基本思想是**当判断一个数组中是否存在两个数的和为目标值时，可以通过判断数组中是否存在和目标元素-当前元素的值**。
2. 因此我们可以通过**Hash 映射**的方法，其中 $key$ 为元素值，$value$ 为其对应的数组下表，从而减少查找的次数。

### 2.2 参考代码

```java
/**
 * 1. 两数之和
 * @param nums  数组
 * @param target    目标值
 * @return  和为目标值的两个整数的下标
 */
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    int len = nums.length;
    int[] res = new int[2];
    for (int i = 0; i < len; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i < len; i++) {
        int item = nums[i];
        if (map.containsKey(target - item) && map.get(target - item) != i) {
            res[0] = i;
            res[1] = map.get(target - item);
            return res;
        }
    }
    return res;
}
```

### 2.3 扩展题目

#### 2.3.1 元素未排序，包含重复元素，输出所有数对

##### 2.3.1.1 问题解析

1. 由于包含重复元素，所以我们需要对上面使用的哈希表进行修改：
   1. **$key$依然是数组中的元素**，$value$**改为对应元素在数组中的索引队列**。
2. 初始时将所有元素及其对应于数组中的索引队列存入哈希表中。
3. 在遍历数组中的元素时，假设当前元素为 $key$，$temp$ 为目标和 $target$ 与 $key$ 的差，即 $temp = target - key$，当满足以下情况时更新结果数组：
   1. **哈希表中包含**$temp$。
   2. $temp$**的索引队列不为空**。
   3. $key$**和**$temp$**的索引队列队顶元素不相等**（为了处理数组为[3]，目标和为 6 的情况）。
4. 注意事项：
   1. **结果数组赋值时元素对应的下标需要从索引队列中取**，**这样主要为了避免元素重复判断**：`res[index++] = new int[]{map.get(key).poll(), map.get(temp).poll()};`
   2. **如果当前元素已用完**，**则将其从哈希表中移除**：`if (map.get(temp).size() == 0) {map.remove(key);}`。

##### 2.3.1.2 参考代码

```java
/**
 * 1. 两数之和（包含重复元素，输出所有数对）
 * @param numbers   数组
 * @param target    目标和
 */
public static int[][] twoSum (int[] numbers, int target) {
    Map<Integer, Queue<Integer>> map = new HashMap<>(); //  key 为元素，value 为元素在数组中的索引队列
    int[][] res = new int[numbers.length / 2][];
    int index = 0;

    /**
     * 存储数组元素及其对应于数组中的索引队列
     */
    for (int i = 0; i < numbers.length; i++) {
        int key = numbers[i];
        Queue<Integer> queue = new LinkedList<>();
        if (!map.containsKey(key)) {queue = new LinkedList<>();} 
        else {queue = map.get(key);}
        queue.offer(i + 1);
        map.put(key, queue);
    }

    /**
     * 获取目标和为 target 的全部数对
     */
    for (int i = 0; i < numbers.length; i++) {
        int key = numbers[i];
        int temp = target - key;
        if (map.containsKey(temp) && map.get(temp).size() > 0 && map.get(key).peek() != map.get(temp).peek()) {
            //  map.get(key).peek() != map.get(temp).peek() 是为了处理 [3] target = 6 的特殊情况
            res[index++] = new int[]{map.get(key).poll(), map.get(temp).poll()};
            if (map.get(temp).size() == 0) {map.remove(key);}   //  如果当前元素已用完，则将其从 map 中移除
        }
    }
    return res;
}
```

#### 2.3.2 元素已排序，常量级额外空间

##### 2.3.2.1 问题解析

1. 因为元素已排序，所以可以考虑使用**二分法**查找目标和减去当前元素对应的元素。

##### 2.3.2.2 参考代码

```java
/**
 * 1. 两数之和（元素已排序，常量级额外空间）
 * @param numbers   数组
 * @param target    目标和
 */
public int[] twoSum(int[] numbers, int target) {
    for (int i = 0; i < numbers.length; i++) {
        int temp = search(numbers, target - numbers[i], i + 1, numbers.length - 1);
        if (temp != -1) {return new int[]{i + 1, temp + 1};}
    }
    return new int[2];
}

/**
 * 二分查找
 * @param numbers   数组
 * @param num   目标元素
 * @param _left 左边界
 * @param _right    右边界
 */
public int search(int[] numbers, int num, int _left, int _right) {
    int left = _left, right = _right;
    while (left <= right) {
        int mid = mid = left + (right - left) / 2;
        if (numbers[mid] < num) {left = mid + 1;}
        else if (numbers[mid] > num) {right = mid - 1;}
        else if (numbers[mid] == num) {return mid;}
    }
    return -1;
}
```

## 参考文献

1. [1. 两数之和](https://leetcode-cn.com/problems/two-sum)。



<h1 style='page-break-before: always;'>1.7 字符串</h1>

1.8 字符串




<h1 style='page-break-before: always;'>1.7.0 最小覆盖子串</h1>

## 1 题目

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

**注意：**

* 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
* 如果 s 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```txt
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```txt
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```txt
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

* 1 <= s.length, t.length <= 105
* s 和 t 由英文字母组成

**进阶：** 你能设计一个在 o(n) 时间内解决此问题的算法吗？

## 2 问题分析

1. 该题目可以采用**滑动窗口**来解决，基本思想为：

   1. **用 $i$，$j$ 表示滑动窗口的左边界和右边界**，**通过改变 $i$、$j$ 来扩展和收缩滑动窗口**，**可以想象成一个窗口在字符串上游走**，**当这个窗口包含的元素满足条件**，即**包含字符串 $T$ 的所有元素**，**记录下这个滑动窗口的长度 $j - i + 1$**，**这些长度中的最小值就是要求的结果**。
2. 具体的步骤如下：

   1. **步骤一：**
      1. **不断增加 $j$ 使滑动窗口增大**，**直到窗口包含了 $T$ 的所有元素**。
   2. **步骤二：**
      1. **不断增加 $i$ 使滑动窗口缩小**，因为是要求最小子串，所以**将不必要的元素排除在外**，**使长度减小**，**直到碰到一个必须包含的元素**，这个时候不能再扔了，再扔就不满足条件了，**记录此时滑动窗口的长度**，并**保存最小值**。
   3. **步骤三：**
      1. **让 $i$ 再增加一个位置**，这个时候**滑动窗口肯定不满足条件了**，那么**继续从步骤一开始执行**，**寻找新的满足条件的滑动窗口**，**如此反复**，**直到 $j$ 超出了字符串 $S$ 范围**。
3. 上面的步骤中会面临一个问题，那就是**如何判断滑动窗口包含了 $T$ 的所有元素**，这个问题可以通过如下的方式来解决：

   1. 我们**用一个字典 `need` 来表示当前滑动窗口所需的各元素数量**，**一开始滑动窗口为空**，**用 $T$ 中各元素来初始化这个 `need`**。
   2. **当滑动窗口扩展或者收缩的时候**，去**维护这个 `need` 字典**，例如：
      1. **当滑动窗口包含某个元素**，我们就**让 `need` 中这个元素的数量减 1**，代表**所需元素减少了 1 个**。
      2. **当滑动窗口移除某个元素**，就**让 `need` 中这个元素数量加 1**。
   3. 需要注意的是，**`need` 始终记录着当前滑动窗口下**，我们**还需要的元素数量**，我们**在改变 $i$、$j$ 时**，**需同步维护 `need`**。
   4. 同时，**只要某个元素包含在滑动窗口中**，我们**就会在 `need` 中存储这个元素的数量**，**如果某个元素存储的是负数**，**就代表这个元素是多余的**，比如当 `need` 等于 `{'A': -2, 'C': 1}` 时，表示当前滑动窗口中，我们有 2 个 `A` 是多余的，同时还需要 1 个 `C`，这么做的目的就是为了步骤二中排除不必要的元素，数量为负的就是不必要的元素，而数量为 0 表示刚刚好。
   5. 因此，**当 `need` 中所有元素的数量都小于等于 0 时**，**表示当前滑动窗口不再需要任何元素**。
4. 但是上面的方法存在一个问题，**如果每次判断滑动窗口是否包含了 $T$ 的所有元素**，**都去遍历 `need` 看是否所有元素数量都小于等于 0**，这个**会耗费 $O(k)$ 的时间复杂度**，其中 $k$ 代表字典长度，最坏情况下，$k$ 可能等于 $len(S)$。
5. 其实这个是可以避免的，我们**可以维护一个额外的变量 `needCnt` 来记录所需元素的总数量**，**当我们碰到一个所需元素 `c`**，**不仅 `need[c]` 的数量减少 1**，**同时 `needCnt` 也要减少 1**，这样我们**通过 `needCnt` 就可以知道是否满足条件**，而**无需遍历字典了**。
6. 具体示例如下，假设 `S = "DOABECODEBANC"`，`T = "ABC"`：

   ![](../../media/202206/2022-06-04_120626_183038.png)

## 3 参考代码

```java
/**
 * 76. 最小覆盖子串
 * @param s 第一个字符串
 * @param t 第二个字符串
 * @return  s 中涵盖 t 所有字符的最小子串
 */
public String minWindow(String s, String t) {
    //  起始位置以及两个字符串的长度
    int i = 0, j = 0, m = s.length(), n = t.length();
    //  当前滑动窗口中需要的各元素的数量
    Map<Character, Integer> need = new HashMap<>();
    //  所需元素的总数量，当给参数为 0 时说明滑动窗口中的元素包含了 t 中所有的元素，这样可以避免遍历 need 中的元素的值是否都小于等于 0
    int needCnt = n;
    //  最后的结果
    String res = "";

    //  对 need 中的元素进行初始化
    for (int k = 0; k < n; k++) {
        char key = t.charAt(k);
        if (!need.containsKey(key)) {need.put(key, 1);}
        else {
            int value = need.get(key);
            need.put(key, value + 1);
        }
    }

    while (i < m) {
        //  移动 j，使得滑动窗口中包含 t 中所有的元素
        while (needCnt > 0 && j < m) {
            char key = s.charAt(j);
            if (need.containsKey(key)) {
                need.put(key, need.get(key) - 1);
                if (need.get(key) >= 0) {needCnt--;}
            }
            j++;
        }

        //  移动 i，使得滑动窗口的起始位置为 t 中包含的元素，然后将 i 移动到下一个位置，进行下一次遍历
        while (i < m) {
            char key = s.charAt(i);
            if (need.containsKey(key)) {
                //  更新最后的结果，包含两种情况：
                //      1. res 为空，且 needCnt 为 0.
                //      2. res 不为空，且 此时滑动窗口的长度小于 res 的长度，且 needCnt 为 0
                if (((res == "") || (res != "" && j - i < res.length())) && needCnt == 0) {res = s.substring(i, j);}
                need.put(key, need.get(key) + 1);
                //  只有当当前 key 对应的值大于 0 时才说明滑动窗口中不包含该元素，此时才将 needCnt 加 1
                if (need.get(key) > 0) {
                    needCnt++;
                }
                i++;
                break;
            }
            i++;
        }
    }

    //  返回最后结果
    return res;
}
```

## 参考文献

1. [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)。
2. [简简单单，非常容易理解的滑动窗口思想](https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k)。



<h1 style='page-break-before: always;'>1.7.1 字符串相乘</h1>

## 1 题目

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```txt
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```txt
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明：**

1. num1 和 num2 的长度小于 110。
2. num1 和 num2 只包含数字 0-9。
3. num1 和 num2 均不以零开头，除非是数字 0 本身。
4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。

## 2 问题分析

1. 该算法是**通过两数相乘时**，**乘数某位与被乘数某位相乘**，**与产生结果的位置的规律来完成**，具体规律如下：
   1. **乘数 $num_1$位数为 $M$**，**被乘数$num_2$位数为 $N$**，$num_1 \times num_2$**结果$res$最大总位数为 $M + N$**。
   2. $num_1[i] \times num_2[j]$**的结果为$tmp$**（位数为两位，形如`0x`、`xy`），其中**第一位位于 $res[i + j]$**，**第二位位于$res[i + j + 1]$**。![](../../media/202111/2021-11-11_2206230.7681314149420733.png)

## 3 参考代码

```java
/**
 * 43. 字符串相乘
 * @param num1  字符串 1
 * @param num2  字符串 2
 * @return  两个字符串的乘积
 */
public String multiply(String num1, String num2) {
    if (num1.equals("0") || num2.equals("0")) {return "0";}

    //  两个长度分为为 m、n 的字符串相加后得到的结果的最大长度为 m + n
    int[] res = new int[num1.length() + num2.length()];
    for (int i = num1.length() - 1; i >= 0; i--) {
        int m = num1.charAt(i) - '0';
        for (int j = num2.length() - 1; j >= 0; j--) {
            int n = num2.charAt(j) - '0';
            int sum = res[i + j + 1] + m * n;
            //  num1.charAt(i) * num2.charAt(j) 的到的结果（以两位数来算，形如"0x"、"xy"）中，十位数为 res[i + j]，个位数为 res[i + j + 1]
            res[i + j] += sum / 10;
            res[i + j + 1] = sum % 10;
        }
    }

    StringBuilder result = new StringBuilder();
    for (int i = 0; i < res.length; i++) {
        //  如果第一位数为 0，则过滤掉
        if (i == 0 && res[i] == 0) {continue;}
        result.append(res[i]);
    }

    //  返回最后结果
    return result.toString();
}
```

## 参考文献

1. [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings)。
2. [优化版竖式(打败 99.4%)](https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean)。



<h1 style='page-break-before: always;'>1.7.2 比较版本号</h1>

## 1 题目

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：

* 如果 version1 > version2 返回 1，
* 如果 version1 < version2 返回 -1，
* 除此之外返回 0。

**示例 1：**

```txt
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
```

**示例 2：**

```txt
输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 "0"
```

**示例 3：**

```txt
输入：version1 = "0.1", version2 = "1.1"
输出：-1
解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2
```

**示例 4：**

```txt
输入：version1 = "1.0.1", version2 = "1"
输出：1
```

**示例 5：**

```txt
输入：version1 = "7.5.2.4", version2 = "7.5.3"
输出：-1
```

**提示：**

* 1 <= version1.length, version2.length <= 500
* version1 和 version2 仅包含数字和 '.'
* version1 和 version2 都是 有效版本号
* version1 和 version2 的所有修订号都可以存储在 32 位整数 中

## 2 问题分析

1. 针对该题目，我们可以采用**双指针**的方法来解决，具体思路如下：
   1. **定义两个指针 $i$ 和 $j$**，**初始化 $i = 0$**，$j = 0$**。**
   2. **两个指针分别遍历两个字符串**，**将每个小数点 `.` 分隔开的修订号解析成数字**，**并进行大小比较**（这样做**可以直接去前导 0**，同时**将字符串转换成数字也便于比较大小**）：
      1. **如果 $num1 \gt num2$**，**返回 1**。
      2. **如果 $num1 \lt num2$**，**返回-1**。
   3. $i++$、$j++$，**两个指针都后移一步**，**进行下一轮的修订号解析比较**。
   4. **如果遍历完两个字符串都没有返回相应结果**，**说明两个字符串相等**，**返回 0**。

## 3 参考代码

```java
/**
 * 165. 比较版本号
 * @param version1  版本号 1
 * @param version2  版本号 2
 * @return  两个版本号的比较结果
 */
public int compareVersion(String version1, String version2) {
    int m = version1.length(), n = version2.length();
    int i = 0, j = 0;

    while (i < m || j < n) {
        int num1 = 0, num2 = 0;
        while (i < m && version1.charAt(i) != '.') {num1 = num1 * 10 + version1.charAt(i++) - '0';}
        while (j < n && version2.charAt(j) != '.') {num2 = num2 * 10 + version2.charAt(j++) - '0';}
        if (num1 > num2) {return 1;}
        else if (num1 < num2) {return -1;}
        ++i;
        ++j;
    }

    return 0;
}
```

## 参考文献

1. [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers)。
2. [比较版本号 | 双指针算法超清晰讲解 【c++/java 版本】](https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-shuang-zhi-zhen-suan-bcv7)。



<h1 style='page-break-before: always;'>1.7.3 验证IP地址</h1>

## 1 题目

编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。

如果是有效的 IPv4 地址，返回 "IPv4" ；
如果是有效的 IPv6 地址，返回 "IPv6" ；
如果不是上述类型的 IP 地址，返回 "Neither" 。
IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；

同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。

IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address 地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。

同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。

**示例 1：**

```txt
输入：IP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"
```

**示例 2：**

```txt
输入：IP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
输出："IPv6"
解释：有效的 IPv6 地址，返回 "IPv6"
```

**示例 3：**

```txt
输入：IP = "256.256.256.256"
输出："Neither"
解释：既不是 IPv4 地址，又不是 IPv6 地址
```

**示例 4：**

```txt
输入：IP = "2001:0db8:85a3:0:0:8A2E:0370:7334:"
输出："Neither"
```

**示例 5：**

```txt
输入：IP = "1e1.4.5.6"
输出："Neither"
```

**提示：**

* IP 仅由英文字母，数字，字符 '.' 和 ':' 组成。

## 2 问题分析

1. **IPv4 判断标准**：
   1. **通过 `.` 分割后的长度必须为 4**。
   2. **每一段的长度必须在 1 到 3 之间**。
   3. **每一段的长度大于 1 时，不能包含前导 0**。
   4. **每一段都必须是数字**。
2. **IPv6 判断标准**：
   1. **通过 `:` 分割后的长度必须为 8**。
   2. **每一段的长度必须在 1 到 4 之间**。
   3. **每一段的字符都必须在 `0123456789abcdefABCDEF` 里面**。
3. 需要注意的是：
   1. `public String[] split(String regex, int limit)`：
      1. 该方法主要**根据匹配给定的正则表达式来拆分此字符串**。
      2. 该方法**返回的数组包含此字符串的子字符串**，**每个字符串都由另一个匹配给定表达式的子字符串终止**，**或者由此字符串末尾终止**，**数组中的子字符串按他们在此字符串中出现的顺序排列**，**如果表达式不匹配输入的任何部分**，**那么所得数组只具有一个元素**，**即此字符串**。
      3. `limit`参数**控制模式应用的次数**，因而**影响所得数组的长度**：
         1. **如果$limit \gt 0$**，则**模式最多被应用$limit - 1$次**，**数组的长度将不会大于$limit$**，而且**数组的最后一项将包含所有超出最后匹配的定界符的输入**。
         2. **如果$limit \lt 0$**，那么**模式将被应用尽可能多的次数**，而且**数组可以是任何长度**。
         3. **如果$limit = 0$**，那么**模式将被应用尽可能多的次数**，而且**数组可以是任何长度**，并且**结尾空字符串将被丢弃**。
      4. 具体实例如下：
         1. 假如有一个字符串`boo:and:foo`，使用这些参数可以生成以下结果：![](../../media/202111/2021-11-14_221925_952904.png)

## 3 参考代码

```java
/**
 * 468. 验证 IP 地址
 * @param queryIP   输入的字符串
 * @return  验证输入的字符串是否是有效的 IPv4 或 IPv6 地址
 */
public String validIPAddress(String queryIP) {
    if (queryIP.contains(".")) {return validateIPv4(queryIP);}
    else if (queryIP.contains(":")) {return validateIPv6(queryIP);}
    return "Neither";
}

/**
 * 验证输入的字符串是否是有效的 IPv4 地址
 * @param queryIP   输入的字符串
 * @return  验证输入的字符串是否是有效的 IPv4 地址
 */
public String validateIPv4(String queryIP) {
    String[] split = queryIP.split("\\.", -1);
    if (split.length != 4) {return "Neither";}
    for (String str: split) {
        if (str.length() == 0 || str.length() > 3) {return "Neither";}
        if (str.charAt(0) == '0' && str.length() != 1) {return "Neither";}
        for (char c: str.toCharArray()) {
            if (!Character.isDigit(c)) {return "Neither";}
        }
        if (Integer.parseInt(str) > 255) {return "Neither";}
    }
    return "IPv4";
}

/**
 * 验证输入的字符串是否是有效的 IPv6 地址
 * @param queryIP   输入的字符串
 * @return  验证输入的字符串是否是有效的 IPv6 地址
 */
public String validateIPv6(String queryIP) {
    String[] split = queryIP.split(":", -1);
    String hexdigits = "0123456789abcdefABCDEF";
    if (split.length != 8) {return "Neither";}
    for (String str: split) {
        if (str.length() == 0 || str.length() > 4) {return "Neither";}
        for (char c: str.toCharArray()) {
            if (hexdigits.indexOf(c) == -1) {return "Neither";}
        }
    }
    return "IPv6";
}
```

## 参考文献

1. [468. 验证 IP 地址](https://leetcode-cn.com/problems/validate-ip-address)。
2. [验证 IP 地址](https://leetcode-cn.com/problems/validate-ip-address/solution/yan-zheng-ip-di-zhi-by-leetcode)。



<h1 style='page-break-before: always;'>1.7.4 基本计算器 II</h1>

## 1 题目

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

**示例 1：**

```txt
输入：s = "3+2*2"
输出：7
```

**示例 2：**

```txt
输入：s = " 3/2 "
输出：1
```

**示例 3：**

```txt
输入：s = " 3+5 / 2 "
输出：5
```

**提示：**

* 1 <= s.length <= 3 * 105
* s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
* s 表示一个 有效表达式
* 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
* 题目数据保证答案是一个 32-bit 整数
* 通过次数 90,862 提交次数 207,522

> 类似的题目还有：
>
> 1. [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator)。

## 2 问题分析

1. 对于【任何表达式】而言，我们**都使用两个栈** `nums`**和 `ops`**：
   1. `nums`：**存放所有的数字**。
   2. `ops`：**存放所有的数字以外的操作**。
2. 然后**从前往后做**，**对遍历到的字符做分情况讨论**：
   1. **空格**：**跳过**。
   2. `(`：**直接加入 `ops` 中**，**等待与之匹配的 `)`**。
   3. `)`：**使用现有的 `nums` 和 `ops` 进行计算**，**直到遇到左边最近的一个左括号为止**，**计算结果放到 `nums`**。
   4. **数字**：**从当前位置开始继续往后取**，**将一个连续数字整体取出**，**加入 `nums`**。
   5. `+ - * / ^ %`：**需要将操作放入 `ops` 中**，**在放入之前先把栈内可以算的都算掉**（**只有【栈内运算符】比【当前运算符】优先级高/同等**，**才进行运算**），**使用现有的 `nums` 和 `ops` 进行计算**，**直到没有操作或者遇到左括号**，**计算结果放到 `nums`**。
3. 【栈内运算符】比【当前运算符】优先级高/同等，才进行运算的含义：
   1. 因为我们是**从前往后做的**，假设我们**当前已经扫描到 `2 + 1` 了**，此时**栈内的操作为 `+`**：
      1. **如果后面出现的 `+ 2` 或者 `- 1` 的话**，**满足【栈内运算符】比【当前运算符】优先级高/同等**，**可以将 `2 + 1` 算掉**，**把结果放到 `nums` 中**。
      2. **如果后面出现的是 `* 2` 或者 `/ 1` 的话**，**不满足【栈内运算符】比【当前运算符】优先级高/同等**，**这时候不能计算 `2 + 1`**。
4. 一些细节：
   1. **由于第一个数可能是负数**，**为了减少边界判断**，**一个小技巧是先往 `nums` 添加一个 0**。
   2. **为防止 `()` 内出现的首个字符为运算符**，**将所有的空格去掉**，**并将 `(-` 替换为 `(0-`**，`(+`**替换为 `(0+`**。
   3. **从理论上分析**，`nums`**最好存放的是 `long`**，**而不是 `int`**，**因为可能存在 `大数 + 大数 + 大数 + ... - 大数 - 大数` 的表达式导致中间结果溢出**，**最终答案不溢出的情况**。

## 3 参考代码

```java
Map<Character, Integer> map = new HashMap() {{
        put('+', 1);
        put('-', 1);
        put('*', 2);
        put('/', 2);
        put('%', 2);
        put('^', 3);
    }};

    /**
     * 227. 基本计算器 II
     * @param s 字符串
     * @return  字符串表达式计算后返回的值
     */
    public int calculate(String s) {
        //  将所有的空格去掉
        s = s.replaceAll(" ", "");
        char[] cs = s.toCharArray();
        int n = s.length();
        //  存放所有的数字
        Deque<Integer> nums = new ArrayDeque<>();
        //  为了防止第一个数为负数，先往 nums 加个 0
        nums.addLast(0);
        //  存放所有【非数字以外】的操作
        Deque<Character> ops = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = cs[i];
            if (c == '(') {ops.addLast(c);}
            else if (c == ')') {
                while (!ops.isEmpty()) {
                    if (ops.peekLast() != '(') {calc(nums, ops);}
                    else {
                        ops.pollLast();
                        break;
                    }
                }
            } else {
                if (isNumber(c)) {
                    int u = 0, j = i;
                    //  将从 i 开始后面的连续数字整体取出，加入 nums
                    while (j < n && isNumber(cs[j])) {u = u * 10 + (cs[j++] - '0');}
                    nums.addLast(u);
                    i = j - 1;
                } else {
                    if (i > 0 && (cs[i - 1] == '(' || cs[i - 1] == '+' || cs[i - 1] == '-')) {nums.addLast(0);}
                    //  有一个新操作要入栈时，先把栈内可以算的都算了
                    //  只有满足【栈内运算符】比【当前运算符】优先级高/同等，才进行运算
                    while (!ops.isEmpty() && ops.peekLast() != '(') {
                        char prev = ops.peekLast();
                        if (map.get(prev) >= map.get(c)) {calc(nums, ops);}
                        else {break;}
                    }
                    ops.addLast(c);
                }
            }
        }

        //  将剩余的计算完
        while (!ops.isEmpty()) {calc(nums, ops);}

        //  返回最后的计算结果
        return nums.peekLast();
    }

    /**
     * 模拟计算器计算
     * @param nums  数值队列
     * @param ops   操作队列
     */
    void calc(Deque<Integer> nums, Deque<Character> ops) {
        if (nums.isEmpty() || nums.size() < 2) {return;}
        if (ops.isEmpty()) {return;}
        int b = nums.pollLast(), a = nums.pollLast();
        char op = ops.pollLast();
        int ans = 0;

        if (op == '+') {ans = a + b;}
        else if (op == '-') {ans = a - b;}
        else if (op == '*') {ans = a * b;}
        else if (op == '/') {ans = a / b;}
        else if (op == '%') {ans = a % b;}
        else if (op == '^') {ans = (int) Math.pow(a, b);}

        nums.addLast(ans);
    }

    /**
     * 判断一个字符是否是数字
     * @param c 字符
     * @return  字符是否是数字
     */
    boolean isNumber(char c) {return Character.isDigit(c);}
```

## 参考文献

1. [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii)。
2. [【宫水三叶】使用「双栈」解决「究极表达式计算」问题](https://leetcode-cn.com/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k)。
3. [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator)。



<h1 style='page-break-before: always;'>1.7.5 字符串解码</h1>

## 1 题目

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

**示例 1：**

```txt
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```txt
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```txt
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```txt
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

## 2 问题分析

1. **构建两个辅助栈 $lastMultiStack$**、$lastResStack$，**分别用于临时存放 `[` 前的遍历的倍数和结果**。
2. **遍历字符串 $s$ 中的每个字符 $c$**：

   1. **当 $c$ 为数字时**：

      1. **将数字字符转化为数字 $multi$**，**用于后续倍数计算**。

         ![](../../media/202206/2022-06-07_153357_250179.png)
   2. **当 $c$ 为字母时**：

      1. **在 $res$ 尾部添加 $c$**。

         ![](../../media/202206/2022-06-07_153438_472342.png)
   3. **当 $c$ 为 `[` 时**：

      1. **记录此 `[` 前的临时结果 $res$ 入栈**，**用于发现对应 `]` 后的拼接操作**。
      2. **记录此 `[` 前的倍数 $multi$ 入栈**，**用于发现对应 `]` 后**，**获取 $multi \times [\cdots]$ 字符串**。
      3. **将 $res$**、**$multi$ 分别置空置 0**。

         ![](../../media/202206/2022-06-07_153504_034646.png)
   4. **当 $c$ 为 `]` 时**：

      1. **$lastResStack$ 出栈**，**获取 $lastRes$**。
      2. **$lastMultiStack$ 出栈**，**获取 $currentMulti$**。
      3. **拼接字符串 $res = lastRes + currentMulti \times res$**。

         ![](../../media/202206/2022-06-07_153534_738665.png)
3. **返回字符串 $res$**。

   ![](../../media/202206/2022-06-07_153313_011567.gif)

## 3 参考代码

```java
/**
 * 394. 字符串解码
 * @param s 编码后的字符串
 * @return  解码后的字符串
 */
public String decodeString(String s) {
    //  最后结果
    StringBuilder res = new StringBuilder();
    //  数字栈
    LinkedList<Integer> lastMultiStack = new LinkedList<>();
    //  临时结果栈
    LinkedList<String> lastResStack = new LinkedList<>();
    //  临时数字
    int multi = 0;

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '[') {
            /**
             * 如果当前字符为 [，则：
             *  1. 将当前 multi 和 res 入栈。
             *  2. 分别将 multi、res 置空置 0
             */
            lastMultiStack.addLast(multi);
            lastResStack.addLast(res.toString());
            multi = 0;
            res = new StringBuilder();
        } else if (c == ']') {
            /**
             * 如果当前字符为 ]，则：
             *  1. lastResStack 出栈，获取 lastRes。
             *  2. lastMultiStack 出栈，获取 currentMulti。
             *  3. res = lastRes + currentMulti * res
             */
            String lastRes = lastResStack.removeLast();
            StringBuilder tmp = new StringBuilder();
            int currentMulti = lastMultiStack.removeLast();
            for (int j = 0; j < currentMulti; j++) {tmp.append(res);}
            res = new StringBuilder(lastRes + tmp);
        } else if (c >= '0' && c <= '9') {
            /**
             * 如果当前字符为数字，则：
             *  1. 将数字字符转化为数字 multi
             */
            multi = multi * 10 + c - '0';
        }
        else {
            /**
             * 如果当前字符为字母，则：
             *  1. 在 res 尾部添加 c
             */
            res.append(c);
        }
    }
    //  返回最后的结果
    return res.toString();
}
```

## 参考文献

1. [394. 字符串解码](https://leetcode-cn.com/problems/decode-string)。
2. [字符串解码（辅助栈法 / 递归法，清晰图解）](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd)。



<h1 style='page-break-before: always;'>1.7.6 移掉 K 位数字</h1>

## 1 题目

给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
**示例 1 ：**

```txt
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

**示例 2 ：**

```txt
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**示例 3 ：**

```txt
输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。
```

**提示：**

* 1 <= k <= num.length <= 105
* num 仅由若干位数字（0 - 9）组成
* 除了 0 本身之外，num 不含任何前导零

## 2 问题分析

1. 这道题让我们**从一个字符串数字中删除 $k$ 个数字**，**使得剩下的数最小**，其中一个思路是：

   1. **从左到右遍历**。
   2. **对于遍历到的元素**，**我们选择保留**。
   3. **但是我们可以选择性丢弃前面相邻的元素**，**丢弃与否的依据是**：

      1. 对于两个数 123a456 和 123b456，如果 $a \gt b$，那么数字 123a456 大于数字 123b456，否则数字 123a456 小于等于数字 123b456。
      2. 也就是说，两个相同位数的数字大小关系取决于第一个不同的数的大小。
   4. 具体过程如下：

      1. 假如 $num = 1432219$，$k = 3$。
      2. 开始的时候遍历到的元素是 1，由于没有左侧相邻元素，因此没办法丢弃。

         ![](../../media/202206/2022-06-09_161031_494584.png)
      3. 接下来遍历到的是 4，由于 4 比左侧相邻的 1 大，如果选择丢弃左侧的 1，那么会使得剩下的数字更大，因此我们仍然选择不丢弃。

         ![](../../media/202206/2022-06-09_161059_488014.png)

         ![](../../media/202206/2022-06-09_161254_964943.png)
      4. 接下来遍历到的元素是 3，由于 3 比左侧相邻的 4 小，如果选择丢弃左侧的 4，那么会使得剩下的数字更小，因此我们选择丢弃。

      ![](../../media/202206/2022-06-09_161341_107625.png)

      ![](../../media/202206/2022-06-09_161349_030894.png)

      ![](../../media/202206/2022-06-09_161401_918565.png)

      ![](../../media/202206/2022-06-09_161410_717517.png)
      6. 后面的思路类似，我们就不继续分析了。
   5. 然而需要注意的是，**如果给定的数字是一个单调递增的数字**，**那么我们的算法会永远选择不丢弃**，与题目中要求的永远确保丢弃 $k$ 个相矛盾，一个简单的思路就是：

      1. **每丢弃一次**，$k$**减去 1**，**当 $k$ 减到 0**，**我们可以提前终止遍历**。
      2. **当遍历完成**，**如果 $k$ 仍然大于 0**，**假设最终还剩下 $x$ 个需要丢弃**，**那么我们需要选择删除末尾 $x$ 个元素**。
   6. 上面的思路可行，但是稍显复杂，我们需要把思路逆转过来，**刚才我们的关注点一直是丢弃**，**题目要求我们丢弃 $k$ 个元素**，反过来说，就是**让我们保留 $n - k$ 个元素**，**其中 $n$ 为数字长度**，那么我们只需要**按照上面的方法遍历完成后**，**再截取前 $n - k$ 个元素即可**。
   7. **按照上面的思路**，**我们来选择数据结构**，**由于我们需要保留和丢弃相邻的元素**，**因此使用栈这种在一端进行添加和删除的数据结构**。

   ![](../../media/202206/2022-06-09_161730_605002.gif)

## 3 参考代码

```java
/**
 * 402. 移掉 K 位数字
 * @param num   字符串表示的非负整数
 * @param k 移除数字的个数
 * @return  移除指定个数后的最小数字
 */
public String removeKdigits(String num, int k) {
    //  存储未移除的数字
    Stack<Integer> stack = new Stack<>();
    //  存储栈中未移除的数字
    StringBuilder sb = new StringBuilder();
    //  最后保留的数字的个数
    int remain = num.length() - k;
    //  最后结果
    String res;

    for (int i = 0; i < num.length(); i++) {
        int item = num.charAt(i) - '0';
        while (k > 0 && stack.size() > 0 && stack.peek() > item) {
            //  将栈中大于当前数字的数字移除
            stack.pop();
            //  k 减 1
            k--;
        }
        stack.push(item);
    }
    //  获取最后结果
    while (stack.size() > 0) {
        sb.append(stack.pop());
    }
    //  replaceFirst("^0*", "") 表示去除数字的前导 0
    res = sb.reverse().substring(0, remain).replaceFirst("^0*", "");

    //  返回最后结果
    return res.equals("") ? "0" : res;
}
```

## 4 相关题目

### 4.1 [去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters)

#### 4.1.1 题目

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

**示例 1：**

```txt
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```txt
输入：s = "cbacdcbc"
输出："acdb"
```

**提示：**

* 1 <= s.length <= 104
* s 由小写英文字母组成

#### 4.1.2 问题分析

1. 与[移掉 K 位数字](#2-问题分析)不同，这道题没有一个全局的删除次数 $k$，而是**对于每一个在字符串 $s$ 中出现的字母 $c$ 都有一个 $k$ 值**，**这个 $k$ 是 $c$ 出现的次数减 1**。
2. 沿用上面的知识，我们要做的就是**计算每一个字符的 $k$**，具体的算法如下：
   1. **建立一个字典**，**其中 $k$ 为字符 $c$**，$value$**为其出现的剩余次数**。
   2. **从左往右遍历字符串**，**每次遍历到一个字符**，**其剩余出现次数减 1**。
   3. **对于每一个字符**，**如果其对应的剩余出现次数大于 1**，**我们可以选择丢弃**，**否则不可以丢弃**。
   4. **是否丢弃的标准和[上面题目](#2-问题分析)类似**，**如果栈中相邻的元素字典序更大**，**那么我们选择丢弃相邻的栈中的元素**。

      ![](../../media/202206/2022-06-09_174914_549301.gif)

#### 4.1.3 参考代码

```java
/**
 * 316. 去除重复字母
 * @param s 源字符串
 * @return  去除重复字母且返回结果的字典序最小的字符串
 */
public String removeDuplicateLetters(String s) {
    //  字符与其对应出现的剩余次数的映射
    HashMap<Character, Integer> map = new HashMap<>();
    //  字符是否在最后结果中出现
    HashSet<Character> seen = new HashSet<>();
    //  存储临时结果
    Stack<Character> stack = new Stack<>();
    //  存储栈中反转后的结果
    StringBuilder sb = new StringBuilder();
    //  最后结果
    String res;

    //  遍历字符串，获取字符与其对应出现的剩余次数的映射
    for (int i = 0; i < s.length(); i++) {
        char item = s.charAt(i);
        if (!map.containsKey(item)) {map.put(item, 1);}
        else {map.put(item, map.get(item) + 1);}
    }

    for (int i = 0; i < s.length(); i++) {
        char item = s.charAt(i);
        if (!seen.contains(item)) {
            //  当前字符未出现在 stack 中
            while (stack.size() > 0 && stack.peek() > item && map.get(stack.peek()) > 0) {
                //  将栈中剩余出现次数大于 0 且 大于当前字符的元素移除
                char temp = stack.pop();
                seen.remove(temp);
            }
            //  将当前字符添加到 seen 中
            seen.add(item);
            //  将当前字符添加到 stack 中
            stack.push(item);
        }
        //  将当前字符的剩余出现次数减 1
        map.put(item, map.get(item) - 1);
    }

    //  获取最后结果
    while (stack.size() > 0) {
        sb.append(stack.pop());
    }
    res = sb.reverse().toString();

    //  返回最后结果
    return res;
}
```

### 4.2 [拼接最大数](https://leetcode-cn.com/problems/create-maximum-number)

#### 4.2.1 问题分析

1. 和[移掉 K 位数字](#2-问题分析)类似，只不过这一次是**两个数组**，而不是一个，并且是**求最大数**。
2. **最大最小是无关紧要的**，**关键在于是两个数组**，**并且要求从两个数组选取的元素个数加起来一共是 $k$**。
3. 然而**在一个数组中取 $k$ 个数字**，**并保持最小**，我们已经会了，但是如果问题扩展到两个，会有什么变化呢，实际上，问题本质并没有发生变化：
   1. 假设我们从 $nums_1$ 中取了 $k_1$ 个，从 $nums_2$ 中取了 $k_2$ 个，其中 $k_1 + k_2 = k$。
   2. 而 $k_1、k_2$ 这两个子问题我们是会解决的，由于这两个问题是相互独立的，因此我们只需要**分别求解**，**然后将结果合并**即可。
   3. 以题目中的 $nums_1 = [3, 4, 5, 6] \space nums_2 = [9, 1, 2, 5, 8, 3] \space k = 5$ 为例：
      1. 假如我们从 $nums_1$ 中取出 1 个数字，那么就要从 $nums_2$ 中取出 4 个数字。
      2. 运用[移掉 K 位数字](#2-问题分析)中的方法，我们计算出应该取 $nums_1$ 中的 $[6]$，并取 $nums_2$ 中的 $[9, 5, 8, 3]$。
      3. 如何将 $[6]$ 和 $[9, 5, 8, 3]$ 合并，使得数字尽可能大，并且保持相对位置不变呢，实际上这个过程有点类似[归并排序](https://notebook.ricear.com/project-21/doc-872/#7-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)中的治，而上面我们分别计算 $nums_1$ 和 $nums_2$ 的最大数的过程类似[归并排序](https://notebook.ricear.com/project-21/doc-872/#7-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)中的分。

         ![](../../media/202202/2022-02-07_2219140.1347819552753512.png)

## 参考文献

1. [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits)。
2. [一招吃遍力扣四道题，妈妈再也不用担心我被套路啦 ～](https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5)。
3. [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters)。
4. [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number)。



<h1 style='page-break-before: always;'>1.7.7 无重复字符的最长子串</h1>

## 1 题目

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

```txt
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```txt
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```txt
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```txt
输入: s = ""
输出: 0
```

**提示：**

* 0 <= s.length <= 5 * 104
* s 由英文字母、数字、符号和空格组成

> 类似的题目还有：
>
> 1. [NC41 最长无重复子数组](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4)。

## 2 解题思路

### 2.1 滑动窗口

#### 2.1.1 问题解析

1. 定义一个窗口，窗口中的内容即为当前的不重复字串，其中窗口的左边界为 $left$，右边界为 $right$。
2. 定义一个 $Map$，里面存储每个元素的下标，用于判断元素是否存在。
3. 然后对元素进行遍历：

   1. 当遍历一个元素在窗口中已经存在时，将 $left$ 的值更新为 $max(left, map.get(key))$，例如下图中 $left$ 的值为 2，当前遍历元素 $b$ 在 $map$ 中的值为 4，而 4 大于 2，因此将 $left$ 的值更新为 4。

      ![](../../media/202206/2022-06-10_160518_352603.png)

      ![](../../media/202206/2022-06-10_160533_448801.png)
   2. 每遍历一个元素，$right$ 向右移动一位，同时计算当前不重复字串的最大长度 $max$，下图中 $right$ 与 $left$ 指针的距离为 2，$max$ 的值为 3，而 3 大于 2，因此此时 $max$ 的值不需要更新。

      ![](../../media/202206/2022-06-10_160726_616162.png)
   3. 然后更新 $map$ 中元素的下标，将下图中当前遍历元素 $b$ 在 $map$ 中的值更新为当前滑动窗口右边界的下标，即更新为 6。

      ![](../../media/202206/2022-06-10_160754_123158.png)
4. 当所有元素遍历完后，$max$ 的值即为不重复字串的最大长度。

   ![](../../media/202206/2022-06-10_160841_797032.gif)

#### 2.1.2 参考代码

```java
/**
 * 3. 无重复字符的最长子串（版本 1：滑动窗口）
 *
 * @param s 字符串
 * @return 无重复字符的最长子串
 */
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int len = s.length();
    int left = -1, right = left, max = 0, temp;
    for (int i = 0; i < len; i++) {
        char key = s.charAt(i);
        right = i;
        if (map.containsKey(key)) {
            left = Math.max(left, map.get(key));
        }
        temp = right == left ? 1 : right - left;
        max = Math.max(max, temp);
        map.put(key, i);
    }
    return max;
}
```

## 3 参考文献

1. [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)。
2. [无重复字符的最长子串『官方题解』](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2)。
3. [滑动窗口](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai)。
4. [NC41 最长无重复子数组](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4)。



<h1 style='page-break-before: always;'>1.7.8 第一个只出现一次的字符</h1>

## 1 题目

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**示例 1:**

```txt
输入：s = "abaccdeff"
输出：'b'
```

**示例 2:**

```txt
输入：s = ""
输出：' '
```

**限制：**

* 0 <= s 的长度 <= 50000

## 2 解题思路

> 本题考察**哈希表**的使用，下面主要介绍**哈希表**和**有序哈希表**两种解法，其中，**在字符串长度较大**、**重复字符很多时**，**有序哈希表解法理论上效率更高**。

### 2.1 哈希表

#### 2.1.1 问题分析

1. **遍历字符串 $s$**，**使用哈希表统计 $ 各字符数量是否 \gt 1$**。
2. **再遍历字符串 $s$**，**在哈希表中找到首个 $ 数量为 1 的字符 $**，**并返回**。

   ![Picture1.png](/media/202202/2022-02-10_1640530.3928294457202771.png)

#### 2.1.2 参考代码

```java
/**
 * 剑指 Offer 50. 第一个只出现一次的字符（版本 1：哈希表）
 * @param s 字符串
 * @return  字符串中第一个只出现一次的字符
 */
public char firstUniqCharV1(String s) {
    HashMap<Character, Boolean> map = new HashMap<>();

    for (char c: s.toCharArray()) {
        map.put(c, !map.containsKey(c));
    }

    for (char c: s.toCharArray()) {
        if (map.get(c)) {return c;}
    }

    return ' ';
}
```

### 2.2 有序哈希表

#### 2.2.1 问题分析

1. **在哈希表的基础上**，**有序哈希表中的键值对是按照插入顺序排序的**，**基于此**，**可通过遍历有序哈希表**，**实现搜索首个 $ 数量为 1 的字符 $**。
2. **哈希表是去重的**，**即哈希表中 $ 键值对数量 \le 字符串 s 的长度 $**，**因此**，**相比于[哈希表](#2-1-哈希表)**，**有序哈希表减少了第二轮遍历的循环次数**，**当字符串很长**（重复字符很多）**时**，**有序哈希表则效率更高**。

#### 2.2.2 参考代码

```java
/**
 * 剑指 Offer 50. 第一个只出现一次的字符（版本2：有序哈希表）
 * @param s 字符串
 * @return  字符串中第一个只出现一次的字符
 */
public char firstUniqCharV2(String s) {
    Map<Character, Boolean> map = new LinkedHashMap<>();

    for (char c: s.toCharArray()) {
        map.put(c, !map.containsKey(c));
    }

    for (Map.Entry<Character, Boolean> entry: map.entrySet()) {
        if (entry.getValue()) {return entry.getKey();}
    }

    return ' ';
}
```

## 参考文献

1. [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof)。
2. [面试题 50. 第一个只出现一次的字符（哈希表 / 有序哈希表，清晰图解）](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3)。



<h1 style='page-break-before: always;'>1.7.9 翻转字符串里的单词</h1>

## 1 题目

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

**说明：**

* 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
* 翻转后单词间应当仅用一个空格分隔。
* 翻转后的字符串中不应包含额外的空格。

**示例 1：**

```txt
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```txt
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**示例 3：**

```txt
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
```

**示例 4：**

```txt
输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
```

**示例 5：**

```txt
输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"
```

**提示：**

* 1 <= s.length <= 104
* s 包含英文大小写字母、数字和空格 ' '
* s 中 至少存在一个 单词

**进阶：**

* 请尝试使用 O(1) 额外空间复杂度的原地解法。

## 2 解题思路

### 2.1 解法一：栈

#### 2.1.1 问题分析

1. 该方法的基本思想是依次遍历字符串中的字符，然后截取每个单词，并将截取后的单词放到栈中。
2. 字符串遍历结束后，再依次遍历栈中的元素，并用 StringBuffer 以空格为分隔符将这些单词并接起来，最后直接返回即可。
   
   ![](../../media/202107/151-翻转字符串里的单词（解法一：栈）_1625841088.gif)

#### 2.1.2 参考代码

```java
/**
 * 151. 翻转字符串里的单词（版本 1：栈）
 *
 * @param s 字符串
 * @return 翻转后的字符串
 */
public String reverseWordsV1(String s) {
    //  截取每个单词的起始位置
    int start = 0, end = 0;
    //  判断单词的位置是否开始计数
    boolean isBegin = false;
    //  存储截取后的单词
    Stack<String> stack = new Stack<>();
    //  用于将栈中的单词转化为字符串
    StringBuffer sb = new StringBuffer();

    //  逐个遍历字符串中的每个字符，并截取相应的单词
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != ' ') {
            //  当前字符不是空字符
            if (isBegin) {
                //  已经开始对当前单词的位置进行计数，将对应的下标加 1
                end++;
            } else {
                //  开始对当前单词的位置进行计数，使用 start 记录当前单词的起始位置
                start = i;
                //  使用 end 记录当前单词的结束位置，其中 end 会一直累加，直到遇到空字符
                end = start + 1;
                //  标记开始对当前单词的位置进行计数
                isBegin = true;
            }
        } else {
            //  当前字符是空字符
            if (isBegin) {
                //  已经开始对当前单词的位置进行计数，现在遇到了空字符，因此需要停止对当前单词的位置进行计数，然后截取字符串中 [start, end) 之间的字符，这些字符便构成了当前单词
                stack.push(s.substring(start, end));
                //  标记停止对当前单词的位置进行计数
                isBegin = false;
            }
        }
    }
    //  如果整个字符串的最后一个不是空字符，那么如果没有这个判断就会导致最后一个单词漏记
    if (isBegin) {
        String temp = s.substring(start, end);
        stack.push(temp);
    }

    //  将栈中的单词组成一个翻转字符串
    while (stack.size() > 0) {
        sb.append(stack.pop());
        sb.append(" ");
    }
    //  将反转后的字符串返回（上面 sb 后面会多加一个空格，因此在返回字符串时需去掉 ）
    return sb.toString().substring(0, sb.length() - 1);
}
```

### 2.2 解法二：两次翻转

#### 2.2.1 问题分析

1. 该方法的基本思想是首先将字符串去除首尾的空格后进行翻转。
2. 然后遍历反转后的字符串，删除多余的空格，并将每个单词进行翻转。
3. 最后转换为字符串，直接返回即可。![](../../media/202107/151-翻转字符串里的单词（解法二：两次翻转）_1625841097.gif)

#### 2.2.2 参考代码

```java
/**
 * 翻转一个单词
 * @param sb    字符串
 * @param start 单词起始位置
 * @param end   单词结束位置加 1
 * @return  翻转相应单词后的字符串
 */
public StringBuilder reverseWord(StringBuilder sb, int start, int end) {
    for (int i = start; i < (start + end) / 2; i++) {
        char temp = sb.charAt(i);
        int symmetricalPosition = start + end - i - 1;
        sb.setCharAt(i, sb.charAt(symmetricalPosition));
        sb.setCharAt(symmetricalPosition, temp);
    }
    return sb;
}

/**
 * 151. 翻转字符串里的单词（版本 2：两次翻转）
 *
 * @param s 字符串
 * @return 翻转后的字符串
 */
public String reverseWordsV2(String s) {
    if (s == null || s.trim() == "") {return "";}
    //  去除字符串两边的空格
    StringBuilder sb = new StringBuilder(s.trim());
    //  将字符串翻转
    sb = sb.reverse();
    int len = sb.length();

    //  是否遇到空格
    boolean meetSpace = false;
    //  删除空格的数量
    int deleteSpaceCount = 0;
    //  要翻转的单词的起始位置
    int start = 0, end = 0;

    //  遍历字符串，删除空格，并将所有的单词翻转
    for (int i = 0; i < len; i++) {
        if (sb.charAt(i - deleteSpaceCount) == ' ') {
            //  遇到了一个空格
            if (!meetSpace) {
                //  在这个单词前面没有遇到空格，说明这是但此后面的第一个空格，直接将 [start, end) 之间的单词进行翻转即可（注：start 和 end 为更正后的位置，即减去了删除空格的长度）
                end = i - deleteSpaceCount;
                start = start - deleteSpaceCount;
                sb = reverseWord(sb, start, end);
                meetSpace = true;
            } else {
                //  在这个单词前面已经遇到了空格，说明这个空格是空格后面的空格，直接删掉即可
                sb = sb.deleteCharAt(i - deleteSpaceCount);
                deleteSpaceCount++;
                meetSpace = true;
            }
        } else {
            //  不是空格
            if (meetSpace) {
                //  单词前面遇到了空格，说明这个是单词的第一个字符，直接重置 start 的位置，然后标记为未遇到空格
                start = i;
                meetSpace = false;
            }
        }
    }
    if (!meetSpace) {
        //  最后一个单词后面没有遇到空格，直接将最后一个单词进行翻转即可
        end = len - deleteSpaceCount;
        sb = reverseWord(sb, start - deleteSpaceCount, end);
    }
    //  返回结果
    return sb.toString();
}
```

## 3 参考文献

1. [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string)。
2. [原地翻转字符串里的单词(空间复杂度为 O(1))](https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/yuan-di-fan-zhuan-zi-fu-chuan-li-de-dan-wbsaw)。




<h1 style='page-break-before: always;'>1.7.10 字符串转换整数 (atoi)</h1>

## 1 题目

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

* 读入字符串并丢弃无用的前导空格
* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
* 返回整数作为最终结果。

**注意：**

* 本题中的空白字符只包括空格字符 ' ' 。
* 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

**示例 1：**

```txt
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```

**示例 2：**

```txt
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```

**示例 3：**

```txt
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
```

**示例 4：**

```txt
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。
```

**示例 5：**

```txt
输入：s = "-91283472332"
输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。提示：0 <= s.length <= 200
s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成
```

## 2 解题思路

### 2.1 有限状态机

#### 2.1.1 含义

1. 有限状态机是一种用来进行**对象行为建模**的工具，其作用主要是**描述对象在他的生命周期内所经历的状态序列**，**以及如何响应来自外界的各种事件**。
2. 在计算机科学中，有限状态机被广泛用于**建模应用行为**、**硬件电路系统设计**、**软件工程**、**编译器**、**网络协议**、**计算机与语言的研究**，比如下图非常有名的 TCP 协议状态机：![](../../media/202107/2021-07-12_2119070.18551046937634952.png)
3. 我们在编程时实现相关业务逻辑时经常需要**处理各种事件和状态切换**，写各种 `switch/case` 和 `if/else`，所以我们其实可能一直都在跟有限状态机打交道，只是可能没有意识到。
4. 在处理一些**业务逻辑比较复杂**的需求时，可以先看看**是否适用于用一个有限状态机来描述**，如果可以**把业务模型抽象成一个有限状态机**，那么**代码逻辑就会特别清晰**，**结构特别规整**。
5. 状态机主要包括四个要素，分别是**现态**、**条件**、**动作**、**次态**，**现态和条件是因**，**动作和次态是果**，具体如下：
   1. **现态**：指**当前所处状态**。
   2. **条件**：又称**事件**，当**一个条件满足**时，就**会触发一个动作**，**或者执行一次状态的迁移**。
   3. **动作**：指**条件满足后执行的动作**，**动作执行完毕后**，**可以迁移到新的状态**，**也可以仍旧保持原状态**，动作**不是必需的**，当条件满足后，**也可以不执行任何动作**，**直接迁移到新状态**。
   4. **次态**：指**条件满足后要迁往的新状态**，次态是相对于现态而言的，**次态一旦被激活**，**就转变成新的现态了**。
6. 我们可以用**状态表**表示整个过程，如下图所示：![](../../media/202107/2021-07-12_2131210.030304143730127353.png)

#### 2.1.2 问题分析

1. 该题目如果要用 `if ... else` 或 `switch ... case` 来判断的话将会非常麻烦，而且情况我们可能也不会考虑的那么全面，因此有可能我们调试了很长时间还是无法提交通过。
2. 这时候我们可以采用一种叫做[有限状态机](#2-1-有限状态机)的方式来解决，具体的**状态表**如下表所示：

|           | " "   | +/-    | number    | other |
| --------- | ----- | ------ | --------- | ----- |
| start     | start | signed | in_number | end   |
| signed    | end   | end    | in_number | end   |
| in_number | end   | end    | in_number | end   |
| end       | end   | end    | end       | end   |

3. 下面以第一行为例说明一下上面表格表示的含义，最左边的 `start` 表示初始状态：
   1. 当遇到" "时，状态更新为 `start`。
   2. 当遇到 `+/-` 时，状态更新为 `signed`。
   3. 当遇到 `number` 时，状态更新为 `in_number`。
   4. 当遇到 `other` 时，状态更新为 `end`。
4. 因此可以**对字符串 $s$ 中的字符 $c$ 进行逐个遍历**，然后**根据字符的值确定当前状态 $state$**，然后**根据相应的状态完成相应的动作**，假设用 $ans$**表示最后的结果**，**初始值为 0**，$sign$**表示最后的结果的符号**，**1 表示正号**，**-1 表示负号**：
   1. 当 $state$ 为 `in_number` 时，说明当前字符 $c$ 为**数字**，则：
      1. `ans = 10 * ans + c - '0'`。
      2. `ans = (sign == 1 ? Math.min(ans, Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE))`。
   2. 当 $state$ 为 `signed` 时，表示当前字符 $c$ 为**符号**，则：
      1. `sign = (c == '-' ? -1 : 1)`。
5. 当**字符串遍历完成**后，直接返回**符号和结果的乘积**$sign * ans$ 即可。

#### 2.1.3 参考代码

```java
/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/7/12 20:41
 * @Description 字符串转换整数 (atoi)
 */
public class L8 {
    /**
     * 8. 字符串转换整数 (atoi)
     *
     * @param s 字符串
     * @return 字符串对应的整数
     */
    public int myAtoi(String s) {
        //  定义有限状态机
        Automaton automaton = new Automaton();
        for (int i = 0; i < s.length(); i++) {
            //  执行有限状态机中的方法，完成相应的状态转移
            automaton.get(s.charAt(i));
        }
        //  将符号和数值相乘，作为最后的结果返回
        return (int) (automaton.sign * automaton.ans);
    }

    /**
     * 有限状态机
     */
    class Automaton {
        public int sign = 1;    /*符号*/
        public long ans = 0;    /*数值*/
        private String state = "start"; /*状态*/
        private Map<String, String[]> table = new HashMap<String, String[]>() {
            {
                put("start", new String[]{"start", "signed", "in_number", "end"});
                put("signed", new String[]{"end", "end", "in_number", "end"});
                put("in_number", new String[]{"end", "end", "in_number", "end"});
                put("end", new String[]{"end", "end", "end", "end"});
            }
        };  /*状态表*/

        /**
         * 状态转移方法
         * @param c 当前字符
         */
        public void get(char c) {
            state = table.get(state)[get_col(c)];
            if ("in_number".equals(state)) {
                //  当前状态为数值，因此进行数值相应的计算
                ans = 10 * ans + c - '0';
                //  当 sign == 1 时，说明此时为正数，因此取 ans 和 Integer.MAX_VALUE 的最小值
                //  否则，说明此时为负数，因此取 ans 和 -Integer.MIN_VALUE 的最小值（现在求的只是数值大小，符号后面会统一加）
                ans = (sign == 1 ? Math.min(ans, Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE));
            } else if ("signed".equals(state)) {
                //  当前状态为符号，因此判断最后是否需要乘以 -1
                sign = (c == '-' ? -1 : 1);
            }
        }

        /**
         * 获取有限状态表中的状态
         * @param c 字符
         * @return  字符对应于有限状态表中的状态
         */
        public int get_col(char c) {
            if (c == ' ') {
                //  start
                return 0;
            } else if (c == '+' || c == '-') {
                //  signed
                return 1;
            } else if (Character.isDigit(c)) {
                //  in_number
                return 2;
            } else {
                //  end
                return 3;
            }
        }
    }
}
```

## 3 参考文献

1. [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi)。
2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-)。
3. [深入浅出理解有限状态机](https://zhuanlan.zhihu.com/p/46347732)。




<h1 style='page-break-before: always;'>1.8 栈</h1>

1.9 栈




<h1 style='page-break-before: always;'>1.8.0 最小栈</h1>

## 1 题目

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
**示例:**

```txt
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]输出：
[null,null,null,null,-3,null,0,-2]解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

* pop、top 和 getMin 操作总是在 非空栈 上调用。

## 2 解题思路

### 2.1 一个栈同时保存当前值和栈内最小值

#### 2.1.1 问题分析

1. 可以**用一个栈**，**这个栈同时保存的是每个数字 $x$ 进栈的时候的值与插入该值后的栈内最小值**，即**每次新元素 $x$ 入栈的时候保存一个元组**（Java 中没有元组的概念，但是可以使用字符串进行拼接，思路是一样的，为了叙述方便，下面统一用元组来叙述）。
2. **这个元祖是一个整体**，**同时进栈和出栈**，即**栈顶同时有值和栈内最小值**，此时各个函数的具体含义如下
   1. `top()`**函数是获取栈顶当前值**，即**栈顶元组的第一个值**。
   2. `getMin()` **函数是获取栈内最小值**，即**栈顶元组的第二个值**。
   3. `pop()`**函数是删除栈顶元组**。
3. **每次新元素入栈时**，**要求新的栈内最小值**，**需要比较当前新插入元素 $x$ 和当前栈内最小值**（即栈顶元组的第二个值）的大小：
   1. **当栈为空的时候**，**保存元祖** $(x, x)$。
   2. **当栈不为空的时候**，**保存元祖** $(x, min(此前栈内最小值), x)$。
4. **出栈的时候**，**直接删除栈顶元组即可**。

#### 2.1.2 参考代码

```java
/**
 * 方法一：一个栈同时保存当前值和栈内最小值
 */
class MinStack {

    Stack<String> stack;
    int index, minVal;

    public MinStack() {
        stack = new Stack<>();
        index = 0;
        minVal = Integer.MAX_VALUE;
    }

    public void push(int val) {
        if (stack.size() == 0) {
            //  如果当前栈为空，则最小值为当前要插入的元素
            minVal = val;
        } else {
            //  如果当前栈不为空，则最小值为栈顶元素中存储的最小值与当前要插入的元素之间的最小值
            minVal = Math.min(val, Integer.parseInt(stack.peek().split("_")[2]));
        }
        //  将拼接好的数据插入栈中，格式为 索引_要插入的元素_当前最小值
        stack.push(String.format("%s_%s_%s", index++, val, minVal));
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return Integer.parseInt(stack.peek().split("_")[1]);
    }

    public int getMin() {
        return Integer.parseInt(stack.peek().split("_")[2]);
    }
}
```

### 2.2 辅助栈

#### 2.2.1 问题分析

1. **辅助栈的基本原理是使用两个栈**，分别为 $stack$、$stack2$，其中 $stack$ **用于保存当前的元素**，$stack2$ **用于保存当前最小的元素**。
2. **当插入一个元素 $val$ 时**：
   1. **将 $val$ 插入 $stack$**。
   2. **如果 $stack2$ 不为空**，并且**当前插入的元素小于等于 $stack2$ 的栈顶元素**，则**将 $val$ 插入 $stack2$**。
3. **当删除一个元素时**，**将 $stack$ 进行 $pop$**，**如果 $stack$ 删除的元素和 $stack2$ 的栈顶元素一样**，**则将 $stack2$ 也进行 $pop$**。
4. **当需要获取栈顶元素时**，**直接返回 $stack.peek()$ 即可**。
5. **当需要获取最小元素时**，**直接返回 $stack2.peek()$**。

#### 2.2.2 参考代码

```java
/**
 * 方法二：辅助栈
 */
class MinStack {
    Stack<Integer> stack;
    Stack<Integer> stack2;
    public MinStack() {
        stack = new Stack<>();
        stack2 = new Stack<>();
    }
    public void push(int val) {
        stack.push(val);
        if (stack2.size() == 0 || val <= stack2.peek()) {
            //  如果 stack2 不为空，并且当前插入的元素小于等于 stack2 的栈顶元素，则将 val 插入 stack2
            stack2.push(val);
        }
    }
    public void pop() {
        int val = stack.pop();
        if (stack2.peek() == val) {
            //  如果 stack 删除的元素和 stack2 的栈顶元素一样，则将 stack2 也进行 pop
            stack2.pop();
        }
    }
    public int top() {
        return stack.peek();
    }
    public int getMin() {
        return stack2.peek();
    }
}
```

## 3 扩展题目

### 3.1 [队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof)

#### 3.1.1 问题分析

1. 如下图所示，我们考虑**构建一个递减列表来保存队列所有递减的元素**，**递减列表随着入队和出队操作实时更新**，**这样队列最大元素就始终对应递减列表的首元素**，**实现了以 $O(1)$ 时间复杂度获取最大值**。
2. **为了实现此递减列表**，**需要使用双向队列**，**假设队列已经有若干元素**：

   1. **当执行入队时**，**若入队一个比队列某些元素更大的数字 $x$**，**则为了保持此列表递减**，**需要将双向队列尾部所有小于 $x$ 的元素弹出**。
   2. **当执行出队时**，**若出队的元素是最大的元素**，**则双向队列需要同时将首元素出队**，**以保持队列和双向队列元素的一致性**。

      > **使用双向队列是因为维护递减列表需要元素队首弹出**、**队尾插入**、**队尾弹出操作皆为 $O(1)$ 时间复杂度**。
      >
3. 具体的函数设计如下：

   1. **初始化队列 $queue$**，**双向队列 $helper$**。

      ![](../../media/202206/2022-06-13_105043_201086.png)
   2. **最大值 `max_value()`**：

      1. **当双向队列 $helper$ 为空**，**则返回-1**。
      2. **否则**，**返回 $helper$ 首元素**。

      ![](../../media/202206/2022-06-13_105159_294886.png)
   3. **入队 `push_back()`**：

      1. **将元素 $value$ 入队 $queue$**。
      2. **将双向队列中队尾所有小于 $value$ 的元素弹出**（以保持 $helper$），**并将元素 $value$ 入队 $helper$**。

      ![](../../media/202206/2022-06-13_105243_947377.png)

      ![](../../media/202206/2022-06-13_105254_040460.png)

      ![](../../media/202206/2022-06-13_105303_856847.png)

      ![](../../media/202206/2022-06-13_105313_190196.png)

      ![](../../media/202206/2022-06-13_105321_893818.png)

      ![](../../media/202206/2022-06-13_105333_848594.png)
   4. **出队 `pop_front()`**：

      1. **若队列 $queue$ 为空**，**则直接返回-1**。
      2. **否则**，**将 $queue$ 首元素出队**。
      3. **若 $helper$ 首元素和 $queue$ 首元素相等**，**则将 $helper$ 首元素出队**（以保持两队列元素一致）。

      ![](../../media/202206/2022-06-13_105408_271440.png)

      ![](../../media/202206/2022-06-13_105428_782343.png)

      ![](../../media/202206/2022-06-13_105438_555110.png)

      ![](../../media/202206/2022-06-13_105448_085033.png)

      ![](../../media/202206/2022-06-13_105457_374648.png)

      ![](../../media/202206/2022-06-13_105534_043335.png)

      ![](../../media/202206/2022-06-13_105543_788476.png)

      ![](../../media/202206/2022-06-13_105553_304979.png)

      ![](../../media/202206/2022-06-13_105602_624825.png)

      ![](../../media/202206/2022-06-13_105612_539738.png)
4. 具体实例如下：

   ![](../../media/202206/2022-06-13_105652_720341.gif)

#### 3.1.2 参考代码

```java
/**
 * 剑指 Offer 59 - II. 队列的最大值
 */
class MaxQueue {

    Queue<Integer> queue;
    Deque<Integer> helper;

    public MaxQueue() {
        queue = new LinkedList<>();
        helper = new LinkedList<>();
    }

    public int max_value() {
        return helper.size() > 0 ? helper.peekFirst() : -1;
    }

    public void push_back(int value) {
        queue.add(value);
        while (helper.size() != 0 && helper.peekLast() < value) {
            helper.pollLast();
        }
        helper.add(value);
    }

    public int pop_front() {
        if (queue.size() == 0) {return -1;}
        int tmp = queue.poll();
        if (tmp == helper.peekFirst()) {
            helper.pollFirst();
        }
        return tmp;
    }
}
```

## 参考文献

1. [155. 最小栈](https://leetcode-cn.com/problems/min-stack)。
2. [一个栈同时保存当前值和栈内最小值](https://leetcode-cn.com/problems/min-stack/solution/zui-yi-dong-yi-ge-zhan-tong-shi-bao-cun-dang-qian-)。
3. [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof)。
4. [剑指 Offer 59 - II. 队列的最大值（单调双向队列，清晰图解）](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap)。



<h1 style='page-break-before: always;'>1.8.1 弹出序列</h1>

## 1 题目

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

**示例 1：**

```txt
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```txt
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

**提示：**

* 0 <= pushed.length == popped.length <= 1000
* 0 <= pushed[i], popped[i] < 1000
* pushed 是 popped 的排列。

## 2 问题分析

1. **考虑使用一个辅助栈**，**模拟压入/弹出操作的排列**，**根据是否模拟成功**，**即可得到结果**：

   1. **入栈操作**：**按照压栈序列的顺序执行**。
   2. **出栈操作**：**每次入栈后**，**循环判断 `栈顶元素 = 弹出序列的当前元素` 是否成立**，**将符合弹出序列顺序的栈顶元素全部弹出**。
      > 由于题目规定，**栈的所有数字均不相等**，因此**在循环入栈中**，**每个元素出栈的位置的可能性是唯一的**（若有重复数字，则具有多个可出栈的位置），因而，**在遇到 `栈顶元素 = 弹出序列的当前元素` 时就应该立即执行出栈**。
      >
2. 算法流程如下：

   1. **初始化**：辅助栈 $stack$，弹出序列的索引 $index$。

      ![](../../media/202206/2022-06-14_110221_872230.png)
   2. **遍历压栈序列**，各元素记为 $num$：

      1. 元素 $num$ 入栈。
      2. 循环出栈，若 $stack$ 的栈顶元素 = 弹出序列元素 $popped[index]$，则执行出栈与 $index++$。

      ![](../../media/202206/2022-06-14_110303_305790.png)

      ![](../../media/202206/2022-06-14_110315_645194.png)

      ![](../../media/202206/2022-06-14_110328_346122.png)

      ![](../../media/202206/2022-06-14_110338_984414.png)

      ![](../../media/202206/2022-06-14_110351_209550.png)

      ![](../../media/202206/2022-06-14_110415_874802.png)

      ![](../../media/202206/2022-06-14_110427_833572.png)

      ![](../../media/202206/2022-06-14_110438_865584.png)

      ![](../../media/202206/2022-06-14_110451_401869.png)
   3. **返回值**：若 $stack$ 为空，则此弹出序列合法。

      ![](../../media/202206/2022-06-14_110546_566231.gif)

## 3 参考代码

```java
/**
 * 剑指 Offer 31. 栈的压入、弹出序列
 * @param pushed    压入序列
 * @param popped    弹出序列
 * @return  弹出序列是否是压入序列对应栈的弹出序列
 */
public boolean validateStackSequences(int[] pushed, int[] popped) {
    Stack<Integer> stack = new Stack<>();
    int index = 0;

    for (int num: pushed) {
        stack.push(num);
        while (!stack.isEmpty() && stack.peek() == popped[index]) {
            stack.pop();
            index++;
        }
    }

    return stack.isEmpty();
}
```

## 参考文献

1. [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof)。
2. [面试题 31. 栈的压入、弹出序列（模拟，清晰图解）](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2)。



<h1 style='page-break-before: always;'>1.9 数学</h1>

1.10 数学




<h1 style='page-break-before: always;'>1.9.0 用 Rand7() 实现 Rand10()</h1>

## 1 题目

已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

**示例 1:**

```txt
输入: 1
输出: [7]
```

**示例 2:**

```txt
输入: 2
输出: [8,4]
```

**示例 3:**

```txt
输入: 3
输出: [8,1,10]
```

**提示:**

1. rand7 已定义。
2. 传入参数: n 表示 rand10 的调用次数。

**进阶:**

1. rand7()调用次数的 期望值 是多少 ?
2. 你能否尽量少调用 rand7() ?

## 2 问题分析

1. 首先需要知道：
   1. **在输出域上进行定量整体偏移**，**仍然满足等概率**，即要实现 0~6 随机器，只需要在 $rand7()$ 的返回值上进行-1 操作即可。
   2. **输出域的拼接/叠加不满足等概率**，例如 $rand7() + rand7()$ 会产生 $[2, 14]$ 范围内的数，但每个数并非等概率：
      1. 产生 2 的概率为：有 1 种情况，即 $(1, 1)$，其概率为 $\frac17 \times \frac17 = \frac1{49}$。
      2. 产生 4 的概率为：有三种情况，分别为 $(1, 3)$、$(2, 2)$、$(3, 1)$，其概率为 $\frac17 \times \frac17 + \frac17 \times \frac17 + \frac17 \times \frac17 = \frac3{49}$。
   3. 上述做法出现概率分布不均的情况，是因为**两次随机值的不同组合「相加」会出现相同的结果**（$(1, 3)$、$(2, 2)$、$(3, 1)$ 最终结果均为 4）。
   4. 因此，【执行两次 $rand7()$ 相加，将 $[1, 10]$ 范围内的数进行返回，否则一直重试】的做法是错误的。
2. 因为**每次执行 $rand7()$ 都可以看做是一次独立事件**，因此我们**可以将两次 $rand7()$ 的结果看作是生成 7 进制的两位**，**从而实现每个数值都唯一对应了一种随机值的组合**（等概率），例如：
   1. 设随机执行两次 $rand7()$ 得到的结果分别是 4、7。
   2. 由于我们是要 7 进制的数，因此可以先对 $rand7()$ 的执行结果进行-1 操作，将输出域偏移到 $[0, 6]$（仍为等概率），即得到 3、6，最终得到的数值是 63（7 进制）。
   3. 该数值唯一对应了我们的随机值组合方案，反过来随机值组合方案也唯一对应一个 7 进制的数值。
3. **根据「进制转换」的相关知识**，**如果我们存在一个 $randK()$ 的函数**，**对其执行 $n$ 次**，**我们能够等概率产生 $[0, K^n - 1]$ 范围内的数值**。
4. 本题中，**执行一次 $rand7()$ 只能产生 $[0, 6]$ 范围内的数值**，**不足 10 个**，而**执行 2 次 $rand7()$ 的话则能产生 $[0, 48]$ 范围内的数值**，**足够 10 个**，且**等概率**，因此我们**只需要判定生成的值是否为 $[1, 10]$ 即可**，**如果是的话直接返回**，**否则一直重试**。
5. 在上述的解法中，**范围 $[0, 48]$ 中**，**只有 $[1, 10]$ 范围内的数据会被接受返回**，**其余情况均被拒绝重试**，为了**尽可能少的调用 $rand7()$ 方法**，我们**可以从 $[0, 48]$ 中取与 $[1, 10]$ 成倍数关系的数**，**来进行转换**，因此我们**可以取 $[0, 48]$ 中的 $[1, 40]$ 范围内的数来代指 $[1, 10]$**，首先**在 $[0, 48]$ 中取 $[1, 40]$ 仍为等概率**，其次**形如 $x1$ 的数值有 4 个**，**分比为 1**、**11**、**21**、**31**，**形如 $x2$ 的数值有 4 个**，**分别为 2**、**12**、**22**、**32**...，因此**最终结果仍为等概率**。

## 3 参考代码

```java
public int rand10() {
    while (true) {
        int ans = (rand7() - 1) * 7 + (rand7() - 1);
        if (ans >= 1 && ans <= 40) return ans % 10 + 1;
    }
}
```

## 参考文献

1. [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7)。
2. [【宫水三叶】k 进制诸位生成 + 拒绝采样](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/gong-shui-san-xie-k-jin-zhi-zhu-wei-shen-zmd4)。




<h1 style='page-break-before: always;'>1.9.1 只出现一次的数字</h1>

## 1 题目

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```txt
输入: [2,2,1]
输出: 1
```

**示例 2:**

```txt
输入: [4,1,2,1,2]
输出: 4
```

## 2 问题分析

1. 该题目可以使用**异或运算**来实现。
2. 异或运算有以下三个性质：

   1. **任何数和 0 做异或运算**，**结果仍然是原来的数**，即 $a \oplus 0 = a$。
   2. **任何数和其自身做异或运算**，**结果是 0**，即 $a \oplus a = 0$。
   3. **异或运算满足交换律和结合律**，即 $a \oplus b \oplus a = b \oplus a \oplus a = b \oplus (a \oplus a) = b \oplus 0 = b$。
3. **假设数组中有 $ 2m + 1 $ 个数**，**其中有 $m$ 个数各出现两次**，**一个数出现一次**，**令 $a_1$**、$a_2$、...、$a_m$**为出现两次的 $m$ 个数**，**$a_{m + 1}$ 为出现一次的数**，**根据性质 3**，**数组中的全部元素的异或运算结果总是可以写成如下形式**：

$$
(a_1 \oplus a_1) \oplus (a_2 \oplus a_2) \oplus \cdot \cdot \cdot \oplus (a_m \oplus a_m) \oplus a_{m + 1}
$$

**根据性质 2 和性质 1**，**上式可化简和计算得到如下结果**：

$$
\oplus 0 \oplus \cdot \cdot \cdot \oplus 0 \oplus a_{m + 1} = a_{m + 1}
$$

**因此**，**数组中的全部元素的异或运算结果即为数组中只出现一次的数字**。

## 3 参考代码

```java
public int singleNumber(int[] nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        ans ^= nums[i];
    }
    return ans;
}
```

## 4 扩展题目

### 4.1 [数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof)

#### 4.1.1 问题分析

1. 该题目是[只出现一次的数字](#2-问题分析)的扩展，可以采用类似的方法来解决。
2. **针对只有一个数字出现了一次**，**其他数字都出现两次的情况**，**我们可以采用对所有数字进行异或操作**，**这样最终的结果便是只出现一次的数字**。
3. **对于有两个数字出现了一次**，**其他数字都出现两次的情况**，**我们可以把所有的数字分成两组**，**使得**：
   1. **两个只出现一次的数字在不同的组上**。
   2. **相同的数字会被分到相同的组上**。
4. **此时**，**对两个组分别进行异或操作**，**便可得到两个只出现一次的数字**，因此，**关键在于如何分组**，具体可采用如下的方法：
   1. **记这两个只出现了一次的数字为 $a$ 和 $b$**，**那么所有数字的异或结果就等于 $a$ 和 $b$ 异或的结果**，**我们记为 $x$**。
   2. **如果我们把 $x$ 写成二进制的形式 $x_kx_{k-1} \cdots x_2x_1x_0$**，**其中 $x \in \left\{0,1\right\}$**，此时，$x_i$**的值就代表 $a_i$ 和 $b_i$ 的关系**，即：

      $$
      \left\{\begin{array}{l}x_i=0,\;a_i=b_i\\x_i=1,\;a_i \ne b_i\end{array}\right.
      $$
   3. **假如我们任选一个不为 0 的 $x_i$**，**按照第 $i$ 位给原来的序列分组**，**如果该位为 0 就分到第一组**，**否则就分到第二组**，**这样就能满足以上两个条件**，因为：

      1. **首先**，**两个相同的数字的对应位都是相同的**，**所以一个被分到了某一组**，**另一个必然被分到这一组**，**所以满足了条件 2**。
      2. **其次**，**这个方法在 $x_i = 1$ 的时候 $a$ 和 $b$ 不被分在同一组**，**因为 $x_i = 1$ 表示 $a_i$ 和 $b_i$ 不等**，**根据这个方法的定义「如果该位为 0 就分到第一组，否则就分到第二组」可以知道他们被分进了两组**，**所以满足了条件 1**。
   4. **在实际的操作过程中**，**我们拿到序列的异或和 $x$ 之后**，**对于这个位是可以任取的**，**只要他满足 $x_i = 1$**，**但是为了方便**，**这里我们选取的是「不为 0 的最低位」**。
5. 具体的算法流程如下：
   1. **先对所有数字进行一次异或**，**得到两个出现一次的数字的异或值**。

      ![](https://notebook.ricear.com/media/202206/2022-06-17_1244000.7151189598650409.png)
   2. **在异或结果中找到任意为 1 的位**。

      ![](https://notebook.ricear.com/media/202206/2022-06-17_1244000.7409195606915164.png)
   3. **根据这一位对所有的数字进行分组**。

      ![](https://notebook.ricear.com/media/202206/2022-06-17_1244000.43883575248146134.png)
   4. **在每个组内进行异或操作**，**得到两个数字**。

      ![](https://notebook.ricear.com/media/202206/2022-06-17_1244000.07782610698793824.png)

      ![](https://notebook.ricear.com/media/202206/2022-06-17_1244000.14969172472009196.png)

#### 4.1.2 参考代码

```java
/**
 * 剑指 Offer 56 - I. 数组中数字出现的次数
 * @param nums  数组
 * @return  数组中两个只出现一次的数字
 */
public int[] singleNumbers(int[] nums) {
    int tmp = 0, div = 1, a = 0, b = 0;

    //  1. 对数组中所有的数字进行异或，得到两个只出现一次的数字的异或
    for (int num: nums) {
        tmp ^= num;
    }

    //  2. 获取两个只出现一次的数字的异或中二进制位第一个不为 0 的低位
    while ((div & tmp) == 0) {div <<= 1;}

    //  3. 对数组中的数字进行分组并进行异或获取两个只出现一次的数字
    for (int num: nums) {
        if ((div & num) != 0) {a ^= num;}
        else {b ^= num;}
    }

    return new int[]{a, b};
}
```

### 4.2 [数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof)

#### 4.2.1 问题分析

1. 如下图所示，考虑数字的二进制形式，**对于出现三次的数字**，**各二进制位出现的次数都是 3 的倍数**，因此，**统计所有数字的各二进制位中 1 的出现次数**，**并对 3 求余**，**结果则为只出现一次的数字**。

   ![Picture1.png](https://notebook.ricear.com/media/202206/2022-06-17_1244000.9936426449792627.png)
2. **各二进制位的位运算规则相同**，因此**只需考虑一位即可**，如下图所示，**对于所有数字中的某二进制位 1 的个数**，**存在 3 种状态**，**即对 3 余数为 0**、**1**、**2**：

   1. 若**输入二进制位为 0**，则**状态不变**。
   2. 若**输入二进制位为 1**，则**状态按照以下顺序转换**：

      $$
      0 \rightarrow 1 \rightarrow 2 \rightarrow 0 \rightarrow \cdots
      $$

      ![Picture2.png](https://notebook.ricear.com/media/202206/2022-06-17_1244000.01575213023832789.png)
3. **由于二进制只能表示 0**、**1**，**因此需要使用两个二进制位来表示 3 个状态**，**设此两位分别为 $two$**、$one$，**则状态转换变为**：

   $$
   00 \rightarrow 01 \rightarrow 10 \rightarrow 00 \rightarrow \cdots
   $$

   ![Picture3.png](https://notebook.ricear.com/media/202206/2022-06-17_1244000.0067849883704458325.png)
4. 接下来，**需要通过状态转换表导出状态转换的计算公式**：

   1. 首先回忆一下位运算特点，**对于任意二进制位 $x$**，有：

      1. **异或运算**：$x \wedge 0 = x$，$x \wedge 1 = \sim x$。
      2. **与运算**：$x \& 0 = 0$，$x \& 1 = x$。
   2. **计算 $one$ 方法**：

      1. **设当前状态为 $two \; one$**，**此时输入二进制位 $n$**，如下图所示，**通过对状态表的拆分**，**可推出 $one$ 的计算方法为**：

         ```java
         if (two == 0) {
           if (n == 0) {
             one = one;
           } else if (n == 1) {
             one = -one;
           }
         } else if (two == 1) {
           one = 0;
         }
         ```
      2. **引入异或运算**，**可将以上拆分简化为**：

         ```java
         if (two == 0) {
           one = one ^ n;
         } else if (two == 1) {
           one = 0;
         }
         ```
      3. **引入与运算**，**可继续简化为**：

         $$
         one = one\; \wedge\; n\; \&\; ~two
         $$

         ![Picture4.png](https://notebook.ricear.com/media/202206/2022-06-17_1244000.20137094576475434.png)
   3. **计算 $two$ 方法**：

      $$
      two = two\; \wedge\; n\; \&\; ~one
      $$

      ![Picture5.png](https://notebook.ricear.com/media/202206/2022-06-17_1244010.5028293466336148.png)
   4. **返回值**：

      1. **以上是对数字的二进制中一位的分析**，**而 `int` 类型的其他 31 位具有相同的运算规则**，**因此可将以上公式直接套用在 32 位数上**。
      2. **遍历完所有数字后**，**各二进制位都处于状态 00 和状态 01**（取决于只出现一次的数字的各二进制位是 1 还是 0），**而此状态是由 $one$ 来记录的**（此两状态下 $two$ 恒为 0），**因此返回 $one$ 即可**。

#### 4.2.2 参考代码

```java
/**
 * 剑指 Offer 56 - II. 数组中数字出现的次数 II
 * @param nums  数组
 * @return  数组中只出现一次的数字
 */
public int singleNumber(int[] nums) {
    int one = 0, two = 0;
    for (int num: nums) {
        one = one ^ num & ~two;
        two = two ^ num & ~one;
    }
    return one;
}
```

## 参考文献

1. [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number)。
2. [只出现一次的数字](https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution)。
3. [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof)。
4. [数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-by-leetcode)。
5. [剑指 Offer 56 - I. 数组中数字出现的次数（位运算，清晰图解）](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom)。



<h1 style='page-break-before: always;'>1.9.2 整数反转</h1>

## 1 题目

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。
**示例 1：**

```txt
输入：x = 123
输出：321
```

**示例 2：**

```txt
输入：x = -123
输出：-321
```

**示例 3：**

```txt
输入：x = 120
输出：21
```

**示例 4：**

```txt
输入：x = 0
输出：0
```

**提示：**

* -231 <= x <= 231 - 1

## 2 问题分析

1. **反转一个整数时**，我们**只需要拿到这个整数的末尾数字就可以了**，例如在反转 12345 时，先拿到 5，再拿到 4，之后是 3、4、1，我们按这样的顺序就可以反向拼接成一个数字了，也能达到反转的效果。
2. **拿末尾数字时**，**用取模运算就可以了**，例如拿 12345 的末尾数字：
   1. 将 $ 12345 \% 10 $ 得到 5，之后将 $ 12345 / 10$。
   2. 将 $ 1234 \% 10 $ 得到 4，之后将 $ 1234 / 10$。
   3. 将 $ 123 \% 10 $ 得到 3，之后将 $ 123 / 10$。
   4. 将 $ 12 \% 10 $ 得到 2，之后将 $ 12 / 10$。
   5. 将 $ 1 \% 10 $ 得到 1，之后将 $ 1 / 10$。
      
      ![1.jpg](https://notebook.ricear.com/media/202201/2022-01-15_1643490.28884188943836187.png)
3. 因为要**考虑负数**，**所以上述循环的判断条件是 $x != 0$**。
4. 同时因为【假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 `[−2^31,  2^31 − 1]`】，所以我们**不能用 `long` 存储最终结果**，而且**有些数字可能是合法范围内的数字**，但是**翻转过来就可能超过范围了**，例如 1147483649，本身是小于最大的 32 位整数 2147483647 的，但是将这个数字反转过来后就变成了 9463847411，这就比最大的 32 位整数还要大了，这样的数字没法存到 `int` 里，所以肯定要返回 0（溢出了），所以我们需要**在反转的过程中不断判断反转的临时结果 $res$ 是否溢出**，**如果溢出的话**，**直接返回 0**，具体判断规则如下：
   1. $res > 214748364 || (res == 214748364 \&\& temp > 7)$，即 $res$ 大于最大的 32 位整数。
   2. $res < -214748364 || (res == -214748364 \&\& temp < -8)$，即 $res$ 小于最小的 32 位整数。
      
      > 注：$temp = x % 10$，即每次取的末尾数字。
      
      ![2.jpg](https://notebook.ricear.com/media/202201/2022-01-15_1650070.6591399192263269.png)
      
      ![3.jpg](https://notebook.ricear.com/media/202201/2022-01-15_1650170.16949562176053135.png)

## 3 参考代码

```java
/**
 * 7. 整数反转
 * @param x 要反转的整数
 * @return  反转后的整数
 */
public int reverse(int x) {
    int res = 0;
    while (x != 0) {
        //  每次取末尾数字
        int temp = x % 10;
        //  判断是否大于最大 32 位整数
        if ( res > 214748364 || (res == 214748364 && temp > 7)) {return 0;}
        //  判断是否小于最小 32 位整数
        if (res < -214748364 || (res == 214748364 && temp < -8)) {return 0;}
        //  拼接结果
        res = res * 10 + temp;
        //  修改要反转的整数
        x /= 10;
    }
    return res;
}
```

## 参考文献

1. [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer)。
2. [图解 7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/solution/tu-jie-7-zheng-shu-fan-zhuan-by-wang_ni_ma)。






<h1 style='page-break-before: always;'>1.9.3 求1+2+…+n</h1>

## 1 题目

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。

**示例 1：**

```txt
输入: n = 3
输出: 6
```

**示例 2：**

```txt
输入: n = 9
输出: 45
```

**限制：**

* 1 <= n <= 10000

## 2 问题分析

1. 本题**需要实现 $ 当 n = 1 时终止递归 $ 的需求**，**可通过短路效应实现**：
   
   ```java
   n > 1 && sumNums(n - 1) > 0 // 当 n = 1 时 n > 1 不成立，此时短路，终止后续递归
   ```

## 3 参考代码

```java
int res = 0;

/**
 * 剑指 Offer 64. 求 1+2+…+n
 * @param n 数据的个数
 * @return  1+2+…+n 的和
 */
public int sumNums(int n) {
    boolean x = n > 1 && sumNums(n - 1) > 0;
    res += n;
    return res;
}
```

## 参考文献

1. [剑指 Offer 64. 求 1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof)。
2. [ 面试题 64. 求 1 + 2 + … + n（逻辑符短路，清晰图解）](https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-)。




<h1 style='page-break-before: always;'>1.9.4 二进制中1的个数</h1>

# 1 题目

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

**提示：**

* 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
* 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

**示例 1：**

```txt
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```txt
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```txt
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

**提示：**

* 输入必须是长度为 32 的 二进制串 。

# 2 解题思路

> 对于数学相关的题目，要学会使用**位运算**来解决。

## 2.1 逐位判断

### 2.1.1 问题分析

1. **根据与运算定义**，**设二进制数字 $n$**，则有：
   1. **若 $n \& 1 = 0$**，**则 $n$ 二进制最右一位为 0**。
   2. **若 $n \& 1 = 1$**，**则 $n$ 二进制最右一位为 1**。
2. **根据以上特点**，**考虑以下循环判断**：
   1. **判断 $n$ 最右一位是否为 1**，**根据结果计数**。
   2. **将 $n$ 右移一位**（本题要求把数字 $n$ 看作无符号数，因此使用**无符号右移**操作）。

### 2.1.2 参考代码

```java
/**
 * 剑指 Offer 15. 二进制中 1 的个数（版本 1：逐位判断）
 * @param n
 * @return
 */
public int hammingWeightV1(int n) {
    int res = 0;
    while (n != 0) {
        res += n & 1;
        n >>>= 1;
    }
    return res;
}
```

## 2.2 巧用 $n \& (n - 1)$

### 2.2.1 问题分析

1. 如果一个整数不等于 0，那么该整数的二进制表示中至少有一位是 1。
2. 先假设这个数的**最右边一位是 1**，那么**减去 1 时**，**最后一位变成 0**，而**其他所有位都保持不变**，也就是**最后一位相当于做了取反操作**，**由 1 变成了 0**。
3. 接下来假设**最后一位不是 1 而是 0**的情况，如果该整数的二进制表示中**最右边的 1 位于第 $m$ 位**，那么**减去 1 时**，**第 $m$ 位由 1 变成 0**，而**第 $m$ 位之后的所有 0 都变成了 1**，整数中**第 $m$ 位之前的所有位都保持不变**，例如一个二进制数 1100，他的第二位是从右边数起的第一个 1，减去 1 后，第二位变成 0，他后面的两位 0 变成 1，而前面的 1 保持不变，因此得到的结果是 1011。
4. 在前面两种情况中，我们发现**把一个整数减去 1**，**都是把最右边的 1 变成 0**，**如果他的右边还有 0**，**则所有的 0 都变成 1**，**而他左边的所有位都保持不变**，接下来我们**把一个整数和他减去 1 的结果做与运算**，**相当于把他最右边的 1 变成 0**，还是以前面的 1100 为例，他减去 1 的结果是 1011，我们再把 1100 和 1011 做位与运算，得到的结果是 1000，我们把 1100 最右边的 1 变成了 0，结果刚好就是 1000。
5. 我们把上面的分析总结起来就是，**把一个整数减去 1**，**再和原整数做与运算**，**会把该整数最右边的 1 变成 0**，**一个整数的二进制表示中有多少个 1**，**就可以进行多少次这样的操作**。

### 2.2.2 参考代码

```java
/**
 * 剑指 Offer 15. 二进制中 1 的个数（版本 2：巧用 n & (n - 1)）
 * @param n
 * @return
 */
public int hammingWeightV2(int n) {
    int res = 0;
    while (n != 0) {
        res++;
        n = n & (n - 1);
    }
    return res;
}
```

# 参考文献

1. [剑指 Offer 15. 二进制中 1 的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof)。
2. [面试题 15. 二进制中 1 的个数（位运算，清晰图解）](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun)。
3. 《剑指 Offer（第 2 版）》。




<h1 style='page-break-before: always;'>1.9.5 幂运算</h1>

## 1 相关知识

### 1.1 快速幂算法

1. **求 $x^n$ 最简单的方法是通过循环将 $n$ 个 $x$ 乘起来**，**依次求 $x_1, x_2,..., x_n$**，**时间复杂度为 $O(n)$**，而**快速幂算法可将时间复杂度降低至 $O(log_2n)$**。
2. **快速幂算法实际上是二分思想的一种应用**，具体推导如下：
   1. $x^n = x^{n / 2} \times x^{n / 2}$，令 $n / 2$ 为整数，则需要分为奇偶两种情况（设向下取整除法符号为 `//`）：
      1. **当 $n$ 为偶数**：$x^n = (x^2)^{n // 2}$。
      2. **当 $n$ 为奇数**：$x^n = x(x^2)^{n // 2}$，即**会多出一项 $x$**。
3. **幂结果的获取方法**如下：
   1. **根据二分推导**，**可通过循环$x = x^2$操作**，**每次把幂从$n$降至$n // 2$**，**直至将幂降为0**。
   2. **设$res = 1$**，**则初始状态$x^n = x^n \times res$**，**在循环二分时**，**每当$n$为奇数时**，**将多出的一项$x$乘入$res$**，**则最终可化至$x^n = x^0 \times res = res$**，**返回$res$即可**。

      ![Picture2.png](/media/202202/2022-02-08_1930410.5592932205133178.png)
4. 计算过程中**部分操作可转化为位运算**：
   1. **向下整除$n // 2$等价于右移一位**，即$n >> 1$。
   2. **取余数$n % 2$等价于判断二进制最右一位值**，即$n \& 1$。

## 2 相关题目

### 2.1 [数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof)

#### 2.1.1 题目

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

**示例 1：**

```txt
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**

```txt
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例 3：**

```txt
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

**提示：**

* -100.0 < x < 100.0
* -231 <= n <= 231-1
* -104 <= xn <= 104

#### 2.1.2 问题分析

1. 可采用[快速幂算法](#1-1-快速幂算法)来求解。
2. 具体算法流程如下：
   1. **当$x = 0$时**，**直接返回0**，**避免后续$x = \frac1x$操作报错**。
   2. **初始化$res = 1$**。
   3. **当$n \lt 0$时**，**把问题转化至$n \ge 0$的范围内**，**即执行$x = \frac1x, n = -n$**。
   4. **循环计算**，**当$n = 0$时跳出**：
      1. **当$n \& 1$时**，**将当前$x$乘入$res$**，**即$res *= x$**。
      2. **执行$x = x^2$**，**即$x *= x$**。
      3. **执行$n$右移一位**，**即$n >>= 1$**。
   5. **返回$res$**。
3. 需要注意的是：
   1. **`Java`中 `int32`变量$n \in [-2147483648, 2147483647]$**，因此**当$n = -2147483648$时执行$n = -n$会因越界而赋值出错**，解决方法是**先将$n$存入 `long`类型变量$temp$**，**后面用$temp$操作即可**。

#### 2.1.3 参考代码

```java
/**
 * 剑指 Offer 16. 数值的整数次方
 * @param x 底数
 * @param n 指数
 * @return  x 的 n 次方
 */
public double myPow(double x, int n) {
    long temp = n;
    double res = 1.0;

    if (x == 0) {return 0;}

    if (temp < 0) {
        x = 1 / x;
        temp = -temp;
    }

    while (temp > 0) {
        if ((temp & 1) == 1) {res *= x;}
        x *= x;
        temp >>= 1;
    }

    return res;
}
```

## 参考文献

1. [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof)。
2. [面试题 16. 数值的整数次方（快速幂，清晰图解）](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s)。



<h1 style='page-break-before: always;'>1.9.6 1～n 整数中 1 出现的次数</h1>

## 1 题目

输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。

例如，输入 12，1～12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。

**示例 1：**

```txt
输入：n = 12
输出：5
```

**示例 2：**

```txt
输入：n = 13
输出：6
```

**限制：**

* 1 <= n < 2^31

## 2 问题分析

1. **将 $ 1 \sim n$ 的个位**、**十位**、**百位**、...**的 1 出现次数相加**，**即为 1 出现的总次数**。
2. **设数字 $n$ 是个 $x$ 位数**，**记 $n$ 的第 $i$ 位为 $n_i$**，**则可将 $n$ 写为 $n_xn_{x-1} \cdots n_2n_1$**：

   1. **称 $n_i$ 为当前位**，**记为 $cur$**。
   2. **将 $n_{i-1}n_{i-2} \cdots n_2n_1$ 称为低位**，**记为 $low$**。
   3. **将 $n_xn_{x-1} \cdots n_{i+2}n_{i+1}$ 称为高位**，**记为 $high$**。
   4. **将 $ 10^i$ 称为位因子**，**记为 $digit$**。
3. 在**计算某位中 1 出现次数时**，**根据当前位 $cur$ 值的不同**，**分为以下三种情况**：

   1. **当 $cur = 0$ 时**，**此位 1 的出现次数只由高位 $high$ 决定**，计算公式为：

      $$
      high \times digit
      $$
   1. **当 $cur = 1$ 时**，**此位 1 的出现次数由高位 $high$ 和低位 $low$ 决定**，计算公式为：

      $$
      high \times digit + low + 1
      $$
   2. **当 $cur = 2, 3, ..., 9$ 时**，**此位 1 的出现次数只由高位 $high$ 决定**，计算公式为：

      $$
      (high + 1) \times digit
      $$
4. **变量递推公式为**：

   1. **设计按照个位**、**十位**、...**的顺序计算**，则 $high / cur / low / digit$**应初始化为**：
      1. $high = n / 10$。
      2. $cur = n % 10$。
      3. $low = 0$。
      4. $digit = 1$，即**个位**。
   2. 因此，**从个位到最高位的变量递推公式为**：
      1. $low += cur * digit$，即**将 $cur$ 加入 $low$**，**组成下轮 $low$**。
      2. $cur = high \% 10$，即**下轮 $cur$ 是本轮 $high$ 的最低位**。
      3. $high /= 10$，即**将本轮 $high$ 最低位删除**，**得到下轮 $high$**。
      4. c$digit *= 10$，即**位因子每轮 $\times$ 10**。
5. 具体实例如下：

   1. 当 $cur = 0$ 时，以 $n = 2304$ 为例，求 $digit = 10$（即十位）的 1 出现次数：

      ![Picture1.png](/media/202202/2022-02-09_1609210.5370369541150786.png)
   2. 当 $cur = 1$ 时，以 $n = 2314$ 为例，求 $digit = 10$（即十位）的 1 出现次数：

      ![Picture2.png](/media/202202/2022-02-09_1610230.41455634163523025.png)
   3. 当 $cur = 2, 3, ..., 9$ 时，以 $n = 2324$ 为例，求 $digit = 10$（即十位）的 1 出现次数：

      ![Picture3.png](/media/202202/2022-02-09_1611220.4709022428185119.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 43. 1～n 整数中 1 出现的次数
 * @param n 整数
 * @return  1～n 整数中 1 出现的次数
 */
public int countDigitOne(int n) {
    int low = 0, high = n / 10, cur = n % 10, digit = 1, res = 0;

    while (high != 0 || cur != 0) {
        //  当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
        if (cur == 0) {res += high * digit;}
        else if (cur == 1) {res += high * digit + low + 1;}
        else {res += (high + 1) * digit;}
        //  将 cur 加入 low，组成下轮 low
        low += cur * digit;
        //  下轮 cur 是本轮 high 的最低位
        cur = high % 10;
        //  将本轮 high 最低位删除，得到下轮 high
        high = high / 10;
        //  位因子每轮 x 10
        digit *= 10;
    }

    return res;
}
```

## 参考文献

1. [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof)。
2. [面试题 43. 1～n 整数中 1 出现的次数（清晰图解）](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2)。



<h1 style='page-break-before: always;'>1.9.7 数字序列中某一位的数字</h1>

## 1 题目

数字以 0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第 5 位（从下标 0 开始计数）是 5，第 13 位是 1，第 19 位是 4，等等。

请写一个函数，求任意第 n 位对应的数字。

**示例 1：**

```txt
输入：n = 3
输出：3
```

**示例 2：**

```txt
输入：n = 11
输出：0
```

**限制：**

* 0 <= n < 2^31

## 2 问题分析

1. 相应的数字定义如下：

   1. **将 $ 101112 \cdots$ 中的每一位称为数位**，**记为 $n$**。
   2. **将 $ 10, 11, 12, \cdots$ 称为数字**，**记为 $num$**。
   3. **数字 $ 10 $ 是一个两位数**，**称此数字的位数为 2**，**记为 $digit$**。
   4. **每 $digit$ 位数的起始数字**（即 $ 1, 10, 100, \cdots$），**记为 $start$**。

      ![Picture1.png](/media/202202/2022-02-09_1733270.5518137850928253.png)
2. 根据以上分析，可将求解分为三步：

   1. **确定 $n$ 所在数字的位数**，**记为 $digit$**：
      1. **循环执行 $n$ 减去一位数**、**两位数**、...**的数位数量 $count$**，**直至 $n \le count$ 时跳出**。
      2. **由于 $n$ 已经减去了一位数**、**两位数**、...、$(digit - 1)$**位数的数位数量 $count$**，**因而此时的 $n$ 是从起始数字 $start$ 开始计数的**。

         ![Picture2.png](/media/202202/2022-02-09_1741260.942468520063812.png)
   2. **确定 $n$ 所在的数字**，**记为 $num$**：
      1. **所求数位在从数字 $start$ 开始的第 $\frac{n - 1}{digit}$ 个数字中**（$start$ 为第 0 个数字），即

         $$
         num = start + \frac{n - 1}{digit}
         $$

         ![Picture3.png](/media/202202/2022-02-09_1745320.31558270921165665.png)
   3. **确定 $n$ 是 $num$ 中的哪一数位**，**并返回结果**：
      1. **所求数位为数字 $num$ 的第 $\frac{n - 1}{digit}$ 位**（数字的首个数位为第 0 位）。

         ![Picture4.png](/media/202202/2022-02-09_1749000.4903168084894265.png)
3. 具体实例如下：

   ![](../../media/202202/2022-02-09_1749560.8402380541484955.png)

   ![](../../media/202202/2022-02-09_1750080.9277916893013155.png)

   ![](../../media/202202/2022-02-09_1750250.8687465615429757.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 44. 数字序列中某一位的数字
 * @param n 数字序列中的位数
 * @return  数字序列中第 n 位的数字
 */
public int findNthDigit(int n) {
    int digit = 1, res = 0;
    long start = 1, count = 9, num = 0;

    //  1. 确定 n 所在数字的位数
    while (n > count) {
        n -= count;
        digit++;
        start *= 10;
        count = 9 * digit * start;
    }

    //  2. 确定 n 所在的数字
    num = start + (n - 1) / digit;
    //  3. 确定 n 是 num 中的哪一数位
    res = Long.toString(num).charAt((n - 1) % digit) - '0';
    return res;
}
```

## 参考文献

1. [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof)。
2. [面试题 44. 数字序列中某一位的数字（迭代 + 求整 / 求余，清晰图解）](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6)。



<h1 style='page-break-before: always;'>1.9.8 丑数</h1>

## 1 题目

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**示例:**

```txt
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明:**

* 1 是丑数。
* n 不超过 1690。

## 2 问题分析

1. **丑数的递推性质**：**丑数只包含因子 2**、**3**、**5**，**因此有 $ 丑数 = 某较小丑数 \times 某因子 $**（例如 $ 10 = 5 \times 2$）。
2. **设已知长度为 $n$ 的丑数序列 $x_1, x_2, \cdots , x_n$**，**求第 $n + 1$ 个丑数 $x_{n + 1}$**，**根据递推性质**，**丑数 $x_{n + 1}$ 只可能是以下三种情况其中之一**（索引 $a, b, c$ 为未知数）：

   $$
   x_{n+1}=\left\{\begin{array}{l}x_a\times2,\;a\in\left[1,\;n\right]\\x_b\times3,\;b\in\left[1,\;n\right]\\x_c\times5,\;c\in\left[1,\;n\right]\end{array}\right.
   $$
3. **丑数递推公式**：**若索引 $a, b, c$ 满足以上条件**，**则下个丑数 $x_{n + 1}$ 为以下三种情况中的最小值**：

   $$
   x_{n + 1} = min(x_a \times 2, x_b \times 3, x_c \times 5)
   $$
4. **由于 $x_{n + 1}$ 是最接近 $x_n$ 的丑数**，**因此索引 $a, b, c$ 需满足以下条件**：

   $$
   x_{n+1}=\left\{\begin{array}{l}x_a\times2>x_n\geq x_{a-1}\times2,\;即 x_a\mathrm{为首个乘以}2\mathrm{后大于}x_n\mathrm{的丑数}\\x_b\times3>x_n\geq x_{b-1}\times3,\;即 x_b\mathrm{为首个乘以}3\mathrm{后大于}x_n\mathrm{的丑数}\\x_c\times5>x_n\geq x_{c-1}\times5,\;即 x_c\mathrm{为首个乘以}5\mathrm{后大于}x_c\mathrm{的丑数}\end{array}\right.
   $$

   ![Picture1.png](/media/202202/2022-02-10_1542480.9788386990040487.png)
5. **可设置指针 $a, b, c$ 指向首个丑数**（即 1），**循环根据递推公式得到下个丑数**，**并每轮将对应指针执行 +1 即可**。
6. 因此，可采用[动态规划](https://notebook.ricear.com/project-21/doc-87)的方法来解，具体过程如下：

   1. **状态定义**：

      1. **设动态规划列表 $dp$**，**其中 $dp[i]$ 表示第 $i + 1$ 个丑数**。
   2. **转移方程**：

      1. **当索引 $a, b, c$ 满足以下条件时**，$dp[i]$**为三种情况的最小值**：

         $$
         \left\{\begin{array}{l}dp\left[a\right]\times2>dp\left[i-1\right]\geq dp\left[a-1\right]\times2\\dp\left[b\right]\times3>dp\left[i-1\right]\geq dp\left[b-1\right]\times3\\dp\left[c\right]\times5>dp\left[i-1\right]\geq dp\left[c-1\right]\times5\end{array}\right.
         $$

         $$
         dp[i] = min(dp[a] \times 2, dp[b] \times 3, dp[c] \times 5)
         $$
      2. **每轮计算 $dp[i]$ 后**，**需要更新索引 $a, b, c$ 的值**，**使其始终满足方程条件**，实现方法为**分别独立判断 $dp[i]$ 和 $dp[a] \times 2, dp[b] \times 3, dp[c] \times 5$ 的大小关系**，**若相等则将对应索引 $a, b, c$ 加 1**。
   3. **初始状态**：

      1. **$dp[0] = 1$**，即**第一个丑数为 1**。
   4. **返回值**：

      1. $dp[n - 1]$，即**返回第 $n$ 个丑数**。

## 3 参考代码

```java
/**
 * 剑指 Offer 49. 丑数
 * @param n 丑数的序号
 * @return  第 n 个丑数
 */
public int nthUglyNumber(int n) {
    //  dp 数组，其中 dp[i] 表示第 i + 1 个丑数
    int[] dp = new int[n];
    int a = 0, b = 0, c = 0;

    //  第一个丑数为 1
    dp[0] = 1;

    //  循环计算 dp[i]
    for (int i = 1; i < n; i++) {
        int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
        dp[i] = Math.min(Math.min(n2, n3), n5);
        if (dp[i] == n2) {a++;}
        if (dp[i] == n3) {b++;}
        if (dp[i] == n5) {c++;}
    }

    //  返回第 n 个丑数
    return dp[n - 1];
}
```

## 参考文献

1. [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof)。
2. [剑指 Offer 49. 丑数（动态规划，清晰图解）](https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t)。



<h1 style='page-break-before: always;'>1.9.9 n个骰子的点数</h1>

## 1 题目

把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

**示例 1:**

```txt
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

**示例 2:**

```txt
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

**限制：**

* 1 <= n <= 11

## 2 解题思路

### 2.1 动态规划

#### 2.1.1 问题分析

1. **设输入 $n$ 个骰子的解**（即概率列表）**为 $f(n)$**，**其中点数和 $x$ 的概率为 $f(n, x)$**。
2. **假设已知 $n  - 1$ 个骰子的解 $f(n - 1)$**，**此时添加一枚骰子**，**求 $n$ 个骰子的点数和为 $x$ 的概率 $f(n, x)$**。
3. **当添加骰子的点数为 1 时**，**前 $n - 1$ 个骰子的点数和应为 $x - 1$**，**方可组成点数和 $x$**，**同理**，**当此骰子为 2 时**，**前 $n - 1$ 个骰子应为 $n - 2$**，**以此类推**，**直至此骰子点数为 6**，**将这 6 种情况的概率相加**，**即可得到概率 $f(n, x)$**，**递推公式如下所示**：

   $$
   f(n, x) = \sum^6_{x = 1}f(n - 1, x - i) \times \frac16
   $$
4. **根据以上分析**，**得知通过子问题的解 $f(n - 1)$ 可递推计算出 $f(n)$**，**而输入一个骰子的解 $f(1)$ 已知**，**因此可通过解 $f(1)$ 依次递推出任意解 $f(n)$**，如下图所示，为 $n = 2, x = 7$ 的递推计算示意图：

   ![Picture2.png](/media/202202/2022-02-12_1057170.3733175875882666.png)
5. **观察发现**，**以上递推公式虽然可行**，**但 $f(n - 1, x - i)$ 中的 $x - i$ 会有越界问题**，例如，若希望递推计算 $f(2, 2)$，由于一个骰子的点数和范围为 $[1, 6]$，因此只应求和 $f(1, 1)$，即 $f(1, 0), f(1, -1),..., f(1, -4) $ 皆无意义。
6. **上面的递推公式是逆向的**，**即为了计算 $f(n, x)$**，**将所有与之相关的情况求和**，**而倘若改换为正向的递推公式**，**便可解决问题**，**具体来看**，**由于新增骰子的点数只可能为 1 至 6**，**因此概率 $f(n - 1, x)$ 仅与 $f(n, x + 1), f(n, x + 2),..., f(n, x + 6)$ 相关**，**因而**，**遍历 $f(n + 1)$ 中各点数和的概率**，**并将其相加至 $f(n)$ 中所有相关项**，**即可完成 $f(n - 1)$ 至 $f(n)$ 的递推**。

   ![Picture3.png](/media/202202/2022-02-12_1106230.40331717078644014.png)
7. 具体实例如下：

   ![](../../media/202202/2022-02-12_1106440.512448934251122.png)

   ![](../../media/202202/2022-02-12_1106520.32350363339285904.png)

   ![](../../media/202202/2022-02-12_1107010.2953053321677126.png)

   ![](../../media/202202/2022-02-12_1107090.5823211622074699.png)

   ![](../../media/202202/2022-02-12_1107170.24416546346844548.png)

   ![](../../media/202202/2022-02-12_1107240.33870643211913043.png)

   ![](../../media/202202/2022-02-12_1107320.398163178063511.png)

   ![](../../media/202202/2022-02-12_1107400.6363814827314325.png)

   ![](../../media/202202/2022-02-12_1107500.07696989614018224.png)

#### 2.1.2 参考代码

```java
/**
 *剑指 Offer 60. n 个骰子的点数
 * @param n 骰子的个数
 * @return  所有骰子朝上一面的点数之和的所有可能的值出现的概率
 */
public double[] dicesProbability(int n) {
    double[] dp = new double[6];
    Arrays.fill(dp, 1.0 / 6.0);
    for (int i = 2; i <= n; i++) {
        double[] tmp = new double[5 * i + 1];
        for (int j = 0; j < dp.length; j++) {
            for (int k = 0; k < 6; k++) {
                tmp[j + k] += dp[j] / 6.0;
            }
        }
        dp = tmp;
    }
    return dp;
}
```

## 参考文献

1. [剑指 Offer 60. n 个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof)。
2. [ 剑指 Offer 60. n 个骰子的点数（动态规划，清晰图解）](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/jian-zhi-offer-60-n-ge-tou-zi-de-dian-sh-z36d)。



<h1 style='page-break-before: always;'>1.9.10 圆圈中最后剩下的数字</h1>

## 1 题目

0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。

**示例 1：**

```txt
输入: n = 5, m = 3
输出: 3
```

**示例 2：**

```txt
输入: n = 10, m = 17
输出: 2
```

**限制：**

* 1 <= n <= 10^5
* 1 <= m <= 10^6

## 2 问题分析

1. 该题目是经典的[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)，即：

   1. $N$**个人围成一圈**，**第一个人从 1 开始报数**，**报 $M$ 的将被杀掉**，**下一个接着从 1 开始报**，**如此反复**，**最后剩下一个**，**求最后的胜利者**。
2. **约瑟夫环是一个经典的数学问题**，**我们不难发现这样的依次报数**，**似乎有规律可循**，**为了方便导出递推式**，**我们重新定义一下题目**：

   1. **$N$ 个人编号为 $ 1, 2,..., N$**，**依次报数**，**每报到 $M$ 时**，**杀掉那个人**，**求最后胜利者的编号**。
3. 下面我们开始求约瑟夫环的递推公式：

   1. **下面我们不用字母表示一个人**，**而用数字**：

      $$
      1、2、3、4、5、6、7、8、9、10、11
      $$
   2. **上面的数字表示 11 个人**，**他们先排成一排**，**假设每报到 3 的人被杀掉**：

      1. **刚开始时**，**头一个人编号是 1**，**从他开始报数**，**第一轮被杀掉的是编号 3 的人**。
      2. **编号 4 的人从 1 开始报数**，**这时候我们可以认为编号 4 这个人是队伍的头**，**第二轮被杀掉的是编号 6 的人**。
      3. **编号 7 的人开始重新报数**，**这个时候我们可以认为编号 7 这个人是队伍的头**，**第三轮杀掉的是编号 9 的人**。
      4. ......
      5. **第九轮时**，**编号 2 的人开始重新报数**，**这时候我们可以认为编号 2 这个人是队伍的头**，**这轮被杀掉的是编号 8 的人**。
      6. **下一个人还是编号为 2 的人**，**他从 1 开始报数**，**不幸的是他在这轮被杀掉了**。
      7. **最后的胜利者是编号为 7 的人**。
   3. 下图表示这一过程（先忽视绿色的一行）：

      ![这里写图片描述](/media/202202/2022-02-12_1649310.6907512898666288.png)
   4. 我们定义 $f(n, m)$**表示 $N$ 个人报数**，**每报到 $M$ 时杀掉那个人**，**最终胜利者的编号**，下面我们来推导具体的递推公式：

      1. **假设我们已经知道 11 个人时胜利者的下标位置为 6**，**在求下一轮 10 个人时**，**由于第一轮删掉编号为 3 的人后**，**之后的人都往前面移动了 3 位**，**胜利者也往前移动了 3 位**，**所以最终胜利者的下标位置由 6 变成 3**。
      2. **假设我们已经知道 10 个人时胜利者的下标位置为 3**，**求上一轮 11 个人时胜利者的下标位置可以看作是上一问题的逆过程**，**大家都往后移动 3 位**，**所以 $f(11, 3) = f(10, 3) + 3$**，**不过有可能数组会越界**，**所以最后模上当前人数的个数**，**即 $f(11, 3) = f(10, 3) \% 11$**。
      3. **现在人数改为 $N$**，**报到 $M$ 时**，**把那个人杀掉**，**因为每杀掉一个人**，**下一个人成为头**，**相当于把数组向前移动 $M$ 位**，**若已知 $N - 1$ 个人时**，**胜利者的下标位置为 $f(N - 1, M)$**，**则 $N$ 个人的时候**，**就是往后移动 $M$ 位**，**因为有可能数组越界**，**越界的部分会被接到头上**，**所以还要模 $N$**，**即 $f(N, M) = (f(N - 1, M) + M) \% n$**。
   5. 因此最终的递推公式为：

      $$
      f(N, M) = (f(N - 1, M) + M) \% n
      $$

## 3 参考代码

```java
/**
 * 剑指 Offer 62. 圆圈中最后剩下的数字
 * @param n 数字的个数
 * @param m 删除数字时的间隔
 * @return  圆圈里剩下的最后一个数字
 */
public int lastRemaining(int n, int m) {
    int dp = 0;
    for (int i = 2; i <= n; i++) {
        dp = (dp + m) % i;
    }
    return dp;
}
```

## 参考文献

1. [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)。
2. [约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)。



<h1 style='page-break-before: always;'>1.9.11 不用加减乘除做加法</h1>

## 1 题目

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

**示例:**

```txt
输入: a = 1, b = 1
输出: 2
```

**提示：**

* a, b 均可能是负数或 0
* 结果不会溢出 32 位整数

## 2 问题分析

1. **设两数字的二进制形式 $a, b$**，**其求和 $s = a + b$**，$a_i$**代表 $a$ 的二进制第 $i$ 位**，则**分为以下四种情况**：

   | $a_i$ | $b_i$ | 无进位和$n_i$ | 进位$c_{i + 1}$ |
   | ------- | ------- | --------------- | ----------------- |
   | 0       | 0       | 0               | 0                 |
   | 0       | 1       | 1               | 0                 |
   | 1       | 0       | 1               | 0                 |
   | 1       | 1       | 0               | 1                 |
2. 观察发现，**无进位和与异或运算规律相同**，**进位和与运算规律相同**（**并需左移一位**），因此，**无进位和 $n$ 与进位 $c$ 的计算公式如下**：

   $$
   \left\{\begin{array}{l}n=a\oplus b\;\;\;\;\;\;\;\;\mathrm{非进位和}：\mathrm{异或运算}\\c=a\&b<<1\;\;\mathrm{进位}：\mathrm{与运算}+\mathrm{左移一位}\end{array}\right.
   $$
3. 此时，**两数字之和 $s$ 即可转化为**

   $$
   s = a + b = 非进位和 + 进位 = n + c
   $$
4. **循环求 $n$ 和 $c$**，**直至进位 $c = 0$**，**此时 $s = n$**，**返回 $n$ 即可**。

   ![Picture1.png](/media/202202/2022-02-12_1942570.5515300761805315.png)

## 3 参考代码

```java
/**
 * 剑指 Offer 65. 不用加减乘除做加法
 * @param a 第一个整数
 * @param b 第二个整数
 * @return  两个整数之和
 */
public int add(int a, int b) {
    int n = -1, c = -1;
    while (n != 0) {
        //  当进位为 0 时跳出
        //  进位
        n = (a & b) << 1;
        //  非进位和
        c = a ^ b;
        //  令 a 等于非进位和
        a = c;
        //  令 b 等于进位
        b = n;
    }
    //  返回非进位和
    return a;
}
```

## 参考文献

1. [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof)。
2. [ 面试题 65. 不用加减乘除做加法（位运算，清晰图解）](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7)。



<h1 style='page-break-before: always;'>1.10 设计</h1>

1.11 设计




<h1 style='page-break-before: always;'>1.10.0 LRU 缓存机制</h1>

## 1 题目

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
**实现 LRUCache 类：**

* LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
* int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
* void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶：** 你是否可以在 O(1) 时间复杂度内完成这两种操作？

**示例：**

```txt
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

* 1 <= capacity <= 3000
* 0 <= key <= 3000
* 0 <= value <= 104
* 最多调用 3 * 104 次 get 和 put

## 2 解题思路

> LRU 缓存机制的原理详见[最近最少使用法](https://notebook.ricear.com/project-26/doc-342/#2-5-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E6%B3%95-Least-Recently-Used--LRU-)。

### 2.1 双向链表

#### 2.1.1 问题解析

1. 这种方法采用的是**哈希表**和**双向链表**相结合的方式，其中哈希表中的**key**存储的是缓存的**key**，**value**存储的是**当前缓存在双向链表中的地址**。
2. 当执行 $get(key)$ 方法时：
   1. 如果 $map$ 中**不存在当前** $key$，则**直接返回-1**。
   2. 否则，**获取当前 $key$ 对应的节点**，并将其**移动到链表头部**，然后**返回当前节点对应的值**。
3. 当执行 $put(key,value)$ 方法时：
   1. 判断 $map$ 中**是否包含当前** $key$：
      
      1. 如果**不包含**的话，判断一下 $map$**中的容量是否大于等于**$capacity$：
         1. 如果 $map$ **中的容量大于或等于** $capacity$：
            1. **将尾部节点从链表中删除**。
            2. **根据 $(key,value)$ 创建一个节点**，并将当前节点**添加到链表头部**。
            3. **将 $key$ 对应的元素从 $map$ 中删除**。
         2. 如果 $map$ **中的容量小于** $capacity$：
            1. **根据 $(key,value)$ 创建一个节点**，并将当前节点**添加到链表头部**。
            2. **将对应的元素添加到 $map$ 中**。
      2. 如果包含的话：
         1. **更新链表中当前 $key$ 对应节点的** $value$。
         2. **将该节点移动到链表头部**。
      
      <iframe src="https://drive.google.com/file/d/1bHm2lwPDZNHXXegVCAEnBF1Y0twuoR7A/preview" width="100%" height="480" allow="autoplay" allowfullscreen="true"></iframe>

#### 2.1.2 参考代码

```java
class LRUCache {

    class DLinkNode {
        int key;
        int value;
        //  前驱结点
        DLinkNode prev;
        //  后驱节点
        DLinkNode next;

        DLinkNode() {
        }

        DLinkNode(int _key, int _value) {
            this.key = _key;
            this.value = _value;
        }
    }

    //  模仿 链头 和 链尾
    DLinkNode head, tail;
    //  存储 key 及其对应的链表
    HashMap<Integer, DLinkNode> map = new HashMap<>();

    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        //  初始化链表的头部和尾部
        head = new DLinkNode();
        tail = new DLinkNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        } else {
            //  获取当前 key 对应的节点，并将其移动至链表头部
            DLinkNode node = map.get(key);
            int value = node.value;
            moveToHead(key, node);
            return value;
        }
    }

    public void put(int key, int value) {
        if (map.size() >= capacity && !map.containsKey(key)) {

            //  将链表尾部的节点删除
            DLinkNode tmpNode = tail.prev;
            tmpNode.prev.next = tail;
            tail.prev = tmpNode.prev;
            map.remove(tmpNode.key);
        }
        if (!map.containsKey(key)) {
            //  将当前 key 对应的节点添加到链表头部
            DLinkNode node = new DLinkNode(key, value);
            map.put(key, node);
            addToHead(node);
        } else {
            //  更新当前 key 对应的元素并将其添加到链表头部
            moveToHeadAndUpdateValue(key, value);
        }
    }

    /**
     * 将当前节点添加到链表头部
     * @param node  当前节点
     */
    public void addToHead(DLinkNode node) {
        node.prev = head;
        node.next = head.next;
        head.next = node;
        node.next.prev = node;
    }

    /**
     * 更新当前 key 对应节点的值，然后将该节点移动到链表头部
     * @param key   key
     * @param value value
     */
    public void moveToHeadAndUpdateValue(int key, int value) {
        DLinkNode node = map.get(key);
        node.value = value;
        moveToHead(key, node);
    }

    /**
     * 将当前节点移动到链表头部
     * @param key   key
     * @param node  当前节点
     */
    public void moveToHead(int key, DLinkNode node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;

        head.next.prev = node;
        node.next = head.next;
        node.prev = head;
        head.next = node;
    }
}
```

#### 2.1.3 扩展题目

##### 2.1.3.1 线程安全的 LRU

###### 2.1.3.1.1 问题解析

1. 要实现线程安全主要在原来的基础上**将 `HashMap` 更改为 `ConcurrentHashMap`**，然后**在 `put` 和 `get` 操作的使用 `ReentrantLock` 进行加锁**即可。

###### 2.1.3.1.2 参考代码

```java
class LRUCache {

    class DLinkNode {
        int key;
        int value;
        //  前驱结点
        DLinkNode prev;
        //  后驱节点
        DLinkNode next;

        DLinkNode() {
        }

        DLinkNode(int _key, int _value) {
            this.key = _key;
            this.value = _value;
        }
    }

    //  模仿 链头 和 链尾
    DLinkNode head, tail;
    //  存储 key 及其对应的链表
    ConcurrentHashMap<Integer, DLinkNode> map = new ConcurrentHashMap<>();
    //  使用 ReadWriteLock 进行加锁，保证线程安全
    ReadWriteLock lock = new ReentrantReadWriteLock();
    Lock readLock = lock.readLock();
    Lock writeLock = lock.writeLock();

    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        //  初始化链表的头部和尾部
        head = new DLinkNode();
        tail = new DLinkNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        //  加读锁
        readLock.lock();
        try {
            if (!map.containsKey(key)) {
                return -1;
            } else {
                //  获取当前 key 对应的节点，并将其移动至链表头部
                DLinkNode node = map.get(key);
                int value = node.value;
                moveToHead(key, node);
                return value;
            }
        } finally {
            //  释放读锁
            readLock.unlock();
        }
    }

    public void put(int key, int value) {
        //  加写锁
        writeLock.lock();
        try {
            if (map.size() >= capacity && !map.containsKey(key)) {

                //  将链表尾部的节点删除
                DLinkNode tmpNode = tail.prev;
                tmpNode.prev.next = tail;
                tail.prev = tmpNode.prev;
                map.remove(tmpNode.key);
            }
            if (!map.containsKey(key)) {
                //  将当前 key 对应的节点添加到链表头部
                DLinkNode node = new DLinkNode(key, value);
                map.put(key, node);
                addToHead(node);
            } else {
                //  更新当前 key 对应的元素并将其添加到链表头部
                moveToHeadAndUpdateValue(key, value);
            }
        } finally {
            //  释放写锁
            writeLock.unlock();
        }
    }

    /**
     * 将当前节点添加到链表头部
     * @param node  当前节点
     */
    public void addToHead(DLinkNode node) {
        node.prev = head;
        node.next = head.next;
        head.next = node;
        node.next.prev = node;
    }

    /**
     * 更新当前 key 对应节点的值，然后将该节点移动到链表头部
     * @param key   key
     * @param value value
     */
    public void moveToHeadAndUpdateValue(int key, int value) {
        DLinkNode node = map.get(key);
        node.value = value;
        moveToHead(key, node);
    }

    /**
     * 将当前节点移动到链表头部
     * @param key   key
     * @param node  当前节点
     */
    public void moveToHead(int key, DLinkNode node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;

        head.next.prev = node;
        node.next = head.next;
        node.prev = head;
        head.next = node;
    }
}
```

##### 2.1.3.2 带有超时自动删除且线程安全的 LRU

###### 2.1.3.2.1 问题解析

> LRU 的超时自动删除策略可以参考 Reis 的[过期键删除策略](https://notebook.ricear.com/project-37/doc-812/#1-2-%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5)。

1. 可以使用一个**定时器线程池**来实现 LRU 的超时自动删除功能，**当添加一个元素时**，**同时将该元素及其对应的超时时间添加到定时器线程池中**，**然后当达到了超时时间时**，**定时器线程自动将该元素从 LRU 缓存中移除**。

###### 2.1.3.2.2 参考代码

```java
class LRUCache {

    class DLinkNode {
        int key;
        int value;
        //  前驱结点
        DLinkNode prev;
        //  后驱节点
        DLinkNode next;

        DLinkNode() {
        }

        DLinkNode(int _key, int _value) {
            this.key = _key;
            this.value = _value;
        }
    }

    //  模仿 链头 和 链尾
    DLinkNode head, tail;
    //  存储 key 及其对应的链表
    ConcurrentHashMap<Integer, DLinkNode> map = new ConcurrentHashMap<>();
    //  使用 ReadWriteLock 进行加锁，保证线程安全
    ReadWriteLock lock = new ReentrantReadWriteLock();
    Lock readLock = lock.readLock();
    Lock writeLock = lock.writeLock();

    ScheduledExecutorService scheduledExecutorService;

    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        //  初始化链表的头部和尾部
        head = new DLinkNode();
        tail = new DLinkNode();
        head.next = tail;
        tail.prev = head;
        //  初始化定时器线程池
        scheduledExecutorService = Executors.newScheduledThreadPool(capacity);
    }

    public int get(int key) {
        //  加读锁
        readLock.lock();
        try {
            if (!map.containsKey(key)) {
                return -1;
            } else {
                //  获取当前 key 对应的节点，并将其移动至链表头部
                DLinkNode node = map.get(key);
                int value = node.value;
                moveToHead(key, node);
                return value;
            }
        } finally {
            //  释放读锁
            readLock.unlock();
        }
    }

    public void put(int key, int value, long expireTime) {
        //  加写锁
        writeLock.lock();
        try {
            if (map.size() >= capacity && !map.containsKey(key)) {

                //  将链表尾部的节点删除
                DLinkNode tmpNode = tail.prev;
                tmpNode.prev.next = tail;
                tail.prev = tmpNode.prev;
                map.remove(tmpNode.key);
            }
            if (!map.containsKey(key)) {
                //  将当前 key 对应的节点添加到链表头部
                DLinkNode node = new DLinkNode(key, value);
                map.put(key, node);
                addToHead(node);
            } else {
                //  更新当前 key 对应的元素并将其添加到链表头部
                moveToHeadAndUpdateValue(key, value);
            }
            //  将元素添加到定时器线程池中
            if (expireTime > 0) {
                removeAfterExpireTime(key, expireTime);
            }
        } finally {
            //  释放写锁
            writeLock.unlock();
        }
    }

    /**
     * 将当前节点添加到链表头部
     * @param node  当前节点
     */
    public void addToHead(DLinkNode node) {
        node.prev = head;
        node.next = head.next;
        head.next = node;
        node.next.prev = node;
    }

    /**
     * 更新当前 key 对应节点的值，然后将该节点移动到链表头部
     * @param key   key
     * @param value value
     */
    public void moveToHeadAndUpdateValue(int key, int value) {
        DLinkNode node = map.get(key);
        node.value = value;
        moveToHead(key, node);
    }

    /**
     * 将当前节点移动到链表头部
     * @param key   key
     * @param node  当前节点
     */
    public void moveToHead(int key, DLinkNode node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;

        head.next.prev = node;
        node.next = head.next;
        node.prev = head;
        head.next = node;
    }

    /**
     * 自动删除 LRU 缓存中的过期元素
     * @param key   LRU 缓存的 key
     * @param expireTime    LRU 缓存的过期时间
     */
    private void removeAfterExpireTime(final int key, long expireTime) {
        final DLinkNode node = map.get(key);
        scheduledExecutorService.schedule(new Runnable() {
            public void run() {
                //  从双向链表中移除相应节点
                DLinkNode tmpNode = node.prev;
                tmpNode.next = node.next;
                node.next.prev = tmpNode;
                node.prev = null;
                node.next = null;
                //  从 map 中移除相应的元素
                map.remove(key);
            }
        }, expireTime, TimeUnit.MILLISECONDS);
    }
}
```

## 3 参考文献

1. [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache)。
2. [LRU 缓存机制【官方题解】](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution)。
3. [Thread-safe LRU Cache Implementation](https://leetcode.com/problems/lru-cache/discuss/1851511/thread-safe-lru-cache-implementation)。
4. [实现一个线程安全带超时时间的 lru(原版 + 变种)](https://leetcode.cn/problems/lru-cache/solution/by-sbsb1122333-kaw0)。
5. [Simple LRU cache with an expiration time](https://codereview.stackexchange.com/questions/60388/simple-lru-cache-with-an-expiration-time)。
6. [LRU 缓存实现案例](https://www.cnblogs.com/helloworldcode/p/13383856.html)。


<h1 style='page-break-before: always;'>高频面试题</h1>

2、高频面试题




<h1 style='page-break-before: always;'>2.0 数学</h1>

2.1 数学




<h1 style='page-break-before: always;'>2.0.0 快速模幂算法</h1>

今天来聊一道与数学运算有关的题目，LeetCode 372 题 Super Pow，需要我们进行巨大的幂运算，然后求余数。

```c++
int superPow(int a, vector<int>& b);
```

要求我们的算法返回幂运算 `a^b` 的计算结果与 1337 取模后的结果。首先我们需要计算 `a^b`，但是这个 `b` 会非常大，所以 `b` 是用数组的形式表示的。

### 2.1.1 处理数组指数

我们可以发现这样一个规律：
![](../../media/202103/2021-03-18_181448.png)

通过公式发现我们可以用递归来解决这个问题，因此问题的规模缩小了：

```c++
superPow(a, [1,5,6,4]) 
=> superPow(a, [1,5,6])
```

根据这个规律，我们可以写出如下代码框架：

```java
/**
     * 返回模幂运算 a^[b] 的计算结果与 base 取模后的结果
     *  1. a^[1024] = a^4 * a^[1020]
     *              = a^4 * (a^[102])^10
     * @param a 底数
     * @param b 指数
     * @param base  取模数
     * @return  模幂运算 a^b 的计算结果与 base 取模后的结果
     */
    public static int superPow(int a, Vector<Integer> b, int base) {
        if (b.size() == 0) {return 1;}
        Integer last = b.lastElement();
        b.removeElementAt(b.size() - 1);
        int part1 = myPow(a, last, base);
        int part2 = myPow(superPow(a, b, base), 10, base);
        //  每次乘法都要求模
        return (part1 * part2) % base;
    }
```

### 2.1.2 处理模运算

由于计算机的编码方式，形如 `(a * b) % base` 这样的运算，乘法的结果可能导致溢出，因此，我们需要找到一种技巧，能够简化这种表达式，以此来避免溢出同时得到结果。

模运算具有如下技巧：

```c++
(a * b) % k = (a % k)(b % k) % k
```

证明如下：

```txt
(a * b) % k = (a % k)(b % k) % k

a = Ak+B
b = Ck+D

a * b = (Ak + B) * (Ck+D)
      = ACk^2 + (BC + AD)k + BD

(a * b) % k = (ACk^2 + (BC + AD)k + BD) % k
            = ACk^2 % k + (BC + AD)k % k + BD % k
            = BD % k

a % k = B
b % k = D

(a % k)(b % k) % k = BD % k

(a * b) % k = (a % k)(b % k) % k
```

因此，对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模。对于该题来说，求一个数的幂就是对这个数连乘，通过将该思路进行扩展可以得到 `a 的 k 次方与 base 取模 ` 的算法，程序如下：

```java
/**
     * 计算 a 的 b 次方与 base 取模后的结果
     *  1. (a * b) % k = (a % k) * (b % k) % k
     * @param a 底数
     * @param k 指数
     * @param base  取模数
     * @return  a 的 b 次方与 base 取模后的结果
     */
    public static int myPow(int a, int k, int base) {
        int tmpRes = a % base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            //  这里有乘法，是潜在的溢出点
            res *= tmpRes;
            //  对乘法结果求模: 可以保证 res * tmpRes 这句代码执行时两个因子都是小于 base 的，也就一定不会造成溢出
            res %= base;
        }
        return res;
    }
```

完整程序如下：

```java
package com.grayson.top;

import org.apache.commons.lang3.time.StopWatch;

import java.util.Arrays;
import java.util.Collections;
import java.util.Vector;
import java.util.concurrent.TimeUnit;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/3/18 16:20
 * @Description 高效模幂算法
 */
public class SuperPow {

    /**
     * 计算 a 的 b 次方与 base 取模后的结果
     *  1. (a * b) % k = (a % k) * (b % k) % k
     * @param a 底数
     * @param k 指数
     * @param base  取模数
     * @return  a 的 b 次方与 base 取模后的结果
     */
    public static int myPow(int a, int k, int base) {
        int tmpRes = a % base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            //  这里有乘法，是潜在的溢出点
            res *= tmpRes;
            //  对乘法结果求模: 可以保证 res * tmpRes 这句代码执行时两个因子都是小于 base 的，也就一定不会造成溢出
            res %= base;
        }
        return res;
    }

    /**
     * 返回模幂运算 a^[b] 的计算结果与 base 取模后的结果
     *  1. a^[1024] = a^4 * a^[1020]
     *              = a^4 * (a^[102])^10
     * @param a 底数
     * @param b 指数
     * @param base  取模数
     * @return  模幂运算 a^b 的计算结果与 base 取模后的结果
     */
    public static int superPow(int a, Vector<Integer> b, int base) {
        if (b.size() == 0) {return 1;}
        Integer last = b.lastElement();
        b.removeElementAt(b.size() - 1);
        int part1 = myPow(a, last, base);
        int part2 = myPow(superPow(a, b, base), 10, base);
        //  每次乘法都要求模
        return (part1 * part2) % base;
    }

    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch();

        stopWatch.start();
        Vector<Integer> vector = new Vector<>();
        vector.addAll(Arrays.asList(3));
        int base = 3;
        int res = superPow(2, vector, base);
        stopWatch.stop();
        System.out.println(String.format("结果为: %s, 执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        vector.removeAllElements();
        vector.addAll(Arrays.asList(3));
        base = 7;
        res = superPow(4, vector, base);
        stopWatch.stop();
        System.out.println(String.format("结果为: %s, 执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        vector.removeAllElements();
        vector.addAll(Arrays.asList(1, 0, 2, 4));
        base = 1337;
        res = superPow(2, vector, base);
        stopWatch.stop();
        System.out.println(String.format("结果为: %s, 执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));
    }

}
```




<h1 style='page-break-before: always;'>2.0.1 搜索二维矩阵</h1>

## 1 题目

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
**示例 1：**

![](../../media/202103/2021-03-30_214631.png)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![](../../media/202103/2021-03-30_214654.png)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**提示：**

* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 100
* -104 <= matrix[i][j], target <= 104

## 2 解题思路

### 2.1 普通遍历

#### 2.1.1 问题分析

由于矩阵每行中的整数从左到右按升序排列，每行的第一个整数大于前一行的最后一个整数，因此我们可以按照如下方法来遍历：

1. 先按行遍历，看每行的第一个元素是否等于目标元素，如果不等于，则找出第一个元素小于等于目标元素，最后一个元素大于等于目标元素的行。
   1. 如果能找到这样的行的话，则直接返回 `true`。
   2. 如果找不到这样的行的话，则直接返回 `false`。

上面的遍历方法时间复杂度较高，可以使用二分查找的方法代替普通查找，这就是下面要用的二分查找法。

#### 2.1.2 参考代码

```java
/**
     * 74. 搜索二维矩阵（版本 1）
     * 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
     *  1. 每行中的整数从左到右按升序排列。
     *  2. 每行的第一个整数大于前一行的最后一个整数。
     * @param matrix    矩阵
     * @param target    目标值
     * @return  矩阵中是否存在目标值
     */
    public boolean searchMatrixV1(int[][] matrix, int target) {
        //  如果矩阵的长度小于 1，则直接返回 false
        if (matrix.length < 1) {return false;}
        //  如果矩阵第一个数组的长度小于 1，则直接返回 false
        if (matrix[0].length < 1) {return false;}
        //  如果矩阵的第一个元素大于目标值，最后一个元素小于目标值，则直接返回 false
        if (matrix[0][0] > target || matrix[matrix.length - 1][matrix[matrix.length - 1].length - 1] < target) {return false;}
        for (int i = 0; i < matrix.length; i++) {
            //  如果目标值在这一行矩阵中，则直接遍历这一行即可
            if (matrix[i][0] <= target && matrix[i][matrix[i].length - 1] >= target) {
                for (int i1 = 0; i1 < matrix[i].length; i1++) {
                    if (matrix[i][i1] == target) {return true;}
                }
            }
        }
        return false;
    }
```

### 2.2 二分查找（一）

#### 2.2.1 问题分析

由于涉及到查找元素，所以我们可以考虑使用二分查找法来判断矩阵中是否含有目标元素，具体如下：

1. 通过[寻找左侧边界的二分查找法](http://notebook.ricear.com/project-21/doc-90)找到不大于目标元素的一行。
2. 然后在该行中通过二分查找法判断这一行中是否含有目标元素。

#### 2.2.2 参考代码

```java
/**
     * 74. 搜索二维矩阵（版本 2：二分法）
     * 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
     *  1. 每行中的整数从左到右按升序排列。
     *  2. 每行的第一个整数大于前一行的最后一个整数。
     * @param matrix    矩阵
     * @param target    目标值
     * @return  矩阵中是否存在目标值
     */
    public boolean searchMatrixV2(int[][] matrix, int target) {
        //  先采用二分法搜索所有行
        int left = 0, right = matrix.length - 1;
        while (left <= right) {
            //  为了防止 (left + right) 太大导致溢出
            int mid = left + (right - left) / 2;
            if (matrix[mid][0] < target) {left = mid + 1;}
            else if (matrix[mid][0] > target) {right = mid -1;}
            else if (matrix[mid][0] == target) {return true;}
        }

        //  然后采用二分法搜索当前行的所有列
        int col = left - 1;
        if (col == -1) {return false;}
        left = 0;
        right = matrix[col].length - 1;
        while (left <= right) {
            //  为了防止 (left + right) 太大导致溢出
            int mid = left + (right - left) / 2;
            if (matrix[col][mid] < target) {left = mid + 1;}
            else if (matrix[col][mid] > target) {right = mid -1;}
            else if (matrix[col][mid] == target) {return true;}
        }

        //  目标值不存在矩阵中，返回 false
        return false;
    }
```

### 2.3 二分查找（二）

#### 2.3.1 问题分析

我们还可以把这个二维矩阵当做一维矩阵，然后通过二分查找的方法来判断矩阵中是否包含目标元素。

#### 2.3.2 参考代码

```java
/**
     * 74. 搜索二维矩阵（版本 3：二分法 2）
     * 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
     *  1. 每行中的整数从左到右按升序排列。
     *  2. 每行的第一个整数大于前一行的最后一个整数。
     * @param matrix    矩阵
     * @param target    目标值
     * @return  矩阵中是否存在目标值
     */
    public boolean searchMatrixV3(int[][] matrix, int target) {
        //  将二阶矩阵当做一阶矩阵，然后按照二分法来查找即可
        int m = matrix.length, n = matrix[0].length;
        int left = 0, right = m * n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            //  当前遍历到的元素所在列
            int col = mid % n;
            //  当前遍历到的元素所在行
            int row = (mid - col) < n ? 0 : (mid - col) / n;
            if (matrix[row][col] < target) {left = mid + 1;}
            else if (matrix[row][col] > target) {right = mid - 1;}
            else if (matrix[row][col] == target) {return true;}
        }
        //  矩阵中不存在目标元素，返回 false
        return false;
    }
```

### 2.4 BST

#### 2.4.1 问题分析

![](../../media/202103/2021-03-31_210932.png)

我们可以将二维矩阵抽象成**以右上角为根的 BST**，那么我们可以从根（右上角）开始搜索，如果当前节点不等于目标值，可以按照树的搜索顺序进行：

1. 当前节点**大于**目标值，搜索当前节点的**左子树**，也就是当前矩阵位置的**左方格子**，即 `y--`。
2. 当前节点**小于**目标值，搜索当前节点的右**子树**，也就是当前矩阵位置的右**方格子**，即 `x++`。

#### 2.4.2 参考代码

```java
int m, n;

    /**
     * 递归二叉树判断二维矩阵中是否含有目标元素
     * @param matrix    二维矩阵
     * @param x 横坐标
     * @param y 纵坐标
     * @param target    目标值
     * @return  二维矩阵中是否含有目标元素
     */
    public boolean check(int[][] matrix, int x, int y, int target) {
        if (x < 0 || x >= m || y < 0 || y >= n) {return false;}
        if (matrix[x][y] == target) {return true;}
        boolean res = check(matrix, x + 1, y, target);
        if (!res) {res = check(matrix, x, y - 1, target);}
        return res;
    }

    /**
     * 74. 搜索二维矩阵（版本 4：二叉树）
     * 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
     *  1. 每行中的整数从左到右按升序排列。
     *  2. 每行的第一个整数大于前一行的最后一个整数。
     * @param matrix    矩阵
     * @param target    目标值
     * @return  矩阵中是否存在目标值
     */
    public boolean searchMatrixV4(int[][] matrix, int target) {
        m = matrix.length;
        n = matrix[0].length;
        int x = 0, y = n - 1;
        return check(matrix, x, y, target);
    }
```

## 3 参考文献

1. [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix)
2. [【宫水三叶】一题双解：「二分」&amp;「抽象 BST」解法](https://leetcode-cn.com/problems/search-a-2d-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-l0pq)。
3. 解题思路 `2.1、2.2、2.3` 来自于[@宫水三叶](https://leetcode-cn.com/u/ac_oier)。




<h1 style='page-break-before: always;'>2.0.2 x 的平方根</h1>

## 1 题目

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```txt
输入: 4
输出: 2
```

**示例 2:**

```txt
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...,
     由于返回类型是整数，小数部分将被舍去。
```

## 2 解题思路

### 2.1 暴力解法

#### 2.1.1 问题分析

1. 暴力解法的基本思路是因为 $i * i = x$，因此 $x / i >= i$ 并且 $x / (i + 1) < (i + 1)$。

#### 2.1.2 参考代码

```java
/**
 * 69. x 的平方根（版本 1：暴力解法）
 * @param x 待求整数
 * @return  x 的平方根的整数部分
 */
public int mySqrtV1(int x) {
    if (x == 0) {return 0;}
    if (x == 1) {return 1;}
    for (int i = 1; i <= x / 2; i++) {
        if (x / i >= i && x / (i + 1) < (i + 1)) {
            return i;
        }
    }
    return -1;
}
```

### 2.2 袖珍计算器算法

#### 2.2.1 问题分析

1. 袖珍计算器算法是一种**用指数函数**$exp$**和对数函数**$ln$**代替平方根函数**的方法，我们**通过有限的可以使用的数学函数**，**得到我们想要的计算结果**。
2. 我们将 $\sqrt x$ 写成幂的形式 $x^{\frac12}$，再使用自然对数 $e$ 进行换底，即可得到
   
   $$
   \sqrt x = x^{\frac12} = (e^{lnx})^{\frac12}
   $$
3. 由于计算机无法存储浮点数的精确值，而指数函数和对数函数的参数返回值均为浮点数，因此运算过程中会存在误差：
   
   1. 例如当 $x=2147395600$ 时，$e^{\frac12{lnx}}$ 的计算结果与正确值 46340 相差 $ 10^{-11} $，这样在对结果取整数部分时，会得到 46399 这个错误的结果。
4. 因此在得到结果的整数部分 $ans$ 时后，我们应当找出 $ans$ 与 $ans + 1$ 中哪一个是真正的答案。

#### 2.2.2 参考代码

```java
/**
 * 69. x 的平方根（版本 2：袖珍计算器算法）
 * @param x 待求整数
 * @return  x 的平方根的整数部分
 */
public int mySqrtV2(int x) {
    //  袖珍计算器公式：x^(1/2) = e^(0.5 * lnx)
    int res = (int)Math.exp(0.5 * Math.log(x));
    return x / (res + 1) < (res + 1) ? res : (res + 1);
}
```

### 2.3 二分查找法

#### 2.3.1 问题分析

1. 题目实际上是找到一个数 $num$ 使得：
   
   $$
   num * num \le x
   $$
   
   并且
   
   $$
   (num + 1) * (num + 1) \gt x
   $$
   
   而这个数一定不大于 $\frac12 x$。
2. 因此题目实际上可以看做查找一个 $num \in [1, \frac12 x]$ 符合上述条件，因此可以采用二分法来进行查找。

#### 2.3.2 参考代码

```java
/**
 * 69. x 的平方根（版本 3：二分查找法）
 * @param x 待求整数
 * @return  x 的平方根的整数部分
 */
public int mySqrtV3(int x) {
    if (x == 1) {return 1;}
    int left = 1, right = x / 2, res = 0;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if ((long)mid * mid <= x) {
            res = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return  res;
}
```

### 2.4 牛顿迭代法

#### 2.4.1 问题分析

1. 牛顿迭代法是一种可以用来快速求解函数零点的方法。
2. 为了叙述方便，我们用 $C$ 表示待求出平方根的那个整数，显然，$C$ 的平方根就是函数
   
   $$
   y = f(x) = x^2 - C
   $$
   
   的零点。
3. 牛顿迭代法的本质是借助泰勒级数，从初始值快速向零点逼近：
   
   1. 我们任取一个 $x_0$ 作为初始值，在每一步的迭代中，我们找到函数图像上的点 $(x_i, f(x_i))$，过该点做一条斜率为该点导数 $f^{'}(x_i)$ 的直线，与横轴的交点记为 $x_{i + 1}$，$x_{i + 1}$ 相较于 $x_i$ 而言距离零点更近。
   2. 在经过多次迭代后，我们就可以得到一个距离零点非常接近的交点，下图给出了从 $x_0$ 开始迭代两次，得到 $x_1$ 和 $x_2$ 的过程。
      
      ![fig1](/media/202107/2021-07-11_1944290.35472416583845645.png)
4. 我们选择 $x_0 = C$ 作为初始值，在每一步迭代中，我们通过当前交点 $x_i$，找到图像上的点 $(x_i, x_i^2 - C)$，作一条斜率为 $f^{'}(x_i) = 2x_i$ 的直线，直线的方程为
   
   $$
   y - (x_i^2 - C) = 2x_i(x - x_i)
   $$
   
   化简后得
   
   $$
   y = 2x_ix - (x_i^2 + C)
   $$
   
   与横轴的交点为方程
   
   $$
   2x_ix - (x_i^2 + C) = 0
   $$
   
   的解，即为新的迭代结果 $x_{i + 1}$：
   
   $$
   x_{i + 1} = \frac12 (x_i + \frac{C}{x_i})
   $$
   
   在进行 $k$ 次迭代后，$x_k$ 的值与真实的零点 $\sqrt C$ 足够接近，即可作为答案。

> 细节：
> 
> 1. 为什么选择 $ x_0 = C $ 作为初始值？
>    因为 $y = x^2 - C$ 有两个零点 $-\sqrt C$ 和 $\sqrt C$，如果我们取得初始值较小，可能会迭代到 $-\sqrt C$ 这个零点，而我们希望找到的是 $\sqrt C$ 这个零点，因此选择 $x_0 = C$ 作为初始值，每次迭代均有 $x_{i + 1} < x_i$，零点 $\sqrt C$ 在其左侧，所以我们一定会迭代到这个零点。
> 2. 迭代到何时才算结束？
>    每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定，此时的结果已经足够我们得到答案了，一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 $\varepsilon$，其中 $\varepsilon$ 一般可以取 $ 10^{-6} $ 或 $ 10^{-7} $。

#### 2.4.2 参考代码

```java
/**
 * 69. x 的平方根（版本 4：牛顿迭代法）
 * @param x 待求整数
 * @return  x 的平方根的整数部分
 */
public int mySqrtV4(int x) {
    if (x == 0) {return 0;}
    double err = 1e-7;
    return (int)sqrt(x, x, err);
}
```

## 3 参考文献

1. [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx)。
2. [x 的平方根](https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution)。




<h1 style='page-break-before: always;'>2.1 二分查找</h1>

2.2 二分查找




<h1 style='page-break-before: always;'>2.2 数组</h1>

2.3 数组




<h1 style='page-break-before: always;'>2.2.0 如何寻找消失的元素</h1>

## 1 题目

数组 nums 包含从 0 到 n 的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在 O(n)时间内完成吗？

**注意：** 本题相对书上原题稍作改动

**示例 1：**

```
输入：[3,0,1]
输出：2
```

**示例 2：**

```
输入：[9,6,4,2,3,5,7,0,1]
输出：8
```

## 2 不同解法

### 2.1 方法一：位运算

对于异或运算（`^`），我们知道他有一个特殊的性质：**一个数和他本身做异或运算结果为 0，一个数和 0 做异或运算还是他本身。**

而且异或运算满足**交换律**和**结合律**，也就是说：

```
2^3^2 = 3^(2^2) = 3^0 = 3
```

而这道题就可以通过这些性质巧妙算出缺失的那个元素。比如说 `nums = [0, 3, 1, 4]`：

![](../../media/202103/2021-03-25_172056.png)

为了容易理解，我们假设先把索引补一位，让后让每个元素和自己相等的索引相对应：

![](../../media/202103/2021-03-25_172332.png)

这样做了之后，就可以发现除了缺失元素之外，所有的索引和元素都组成一对儿了，现在如果把这个落单的索引 2 找出来，也就找到了缺失的那个元素。

如何找这个落单的数字呢，**只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下**，这也就达到了我们的目的。

```java
/**
     * 面试题 17.04. 消失的数字（版本 2：位运算）
     * @param nums  数字集合
     * @return
     */
    public int missingNumberV2(int[] nums) {
        int res = 0;
        int n = nums.length;
        res ^= n;
        for (int i = 0; i < n; i++) {
            res ^= i ^ nums[i];
        }
        return res;
    }
```

![](../../media/202103/2021-03-25_214307.png)

由于**异或运算满足交换律和结合律**，所以总是能把成对儿的数字消去，留下缺失的那个元素。

### 2.2 方法二：等差数列

题目的意思我们可以这样理解：现在有个等差数列 `[0,1,2..n]`，其中少了某一个数字，需要我们把它找出来，这个数字就是 `sum(0,1,2..n)-sum(nums)`。

```java
/**
     * 面试题 17.04. 消失的数字（版本 3：等差数列）
     * @param nums  数字集合
     * @return
     */
    public int missingNumberV3(int[] nums) {
        int res = 0;
        int n = nums.length;
        //  求和公式：(首项 + 某项) * 元素个数 / 2
        int expect = (0 + n) * (n + 1) / 2;
        for (int i = 0; i < n; i++) {
            res += nums[i];
        }
        return expect - res;
    }
```

但是我们需要考虑的是在用求和公式计算 `expect` 时可能会出现相乘的结果太大导致**整型溢出**的情况。我们刚才的思路是把两个和都加起来然后相减，为了避免溢出，干脆一边求和一边减算了。很类似刚才位运算解法的思路，仍然假设 `nums = [0, 3, 1, 4]`，先补一位索引再让元素跟索引配对：

![](../../media/202103/2021-03-25_215746.png)

我们让每个索引减去其对应的元素，再把相减的结果加起来，就是那个缺失的元素。

```java
/**
     * 面试题 17.04. 消失的数字（版本 1）
     * @param nums  数字集合
     * @return
     */
    public int missingNumberV1(int[] nums) {
        int res = 0;
        int n = nums.length;
        res += n - 0;
        for (int i = 0; i < n; i++) {
            res += i - nums[i];
        }
        return res;
    }
```




<h1 style='page-break-before: always;'>2.2.1 如何寻找缺失和重复的元素</h1>

## 1 题目

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

## 2 问题解析

这个问题的特点是，每个元素和数组索引有一定的对应关系，。

我们可以暂且将 `nums` 中的元素变为 `[0..N-1]`，这样每个元素就和一个数组索引完全对应了，这样方便理解一些。

现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会**导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去**。

所以我们如果可以**通过某种方法，找到那个重复元素对应的索引，也就相当于找到了那个重复元素，找到那个没有元素对应的索引，也就找到了那个缺失的元素**。

我们可以**通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了**。
![](../../media/202103/2021-03-26_164924.png)

如果出现重复元素 `4`，直观结果就是，索引 `4` 所对应的元素已经是负数了。

![](../../media/202103/2021-03-26_165431.png)

对于缺失元素 `3`，直观结果就是，索引 `3` 所对应的元素是正数。

![](../../media/202103/2021-03-26_172419.png)

对于这种数组问题，**关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射**。

## 3 参考代码

```java
package com.grayson.top;

import org.apache.commons.lang3.time.StopWatch;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/3/26 14:32
 * @Description 错误的集合
 */
public class L645 {

    /**
     * 645. 错误的集合（版本 2）
     * 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
     * 给定一个数组 nums 代表了集合 S 发生错误后的结果。
     * 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
     * @param nums  集合
     * @return  重复出现的整数和丢失的整数组成的集合
     */
    public static int[] findErrorNumsV2(int[] nums) {
        int n = nums.length;
        int dup = -1, missing = -1;
        for (int i = 0; i < n; i++) {
            int index = Math.abs(nums[i]) - 1;
            //  相当于在集合后面又加了一个元素 0
            if (nums[index] < 0) {
                dup = index + 1;
            } else {
                nums[index] *= -1;
            }
        }

        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                missing = i + 1;
                break;
            }
        }
        return new int[]{dup, missing};
    }

    /**
     * 645. 错误的集合（版本 1）
     * 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
     * 给定一个数组 nums 代表了集合 S 发生错误后的结果。
     * 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
     * @param nums  集合
     * @return  重复出现的整数和丢失的整数组成的集合
     */
    public static int[] findErrorNumsV1(int[] nums) {
        //  结果集合
        int[] res = new int[2];

        //  1. 对数组进行排序
        Arrays.sort(nums);

        //  2. 对数组进行遍历，找出重复出现的整数和丢失的整数
        if (nums[0] > 1) {res[1] = 1;}
        if (nums[nums.length - 1] < nums.length) {res[1] = nums.length;}
        if (nums.length == 2 && nums[1] == nums[0]) {res[0] = nums[0]; res[1] = (nums[1] == 1 ? 2 : 1);}
        for (int i = 1; i < nums.length; i++) {
            //  2.1 如果 nums[i] - nums[i - 1] == 0，则 nums[i - 1] 为重复的元素
            if (0 == nums[i] - nums[i - 1]) {res[0] = nums[i - 1];}
            //  2.2 如果 nums[i] - nums[i - 1] == 2，则 nums[i] - 1 即为丢失的整数
            if (nums[i] - nums[i - 1] == 2) {res[1] = nums[i] - 1;}
            //  2.3 如果重复出现的整数和丢失的整数都已经找到，则直接返回结果
            if (res[0] != 0 && res[1] != 0) {return res;}
        }

        //  3. 返回结果
        return res;
    }

    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch();

        stopWatch.start();
//        int[] nums = {1, 3, 3};
//        int[] nums = {3,2,3,4,6,5};
//        int[] nums = {1,2,2,4};
        int[] nums = {3,5,9,4,1,2,7,8,1};
        int[] res = findErrorNumsV2(nums);
        stopWatch.stop();
        System.out.println(String.format("测试用例 1 结果为：%s，执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));
    }

}
```




<h1 style='page-break-before: always;'>2.2.2 找出数组游戏的赢家</h1>

## 1 题目

给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。

每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。

返回赢得比赛的整数。

题目数据 保证 游戏存在赢家。

**示例 1：**

```
输入：arr = [2,1,3,5,4,6,7], k = 2
输出：5
解释：一起看一下本场游戏每回合的情况：因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。
```

**示例 2：**

```
输入：arr = [3,2,1], k = 10
输出：3
解释：3 将会在前 10 个回合中连续获胜。
```

**示例 3：**

```
输入：arr = [1,9,8,2,3,7,6,4,5], k = 7
输出：9
```

**示例 4：**

```
输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
输出：99
```

**提示：**

* 2 <= arr.length <= 10^5
* 1 <= arr[i] <= 10^6
* arr 所含的整数 各不相同 。
* 1 <= k <= 10^9

## 2 解题思路

### 2.1 常规解法

#### 2.1.1 问题解析

按照题目所述，**每次将较小的元素移动到数组的最后，将较大的元素放到数组的第一位，但是这样做会超时**。

#### 2.1.2 参考代码

```java
/**
 * 将指定位置的数移到数组的某尾
 * @param arr   数组
 * @param i 指定位置
 * @return  移动元素后的数组
 */
public int[] moveToLast(int[] arr, int i) {
    int temp = arr[i];
    int n = arr.length;
    for (int j = i;j <= n - 2;j++) {
        arr[j] = arr[j + 1];
    }
    arr[n - 1] = temp;
    return arr;
}

/**
 * 1535. 找出数组游戏的赢家（版本 1：常规解法）
 * 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
 * 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
 * 返回赢得比赛的整数。
 * 题目数据 保证 游戏存在赢家。
 * @param arr   数组
 * @param k 需要连续赢得回合的次数
 * @return  赢得比赛的整数
 */
public int getWinnerV1(int[] arr, int k) {
    //  定义赢取回合的元素和赢取回合的次数
    int winNum = 0, winCount = 0;
    while (true) {
        if (arr[0] > arr[1]) {
            //  第一个元素大于第二个元素
            if (arr[0] == winNum) {
                //  如果和上一个赢取回合的元素一样，则将其赢取回合的次数加 1
                winCount++;
                //  如果一个元素赢取回合的次数等于 k，则返回第一个元素
                if (winCount == k) {return arr[0];}
            } else {
                //  如果和上一个赢取回合的元素不一样，则将第一个元素置为赢取回合的元素，同时将赢取回合的次数加 1
                winNum = arr[0];
                winCount = 1;
            }
            //  将第 1 个元素移到最后一个位置
            moveToLast(arr, 1);
        } else {
            //  第二个元素大于第一个元素
            if (arr[1] == winNum) {
                //  如果和上一个赢取回合的元素一样，则将其赢取回合的次数加 1
                winCount++;
                //  如果一个元素赢取回合的次数等于 k，则返回第二个元素
                if (winCount == k) {return arr[1];}
            } else {
                //  如果和上一个赢取回合的元素不一样，则将第二个元素置为赢取回合的元素，同时将赢取回合的次数加 1
                winNum = arr[1];
                winCount = 1;
            }
            //  将第一个元素和第二个元素互换位置
            int temp = arr[0];
            arr[0] = arr[1];
            arr[1] = temp;
            //  将第 2 个元素移到最后一个位置
            moveToLast(arr, 1);
        }
    }
}
```

### 2.2 单链表解法

#### 2.2.1 问题解析

**将数组中的元素先存储在单链表中，然后每次将较小的元素移动到单链表的尾部，将较大的元素移动到单链表的头部，相比于 2.1 中的常规解法来说，这种解法移动元素的时间复杂度较低，但是空间复杂度较高，因为需要多余的空间来存储数组中的元素，同时该算法也会超时。**

#### 2.2.2 参考代码

```java
/**
 * 1535. 找出数组游戏的赢家（版本 2：单链表）
 * 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
 * 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
 * 返回赢得比赛的整数。
 * 题目数据 保证 游戏存在赢家。
 * @param arr   数组
 * @param k 需要连续赢得回合的次数
 * @return  赢得比赛的整数
 */
public int getWinnerV2(int[] arr, int k) {
    //  定义赢取回合的元素和赢取回合的次数
    int winNum = 0, winCount = 0, n = arr.length;;

    ListNode head = new ListNode(), p = head, tail = null;
    for (int i = 0; i < n; i++) {
        ListNode node = new ListNode(arr[i]);
        p.next = node;
        p = node;
        if (i == n - 1) {
            tail = p;
        }
    }
    head = head.next;

    p = head;
    while (true) {
        int first = p.val;
        int second = p.next.val;
        if (first > second) {
            //  第一个元素大于第二个元素
            if (first == winNum) {
                //  如果和上一个赢取回合的元素一样，则将其赢取回合的次数加 1
                winCount++;
                //  如果一个元素赢取回合的次数等于 k，则返回第一个元素
                if (winCount == k) {return first;}
            } else {
                //  如果和上一个赢取回合的元素不一样，则将第一个元素置为赢取回合的元素，同时将赢取回合的次数加 1
                winNum = first;
                winCount = 1;
            }
            //  将第 2 个元素移到最后一个位置
            ListNode q = p.next;
            p.next = q.next;
            tail.next = q;
            q.next = null;
            tail = q;
        } else {
            //  第二个元素大于第一个元素
            if (second == winNum) {
                //  如果和上一个赢取回合的元素一样，则将其赢取回合的次数加 1
                winCount++;
                //  如果一个元素赢取回合的次数等于 k，则返回第二个元素
                if (winCount == k) {return second;}
            } else {
                //  如果和上一个赢取回合的元素不一样，则将第二个元素置为赢取回合的元素，同时将赢取回合的次数加 1
                winNum = second;
                winCount = 1;
            }
            //  将第一个元素和第二个元素互换位置
            ListNode q = p.next;
            p.next = q.next;
            q.next = p;
            p = q;
            //  将第 2 个元素移到最后一个位置
            q = p.next;
            p.next = q.next;
            tail.next = q;
            q.next = null;
            tail = q;
        }
    }
}
```

### 2.3 优化解法

#### 2.3.1 问题解析

根据题目描述，每回合游戏之后，较小的整数移至数组的某尾，其实，并不需要对数组进行更新：

1. 在第一回合游戏之后，无论 $arr[0]$ 和 $arr[1]$ 当中谁取得胜利，第二回合游戏的另一个整数一定是 $arr$ 中的下一个整数。
2. 推广到一般的情况，当 $ 2 \le i \lt arr.length$ 时，第 $i$ 回合的游戏一定在第 $i-1$ 回合游戏中取得胜利的整数和 $arr[i]$ 之间进行。

因此，我们只需要记录一下第 $i-1$ 回合中取得胜利的整数 $winNum$ 以及截止到当前连胜的回合次数 $winCount$：

1. 当 $arr[i]$ 大于 $winNum$ 时，将 $winNum$ 更新为 $arr[i]$，同时将 $winCount$ 置为 1。
2. 当 $arr[i]$ 小于 $winNum$ 时，将 $winCount$ 加 1，同时判断 $winCount$ 是否大于等于 $k$，如果是的话，直接返回 $arr[i]$ 即可。

#### 2.3.2 参考代码

```java
/**
 * 1535. 找出数组游戏的赢家（版本 3：不用移动元素，挨个遍历）
 * 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
 * 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
 * 返回赢得比赛的整数。
 * 题目数据 保证 游戏存在赢家。
 * @param arr   数组
 * @param k 需要连续赢得回合的次数
 * @return  赢得比赛的整数
 */
public int getWinnerV3(int[] arr, int k) {
    int winNum = arr[0], winCount = 0;
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > winNum) {
            winNum = arr[i];
            winCount = 1;
        } else {winCount++;}
        if (winCount >= k) {break;}
    }
    return winNum;
}
```

## 3 参考文献

1. [1535. 找出数组游戏的赢家](https://leetcode-cn.com/problems/find-the-winner-of-an-array-game)。
2. [找出数组游戏的赢家『官方解法』](https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/solution/zhao-chu-shu-zu-you-xi-de-ying-jia-by-leetcode-sol)。




<h1 style='page-break-before: always;'>2.2.3 二维数组中的查找</h1>

## 1 题目

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**示例:**

现有矩阵 matrix 如下：

```
[
[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]
]
```

给定 target = 5，返回 true。

给定 target = 20，返回 false。

**限制：**

* 0 <= n <= 1000
* 0 <= m <= 1000

## 2 解题思路

如下图所示，我们将矩阵逆时针旋转 45 度，并将其转化为图形式，发现其类似于**二叉搜索树**，即对于每个元素，其左分支元素更小，右分支元素更大。因此，通过从“根节点”开始搜索，遇到比 `target` 大的元素就向左，反之向右，即可找到目标值 `target`。

![Picture1.png](/media/202104/2021-04-27_213722.png)

## 3 参考代码

```java
package com.grayson.top.codinginterviews;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/27 20:05
 * @Description
 */
public class CI4 {
    /**
     * 剑指 Offer 04. 二维数组中的查找
     * @param matrix    二维数组
     * @param target    目标值
     * @return  二维数组中是否含有目标值
     */
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length < 1) {return false;}
        int x = 0, y = matrix[0].length - 1;
        /**
         * 将矩阵逆时针旋转 45 度，然后将其视为二叉搜索树，然后按照二分查找法来查找元素即可
         */
        while (y >= 0 && x < matrix.length) {
            if (matrix[x][y] > target) {
                y--;
            } else if (matrix[x][y] < target) {
                x++;
            } else if (matrix[x][y] == target) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        CI4 ci4 = new CI4();
        int[][] matrix = {
                {1, 4, 7, 11, 15},
                {2, 5, 8, 12, 19},
                {3, 6, 9, 16, 22},
                {10, 13, 14, 17, 24},
                {18, 21, 23, 26, 30}
        };
//        int[][] matrix = {
//                {-1, 3}
//        };
        int target = 5;
        boolean res = ci4.findNumberIn2DArray(matrix, target);
        System.out.println(res);
    }
}
```

## 4 参考文献

1. [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof)。
2. [面试题 04. 二维数组中的查找（标志数，清晰图解）](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo)。




<h1 style='page-break-before: always;'>2.2.4 三数之和</h1>

## 1 题目

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例 1：**

```txt
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```txt
输入：nums = []
输出：[]
```

**示例 3：**

```txt
输入：nums = [0]
输出：[]
```

**提示：**

* 0 <= nums.length <= 3000
* -105 <= nums[i] <= 105

## 2 解题思路

### 2.1 双指针法

#### 2.1.1 问题解析

1. 先对原来的数组进行排序。
2. 假设数组 $nums$ 的长度为 $len$。
3. 首先固定一个点 $nums[i]$，进行第一次去重，如果 $nums[i]==nums[i+1]$，则进行下一个循环。
4. 然后分别定义左、右指针：

$$
left = i + 1
$$

$$
right = len - 1
$$

5. 定义 $sum$：

$$
sum = nums[i] + nums[left] + nums[right]
$$

6. 对 $sum$ 进行判断：
   
   * 如果 $sum>0$，$left++$。
   * 如果 $sum < 0$，$right--$。
   * 如果 $sum = 0$，将 $[nums[i],nums[left],nums[right]]$ 添加到结果中，同时 $left++,right--$，然后进行第二次去重：
   
   $$
   while(left < right \space and \space nums[left] == nums[left+1]) \space left++
   $$
   
   $$
   while(left < right \space and \space nums[right] == nums[right-1]) \space right—
   $$
   
   ![](../../media/202105/15-三数之和（双指针法）_1621948196.gif)

#### 2.1.2 参考代码

```java
/**
 * 15. 三数之和
 * @param nums  数组
 * @return  和为 0 且不重复的三元组
 */
public List<List<Integer>> threeSum(int[] nums) {
    int len = nums.length, left, right, sum;
    List<List<Integer>> res = new ArrayList<>();
    //  如果数组的长度大于 3，说明不符合题意，直接返回空数组即可
    if (len < 3) {return res;}
    Arrays.sort(nums);
    for (int i = 0; i < len; i++) {
        //  如果第一个元素都大于 0， 说明后面的元素肯定大于 0，则三者之和肯定大于 0，继续进行下一个循环即可
        if (nums[i] > 0) {continue;}
        //  去重，如果第一个元素前后两个一样，则最后的结果可能和前面的结果重复
        if (i > 0 && nums[i] == nums[i - 1]) {continue;}
        left = i + 1;
        right = len - 1;
        while (left < right) {
            sum = nums[i] + nums[left] + nums[right];
            if (sum < 0) {
                left++;
            } else if (sum > 0) {
                right--;
            } else if (sum == 0) {
                res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                //  去重，如果左指针对应元素和其下一个元素相同，则最后的结果可能和前面的结果重复，直接将左指针向后面移动一位即可
                while (left < right && nums[left] == nums[left+1]) {left++;}
                //  去重，如果右指针对应元素和其上一个元素相同，则最后的结果可能和前面的结果重复，直接将右指针向前面移动一位即可
                while (left < right && nums[right] == nums[right-1]) {right--;}
                //  将左指针右移
                left++;
                //  将右指针左移
                right--;
            }
        }
    }
    return res;
}
```

## 3 参考文献

1. [15. 三数之和](https://leetcode-cn.com/problems/3sum)。
2. [画解算法：15. 三数之和](https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn)。




<h1 style='page-break-before: always;'>2.2.5 合并两个有序数组</h1>

## 1 题目

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

初始化 `nums1` 和 nums2 的元素数量分别为 `m` 和 `n` 。你可以假设 nums1 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

**示例 1：**

```txt
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```txt
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

**提示：**

* nums1.length == m + n
* nums2.length == n
* 0 <= m, n <= 200
* 1 <= m + n <= 200
* -109 <= nums1[i], nums2[i] <= 109

## 2 解题思路

### 2.1 从后向前

#### 2.1.1 问题分析

1. 初始时 $i=m-1$，$j=n-1$，$k=m+n-1$。
2. 如果 $i>=0$ 并且 $j>=0$：

   1. 如果 $nums2[j]>=nums1[i]$：将 $nums2[j]$ 放到 $nums1[k]$ 的位置上，同时将 $j$ 的值减 1。
   2. 如果 $nums1[i]>nums2[j]$：将 $nums1[i]$ 放到 $nums1[k]$ 的位置上，同时将 $i$ 的值减 1。
   3. 最后统一将 $k$ 的值减 1。
3. 如果最后 $i<0$，说明 $nums1$ 已经遍历完了，$nums2$ 还没有遍历完，此时 $nums1$ 的元素都已经移动到了对应的位置上，而且此时 $nums2$ 中剩余的元素都比 $nums1$ 中已经存在的元素小，因此将 $nums2$ 中还未遍历完的元素从 $nums1$ 的起始位置依次存放即可。

![](../../media/202106/88-合并两个有序数组（解法二：从后向前）_1624193151.gif)

#### 2.1.2 参考代码

```java
/**
 * 打印数组
 * @param obj   对象数组
 */
public static void printArray(int[] obj) {
    for (int i = 0; i < obj.length; i++) {
        System.out.print(obj[i]);
    }
    System.out.println();
}

/**
 * 88. 合并两个有序数组（版本 2：从后向前）
 *
 * @param nums1
 * @param m
 * @param nums2
 * @param n
 */
public void mergeV2(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    //  从后向前依次遍历 nums1 和 nums2
    while (i >= 0 && j >= 0) {
        if (nums2[j] >= nums1[i]) {
            // 如果 nums2[j] >= nums1[i]，则将 nums2[j] 放到 nums1[k] 的位置上，同时将 j 的值减 1
            nums1[k] = nums2[j];
            j--;
        } else if (nums1[i] > nums2[j]) {
            // 如果 nums1[i] >= nums2[j]，则将 nums1[i] 放到 nums1[k] 的位置上，同时将 i 的值减 1
            nums1[k] = nums1[i];
            i--;
        }
        //  最后统一将 k 的值减 1
        k--;
    }
    //  如果最后 nums1 已经遍历完了，nums2 还没有遍历完，说明此时 nums1 中的元素都已经移动到了 nums1 的对应的位置上，而且此时 nums2 中剩余的元素都小于 nums1 中已经存在的元素，因此直接将 nums2 中还未遍历完的元素从 nums1 的起始位置依次存放即可
    if (i < 0) {
        int q = 0;
        for (int p = 0; p <= j; p++) {
            nums1[p] = nums2[q];
            q++;
        }
    }
    printArray(nums1);
}
```

## 参考文献

1. [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)。



<h1 style='page-break-before: always;'>2.2.6 下一个排列</h1>

## 1 题目

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

**示例 1：**

```txt
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```txt
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```txt
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```txt
输入：nums = [1]
输出：[1]
```

**提示：**

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 100

## 2 问题分析

1. 这道题可以按照[维基百科](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order)上的解题思路来解决，具体如下：
   1. **先找出最大的索引 $k$**，**满足 $nums[k] < nums[k + 1]$**，**如果不存在**，**就翻转整个数组**。
   2. **再找出另一个最大索引 $l$**，**满足 $nums[l] > nums[k]$**。
   3. **交换 $nums[l]$ 和 $nums[k]$**。
   4. **最后反转 $nums[k+1]$ 后面的元素**。

## 3 参考代码

```java
/**
 * 31. 下一个排列
 * @param nums  数组
 */
public void nextPermutation(int[] nums) {
    int m = nums.length;
    boolean exist = false;  /*判断数字序列是否可以重新排列成下一个更大的序列*/

    for (int i = m - 2; i >= 0; i--) {
        if (exist) {    /*如果可以排列成下一个更大的序列，则中断 for 循环*/
            break;
        }
        if (nums[i] < nums[i + 1]) {    /*如果可以找到一个元素对 (nums[k], nums[k+1])，则表名可以重新排列成下一个更大的序列，令 exist = true*/
            exist = true;

            for (int j = m - 1; j >= i + 1; j--) {  /*循环遍历找到比 nums[i] 大的索引最大的元素*/
                if (nums[j] > nums[i]) {
                    int temp = nums[j]; /*交换 nums[i] 和 nums[j]*/
                    nums[j] = nums[i];
                    nums[i] = temp;

                    sort(nums, i + 1, m);   /*将 i + 1 后面的元素按照升序重新排列*/

                    break;
                }
            }
        }
    }

    if (!exist) {   /*如果不能排列成下一个更大的序列，则对整个数组进行重新排序*/
        sort(nums, 0, m);
    }
}

/**
 * 对数组指定区间的元素进行重新排序
 * @param nums  数组
 * @param start 起始位置
 * @param end   结束位置
 */
public void sort(int[] nums, int start, int end) {
    for (int k = start; k < end - 1; k++) {
        for (int l = k + 1; l < end; l++) {
            if (nums[k] > nums[l]) {
                int temp = nums[k];
                nums[k] = nums[l];
                nums[l] = temp;
            }
        }
    }
}
```

## 参考文献

1. [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation)。
2. [下一个排列](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-powcai)。
3. [Generation in lexicographic order](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order).




<h1 style='page-break-before: always;'>2.2.7 缺失的第一个正数</h1>

## 1 题目

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
**示例 1：**

```txt
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```txt
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```txt
输入：nums = [7,8,9,11,12]
输出：1
```

**提示：**

* 1 <= nums.length <= 5 * 105
* -231 <= nums[i] <= 231 - 1

## 2 解题思路

### 2.1 哈希表

#### 2.1.1 问题分析

1. 对于一个**长度为 $N$ 的数组**，其中**没有出现的最小正整数只能在 $[1, N + 1]$ 中**，这是因为**如果 $[1, N]$ 都出现了**，**那么答案是 $N + 1$**，**否则答案是 $[1, N]$ 中没有出现的最小正整数**。
2. 因此，我们有了一种**将数组设计成哈希表**的思路：
   1. 我们**对数组进行遍历**，对于**遍历到的数 $x$**，**如果他在 $[1, N]$ 的范围内**，**那么就将数组中的第 $x - 1$ 个位置**（数组下标从 0 开始）**打上标记**。
   2. 在**遍历结束之后**，**如果所有位置都被打了标记**，**那么答案是 $N + 1$**，**否则答案是最小的没有打上标记的位置加 1**。
3. 由于我们只在意 $[1, N]$ 的数，因此我们可以**先对数组进行遍历**，**把不在 $[1, N]$ 范围内的数修改成任意一个大于 $N$ 的数**（例如 $N + 1$），这样一来，**数组中的所有数就都是正数了**，因此，我们可以**将标记表示为负号**。
4. 具体的算法流程如下：
   1. **将数组中所有小于等于 0 的数修改为 $N + 1$**。
   2. **遍历数组中的每一个数 $x$**，他**可能已经被打了标记**，因此**原本对应的数为 $|x|$**，**如果 $|x| \in [1, N]$**，**并且**，**那么我们给数组中的第 $|x| - 1$ 个位置的数添加一个负号**，**如果他已经有负号**，**不需要重复添加**。
   3. **在遍历完成之后**，**如果数组中的每一个数都是负数**，**那么答案是 $N + 1$**，**否则答案是第一个正数的位置 $+ 1$**。
      
      ![](../../media/202108/2021-08-15_214948.png)

#### 2.1.2 参考代码

```java
/**
 * 41. 缺失的第一个正数（版本 1：哈希表）
 * @param nums  数组
 * @return  数组中缺失的第一个正数
 */
public int firstMissingPositiveV1(int[] nums) {
    int m = nums.length;

    for (int i = 0; i < m; i++) {
        //  将数组中小于等于 0 的数修改为 m + 1
        if (nums[i] <= 0) {nums[i] = m + 1;}
    }

    for (int i = 0; i < m; i++) {
        //  假设遍历到的数的绝对值为 x，如果 nums[x] 为正数，则将其变为对应的相反数
        int x = Math.abs(nums[i]);
        if (x <= m) {nums[x - 1] = -Math.abs(nums[x - 1]);}
    }

    for (int i = 0; i < m; i++) {
        //  数组中第一个正数所在的位置 + 1 即为数组中缺失的第一个正数
        if (nums[i] > 0) {return i + 1;}
    }

    //  如果数组中全部都为负数，则数组中缺失的第一个正数为 m + 1
    return m + 1;
}
```

### 2.2 置换

#### 2.2.1 问题分析

1. 除了打标记外，我们还可以使用**置换**的方法，将给定的数组恢复成下面的形式：
   1. **如果数组中包含 $x \in [1, N]$**，**那么恢复后**，**数组的第 $x - 1$ 个元素为 $x$**。
2. 在**恢复后**，**数组应当有 $[1, 2,...,N]$ 的形式**，**但其中有若干个位置的数是错误的**，**每一个错误的位置就代表了一个缺失的正数**。
3. 我们可以按照如下的方式对数组进行恢复：
   1. **对数组进行遍历**，**对于遍历到的数 $x = nums[i]$**，**如果 $x \in [1, N]$**，我们就知道 $x$**应当出现在数组中的 $x - 1$ 的位置**，因此**交换 $nums[i]$ 和 $nums[x - 1]$**，**这样 $x$ 就出现在了正确的位置**，**在完成交换后**，**新的 $nums[i]$ 可能还在 $[1, N]$ 的范围内**，**我们需要继续进行交换操作**，**直到 $x \in [1, N]$**。
   2. 需要注意的是，上面的方法**可能陷入死循环**，**如果 $nums[i]$ 恰好与 $nums[x - 1]$ 相等**，**那么就会无限交换下去**，**此时我们有 $nums[i] = x = nums[x - 1]$**，**说明 $x$ 已经出现在了正确的位置**，**因此我们可以跳出循环**，**开始遍历下一个数**。![](../../media/202108/41-缺失的第一个正数_1629036188.gif)

#### 2.2.2 参考代码

```java
/**
 * 41. 缺失的第一个正数（版本 2：置换）
 * @param nums  数组
 * @return  数组中缺失的第一个正数
 */
public int firstMissingPositiveV2(int[] nums) {
    int m = nums.length;

    for (int i = 0; i < m; i++) {
        //  对于遍历到的数 x = nums[i]，如果 x 在 [1, m] 范围内，并且 x != nums[x - 1] （防止发生死循环），则交换 nums[i] 与 nums[x - 1]，如果交换后新的 nums[i] 还在 [1, m] 范围内，则继续执行交换操作，知道 x 不在 [1, m] 范围内
        while (nums[i] >= 1 && nums[i] <= m && nums[i] != nums[nums[i] - 1]) {
            int temp = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = temp;
        }
    }

    for (int i = 0; i < m; i++) {
        //  交换后完后的数组中第 i 个位置的元素 nums[i]，如果 nums[i] != i + 1，则该元素所在的下一个位置 i + 1 即为数组中缺失的第一个正数
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    //  如果数组中的元素 nums[i] 都等于 i + 1，则数组中缺失的第一个正数为 m + 1
    return m + 1;
}
```

## 参考文献

1. [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive)。
2. [缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution)。




<h1 style='page-break-before: always;'>2.2.8 寻找两个正序数组的中位数</h1>

## 1 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**示例 1：**

```txt
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```txt
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**示例 3：**

```txt
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

**示例 4：**

```txt
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

**示例 5：**

```txt
输入：nums1 = [2], nums2 = []
输出：2.00000
```

**提示：**

* nums1.length == m
* nums2.length == n
* 0 <= m <= 1000
* 0 <= n <= 1000
* 1 <= m + n <= 2000
* -106 <= nums1[i], nums2[i] <= 106

**进阶：** 你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

## 2 解题思路

### 2.1 二分查找

#### 2.1.1 问题分析

1. 给定两个有序数组，要求**找到两个有序数组的中位数**，最直观的思路有以下两种：
   1. 使用**归并**的方式，**合并两个有序数组**，**得到一个大的有序数组**，**大的有序数组的中间位置的元素**，**即为中位数**。
   2. **不需要合并两个有序数组**，**只要找到中位数的位置即可**，由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的：
      1. 维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。
2. 假设两个有序数组的长度分别为 $m$ 和 $n$，上述两种思路的复杂度如下：
   1. 第一种思路的时间复杂度为 $O(m + n)$，空间复杂度是 $O(m + n)$。
   2. 第二种思路虽然可以将空间复杂度降到 $O(1)$，但是时间复杂度依然是 $O(m + n)$。
3. 本题也可以使用二分查找的方法来实现，具体思路如下：
   1. 根据中位数的定义，**当 $m + n$ 是奇数时**，**中位数是两个有序数组中的第 $(m + n) / 2$ 个元素**，**当 $m + n$ 是偶数时**，**中位数是两个有序数组中的第 $(m + n) / 2$ 个元素和第 $(m + n) / 2 + 1$ 个元素的平均值**，因此，这道题可以转化成**寻找两个有序数组中第 $k$ 小的数**，**其中 $k$ 为 $(m + n) / 2$ 或 $(m + n) / 2 + 1$。**
   2. 假设两个有序数组分别是 $A$ 和 $B$，要找到第 $k$ 个元素，我们可以**比较 $A[\frac{k}{2} - 1]$ 和 $B[\frac{k}{2} - 1]$**，由于 $A[\frac{k}{2} - 1]$ 的前面分别有 $A[0..\frac{k}{2} - 2]$ 和 $B[0..\frac{k}{2} - 2]$，即 $\frac{k}{2} - 1$ 个元素，对于 $A[\frac{k}{2} - 1]$**和 $B[\frac{k}{2} - 1]$ 中的最小值**，**最多只会有 $(\frac{k}{2} - 1) + (\frac{k}{2} - 1) = k - 2 < k - 1$ 个元素比他小**，**那么他就不能是第 $k$ 小的数了**（第 $k$ 小的数最多有 $k - 1$ 个数比他小）。
   3. 因此，我们可以归纳出三种情况：
      1. 如果 $A[\frac{k}{2} - 1] < B[\frac{k}{2} - 1]$，则 $A[0..\frac{k}{2} - 1]$ 不可能是不可能是第 $k$ 个数，可以全部排除。
      2. 如果 $A[\frac{k}{2} - 1] > B[\frac{k}{2} - 1]$，则 $B[0..\frac{k}{2} - 1]$ 不可能是不可能是第 $k$ 个数，可以全部排除。
      3. 如果 $A[\frac{k}{2} - 1] = B[\frac{k}{2} - 1]$，归入第一种情况处理。
         
         ![fig1](/media/202108/2021-08-18_1941310.9842675918411851.png)
   4. 可以看到，**比较 $A[\frac{k}{2} - 1]$ 之后**，**可以排除 $\frac{k}{2}$ 个不可能是第 $k$ 小的数**，**查找范围缩小了一半**，同时，**我们将在排除后的新数组上继续二分查找**，并且**根据我们排除数的个数**，**减少 $k$ 的值**，这是**因为我们排除的数都是不大于 $k$ 的数**。
   5. 有以下三种情况需要特殊处理：
      1. **如果 $A[\frac{k}{2} - 1]$ 或 $B[\frac{k}{2} - 1]$ 越界**，那么**我们可以选取对应数组中的最后一个元素**，在这种情况下，我们**必须根据排除数的个数减少 $k$ 的值**，而**不能直接将 $k$ 减去 $\frac{k}{2}$**。
      2. **如果一个数组为空**，**说明该数组中的所有元素都被排除**，**我们可以直接返回另一个数组中第 $k$ 小的元素**。
      3. **如果 $k = 1$**，**我们只要返回两个数组中的未排除下标范围内的首元素的最小值即可**。
   6. 具体示例如下：
      1. 假设两个有序数组如下：
         
         ```txt
         A: 1 3 4 9
         B: 1 2 3 4 5 6 7 8 9
         ```
      2. 两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 $k = 7$ 的元素。
      3. 比较两个有序数组中下标为 $\frac{k}{2} - 1 = 2$ 的数，即 $A[2]$ 和 $B[2]$，如下面所示：
         
         ```txt
         A: 1 3 4 9
                ↑
         B: 1 2 3 4 5 6 7 8 9
                ↑
         ```
      4. 由于 $A[2] > B[2]$，因此排除 $B[0..2]$，即数组 $B$ 的下标偏移（`offset`）变为 3，同时更新 $k$ 的值 $k = k - \frac{k}{2} = 4$。
      5. 下一步寻找，比较两个有序数组中下标为 $\frac{k}{2} - 1 = 1$ 的数，即 $A[1]$ 和 $B[4]$，如下面所示，其中，方括号部分表示已经被排除的数：
         
         ```txt
         A: 1 3 4 9
              ↑
         B: [1 2 3] 4 5 6 7 8 9
                      ↑
         ```
      6. 由于 $A[1] < B[4]$，因此排除 $A[0..1]$，即数组 $A$ 的下标偏移变为 2，同时更新 $k$ 的值 $k = k - \frac{k}{2} = 2$。
      7. 下一步寻找，比较两个有序数组中下标为 $\frac{k}{2} - 1 = 0$ 的数，即比较 $A[2]$ 和 $B[3]$，如下面所示：
         
         ```
         A: [1 3] 4 9
                  ↑
         B: [1 2 3] 4 5 6 7 8 9
                    ↑
         ```
      8. 由于 $A[2] = B[3]$，根据之前的规则，排除 $A$ 中的元素，因此排除 $A[2]$，即数组 $A$ 的下标偏移变为 3，同时更新 $k$ 的值 $k = k - \frac{k}{2} = 1$，由于 $k$ 的值变为 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 $k$ 个数，由于 $A[3] = 9 > B[3] = 4$，因此第 $k$ 个数是 $B[3] = 4$。

#### 2.1.2 参考代码

```java
/**
 * 4. 寻找两个正序数组的中位数
 * @param nums1 第一个正序数组
 * @param nums2 第二个正序数组
 * @return  两个正序数组的中位数
 */
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int length1 = nums1.length, length2 = nums2.length;
    int totalLength = length1 + length2;

    if (totalLength % 2 == 1) {
        //  数组长度之和为奇数，则中位数下标为 totalLength / 2
        int midIndex = totalLength / 2;
        double median = getKthElement(nums1, nums2, midIndex + 1);
        return median;
    } else {
        //  数组长度之和为偶数，则中位数下标分别为 totalLength / 2 - 1，totalLength / 2
        int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
        double median = (getKthElement(nums1, nums2, midIndex1 + 1)
                + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        return median;
    }
}

/**
 * 获取两个正序数组中第 k 小的元素
 * @param nums1 第一个正序数组
 * @param nums2 第二个正序数组
 * @param k k 值
 * @return  两个正序数组中第 k 小的元素
 */
public int getKthElement(int[] nums1, int[] nums2, int k) {
    int length1 = nums1.length, length2 = nums2.length;
    int index1 = 0, index2 = 0;

    while (true) {
        //  边界情况
        //  如果其中一个数组到达边界，则另一个数组中原来下标加上 k - 1 对应的下标即为两个数组中位数的下标
        if (index1 == length1) {return nums2[index2 + k - 1];}
        if (index2 == length2) {return nums1[index1 + k - 1];}
        //  如果 k == 1，则两个数组中的较小数即为两个数组的中位数
        if (k == 1) {return Math.min(nums1[index1], nums2[index2]);}

        //  正常情况
        int half = k / 2;
        int newIndex1 = Math.min(index1 + half, length1) - 1;
        int newIndex2 = Math.min(index2 + half, length2) - 1;
        int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
        if (pivot1 <= pivot2) {
            //  如果 pivot1 <= pivot2，则 nums1[0, newIndex1] 都不可能是第 k 小的元素，把这些元素全部删除，剩下的作为新的 nums1 数组
            k -= (newIndex1 - index1 + 1);
            //  由于我们删除了一些元素（这些元素都比第 k 小的元素小），因此需要修改 k 的值，减去删除的数的个数
            index1 = newIndex1 + 1;
        } else {
            //  如果 pivot1 > pivot2，则 nums2[0, newIndex2] 都不可能是第 k 小的元素，把这些元素全部删除，剩下的作为新的 nums2 数组
            k -= (newIndex2 - index2 + 1);
            //  由于我们删除了一些元素（这些元素都比第 k 小的元素小），因此需要修改 k 的值，减去删除的数的个数
            index2 = newIndex2 + 1;
        }
    }
}
```

## 参考文献

1. [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)。
2. [寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114)。




<h1 style='page-break-before: always;'>2.2.9 最长连续序列</h1>

## 1 题目

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

**示例 1：**

```txt
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```txt
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

* 0 <= nums.length <= 105
* -109 <= nums[i] <= 109

## 2 解题思路

### 2.1 哈希表

#### 2.1.1 问题分析

1. 有意题目要求的时间复杂度为 $O(n)$，因此我们可以使用**哈希表**来解决这个问题。
2. 我们使用哈希表来**存储每个端点值对应连续区间的长度**，其中 $key$**为端点值**，$value$**为对应连续区间的长度**。
3. 然后按以下步骤计算每个端点值对应连续区间的长度：
   1. 若**该端点已经在哈希表中存在**，则**直接跳过**即可。
   2. 否则：
      1. **计算出该端点左右两个相邻端点 $nums[i] - 1$ 和 $nums[i] + 1$ 的连续区间的长度分别为 $left$ 和 $right$**。
      2. 则**当前端点对应连续区间的长度**$currentLength$**为 $left + right + 1$**，**然后更新最后的结果值 $res$ 为所有已计算端点连续区间长度的最大值**。
      3. **更新当前端点 $nums[i]$ 及所在连续区间两边端点 $nums[i] - left$ 和 $nums[i] + right$ 的连续区间的长度为当前端点对应连续区间的长度 $currentLength$**。![](../../media/202108/128-最长连续序列_1629723804.gif)

#### 2.1.2 参考代码

```java
/**
 * 128. 最长连续序列
 *
 * @param nums 数组
 * @return 数组中数字连续的最长序列（不要求序列元素在原数组中连续）的长度
 */
public int longestConsecutive(int[] nums) {
    //  用于记录每个端点值对应连续区间的长度，其中 key 为端点值，value 为对应连续区间的长度
    Map<Integer, Integer> map = new HashMap<>();
    int res = 0, currentLength = 0;

    for (int i = 0; i < nums.length; i++) {
        /**
         * 计算每个端点值对应连续区间的长度：
         *  1. 若该端点已经在哈希表中存在，则直接跳过即可
         *  2. 否则：
         *      2.1 计算出该端点左右两个相邻的端点 nums[i] - 1 和 nums[i] + 1 的连续区间的长度分别为 left 和 right
         *      2.2 则当前端点对应连续区间的长度为 left + right + 1，然后更新最后的结果值为所有已计算端点连续区间长度的最大值。
         *      2.3 更新当前端点 nums[i] 及所在连续区间两边端点 nums[i] - left 和 nums[i] + right 的连续区间的长度为当前端点对应连续区间的长度
         */
        int key = nums[i];
        if (map.containsKey(key)) {
            continue;
        }

        int left = map.getOrDefault(nums[i] - 1, 0);
        int right = map.getOrDefault(nums[i] + 1, 0);
        currentLength = left + right + 1;
        res = Math.max(res, currentLength);

        map.put(key, currentLength);
        map.put(key - left, currentLength);
        map.put(key + right, currentLength);
    }

    return res;
}
```

## 参考文献

1. [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence)。
2. [ 【动态规划】Python 题解](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/dong-tai-gui-hua-python-ti-jie-by-jalan)。




<h1 style='page-break-before: always;'>2.2.10 给定数字能组成的最大时间</h1>

## 1 题目

给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。

24 小时格式为 "HH:MM" ，其中 HH 在 00 到 23 之间，MM 在 00 到 59 之间。最小的 24 小时制时间是 00:00 ，而最大的是 23:59 。从 00:00 （午夜）开始算起，过得越久，时间越大。

以长度为 5 的字符串，按 "HH:MM" 格式返回答案。如果不能确定有效时间，则返回空字符串。

**示例 1：**

```txt
输入：arr = [1,2,3,4]
输出："23:41"
解释：有效的 24 小时制时间是 "12:34"，"12:43"，"13:24"，"13:42"，"14:23"，"14:32"，"21:34"，"21:43"，"23:14" 和 "23:41" 。这些时间中，"23:41" 是最大时间。
```

**示例 2：**

```txt
输入：arr = [5,5,5,5]
输出：""
解释：不存在有效的 24 小时制时间，因为 "55:55" 无效。
```

**示例 3：**

```txt
输入：arr = [0,0,0,0]
输出："00:00"
```

**示例 4：**

```txt
输入：arr = [0,0,1,0]
输出："10:00"
```

**提示：**

```txt
arr.length == 4
0 <= arr[i] <= 9
```

## 2 解题思路

### 2.1 暴力法

#### 2.1.1 问题分析

1. 基本思路是**遍历所有可能的时间**，**找到最大的那个**：
   1. 我们可以**用 $(i, j, k, l)$ 表示 $(0, 1, 2, 3)$**，**用 $res$ 表示最大时间**，**然后做全排列**，**对于每个排列**，**会有 $arr[i]arr[j]:arr[k]arr[l]$**，此时小时 $hours$ 和分钟 $minutes$ 用整数可以按如下方式表示：
      
      $$
      hours = 10 * arr[i] + arr[j]
      $$
      
      $$
      minutes = 60 * arr[k] + arr[l]
      $$
   2. 然后**检查每个排列对应的时间是否合法**，即 $hours < 24$ 并且 $minutes < 60$：
      
      1. 如果**合法**且**比目前最大时间 $res$ 更大**，则**更新这个最大时间**。
   3. 最后**把最大时间输出就可以了**。
2. 需要注意的是：
   1. $i + j + k + l = 6$。
   2. 最后对字符串格式化为时间格式可以采用 `String.format("%02d%02d", hours, minutes)`，其中 `0` 代表如果位数不足就在前面补 `0`，`2` 代表整数的位数为 `2`，`d` 代表整数类型。

#### 2.1.2 参考代码

```java
/**
 * 949. 给定数字能组成的最大时间
 * @param arr   数组
 * @return  给定数字能组成的最大时间
 */
public String largestTimeFromDigits(int[] arr) {
    long res = -1L;

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (j == i) {continue;}
            for (int k = 0; k < 4; k++) {
                if (k == i || k == j) {continue;}
                int l = 6 - i - j - k;
                int hours = arr[i] * 10 + arr[j];
                int minutes = arr[k] * 10 + arr[l];
                if (hours < 24 && minutes < 60) {
                    res = Math.max(res, hours * 60 + minutes);
                }
            }
        }
    }

    return res >= 0 ? String.format("%02d:%02d", res / 60, res % 60) : "";
}
```

## 参考文献

1. [949. 给定数字能组成的最大时间](https://leetcode-cn.com/problems/largest-time-for-given-digits)
2. [ 给定数字能组成的最大时间](https://leetcode-cn.com/problems/largest-time-for-given-digits/solution/gei-ding-shu-zi-neng-zu-cheng-de-zui-da-shi-jian-b)。
3. [JAVA 字符串格式化-String.format()的使用](https://www.cnblogs.com/Dhouse/p/7776780.html)。




<h1 style='page-break-before: always;'>2.3 字符串</h1>

2.4 字符串




<h1 style='page-break-before: always;'>2.3.0 构造 K 个回文字符串</h1>

## 1 题目

给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。

如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。
**示例 1：**

```
输入：s = "annabelle", k = 2
输出：true
解释：可以用 s 中所有字符构造 2 个回文字符串。
一些可行的构造方案包括："anna" + "elble"，"anbna" + "elle"，"anellena" + "b"
```

**示例 2：**

```
输入：s = "leetcode", k = 3
输出：false
解释：无法用 s 中所有字符构造 3 个回文串。
```

**示例 3：**

```
输入：s = "true", k = 4
输出：true
解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。
```

**示例 4：**

```
输入：s = "yzyzyzyzyzyzyzy", k = 2
输出：true
解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。
```

**示例 5：**

```
输入：s = "cr", k = 7
输出：false
解释：我们没有足够的字符去构造 7 个回文串。
```

**提示：**

* 1 <= s.length <= 10^5
* s 中所有字符都是小写英文字母。
* 1 <= k <= 10^5

## 2 解题思路

### 2.1 定理证明

先来证明两个定理：

对于一个字符串 $s$，能构成的最小回文串的个数为 $min$，能构成的最大回文串的个数为 $max$：

1. **$min$ 等于 $s$ 中出现奇数次字符的个数，$max$ 等于 $s$ 中字符的个数。**
2. **$s$ 能构成 $min$ 和 $max$ 之间任意个数的回文串。**

具体证明如下：

**定理 1 证明：**

1. 因为出现奇数次的字符每一个都可以单独构成一个回文串，所以 $s$ 中能构成的最小回文串的个数就等于出现奇数次字符的个数。
2. 由于每一个字符都能单独构成一个回文串，所以 $d$ 中能构成的最大回文串的个数就等于 $s$ 中字符的个数。

**定理 2 证明：**

1. 回文串分两种，一种是奇数个字符，一种是偶数个字符。
2. 对于奇数个字符的回文串，每次拿出一个字符单独构成一个回文串，整个字符串能构成的回文串的个数会加 1。
3. 对于偶数个字符的回文串，可以随便拿出一个字符单独构成一个回文串，整个字符串能构成的回文串的个数会加 1，同时生预测回文串会成为奇数个字符，这就相当于情况 1 了。
4. 因此 $s$ 能构成 $min$ 和 $max$ 之间任意个数的回文串。

### 2.2 问题解析

通过以上定理我们可知只要判断 $k$ 是否在 $min$ 和 $max$ 之间即可。

### 2.3 参考代码

代码中有一点需要注意，就是**采用****整数数组替代 $HashMap$ 来保存字符串中每个字符出现的次数，这样可以减少算法的时间复杂度和空间复杂度**。

```java
package com.grayson.top;

import java.util.HashMap;
import java.util.Map;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/9 16:15
 * @Description 构造 K 个回文字符串
 */
public class L1400 {
    /**
     * 1400. 构造 K 个回文字符串
     * 给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。
     * 如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。
     * @param s 字符串
     * @param k 回文串的个数
     * @return  能否用字符串中的所有字符构建 k 个回文字符串
     */
    public boolean canConstruct(String s, int k) {
        //  字符串中出现奇数次字符的个数
        int odd = 0;
        //  字符串可以构建的最少和做多回文串的个数
        int min = 0, max = s.length();

        //  字符串中每个字符出现的次数，使用整数数组来存，而不用 HashMap，从而减少算法的时间和空间复杂度
        int[] chars = new int[26];
        for (int i = 0; i < max; i++) {
            ++chars[s.charAt(i) - 'a'];
        }

        //  查找字符串中出现奇数次字符的个数
        for (int i = 0; i < 26; i++) {
            if (chars[i] % 2 != 0) {odd++;}
        }
        min = Math.max(odd, 1);

        //  如果 k 在 [min, max] 之间，则该字符串可以构造 k 个回文字符串，否则不可以
        return k >= min && k <= max;
    }
}
```

## 3 参考文献

1. [1400. 构造 K 个回文字符串](https://leetcode-cn.com/problems/construct-k-palindrome-strings)。
2. [构造 K 个回文字符串「官方题解」](https://leetcode-cn.com/problems/construct-k-palindrome-strings/solution/gou-zao-k-ge-hui-wen-zi-fu-chuan-by-leetcode-solut)。




<h1 style='page-break-before: always;'>2.3.1 如何寻找最⻓回⽂⼦串</h1>

## 1 题目

给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```

示例 3：

```
输入：s = "a"
输出："a"
```

示例 4：

```
输入：s = "ac"
输出："a"
```

## 2 问题分析

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串。** 可以通过**双指针**的方法来解决。

## 3 参考代码

```java
package com.grayson.top;

import org.apache.commons.lang3.time.StopWatch;

import java.util.concurrent.TimeUnit;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/3/23 15:05
 * @Description 最长回文子串
 */
public class L5 {

    /**
     * 寻找回文子串
     *
     * @param s     字符串
     * @param start 起始字符的下标
     * @param end   结束字符的下标
     * @return 偶数回文子串的长度
     */
    public static String palindrome(String s, int start, int end) {
       int slow = start, fast = end;
        while (slow >= 0 && fast < s.length() && s.charAt(slow) == s.charAt(fast)) {
            slow--;
            fast++;
        }
        return s.substring(slow + 1, fast);
    }

    /**
     * 5.最长回文子串
     * 给你一个字符串 s，找到 s 中最长的回文子串。
     *
     * @param s 字符串
     * @return 最长回文子串
     */
    public static String longestPalindrome(String s) {
        if (s.length() == 0) {return null;}
        else if (s.length() == 1) {return s;}

        String palindrome = "";

        for (int i = 0; i < s.length(); i++) {
            String oddPalindrome = palindrome(s, i - 1, i + 1);
            String evenPalindrome = palindrome(s, i - 1, i);
            palindrome = oddPalindrome.length() > palindrome.length() ? oddPalindrome : palindrome;
            palindrome = evenPalindrome.length() > palindrome.length() ? evenPalindrome : palindrome;
        }
        return palindrome;
    }

    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch();

        stopWatch.start();
        String s = "babad";
        String palindrome = longestPalindrome(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 1 结果为：%s，执行用时：%s 微秒", palindrome, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        s = "cbbd";
        palindrome = longestPalindrome(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 2 结果为：%s，执行用时：%s 微秒", palindrome, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        s = "a";
        palindrome = longestPalindrome(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 3 结果为：%s，执行用时：%s 微秒", palindrome, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        s = "ac";
        palindrome = longestPalindrome(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 4 结果为：%s，执行用时：%s 微秒", palindrome, stopWatch.getTime(TimeUnit.MICROSECONDS)));
    }

}
```




<h1 style='page-break-before: always;'>2.3.2 如何判定括号的合法性</h1>

## 1 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**示例 4：**

```
输入：s = "([)]"
输出：false
```

**示例 5：**

```
输入：s = "{[]}"
输出：true
```

## 2 问题解析

**栈**是一种**后进先出**的结构，处理**括号**的问题时尤其有用。

我们可以遍历字符串，然后**遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配**。

## 3 参考代码

```java
package com.grayson.top;

import org.apache.commons.lang3.time.StopWatch;

import javax.xml.stream.events.Characters;
import java.util.Stack;
import java.util.concurrent.TimeUnit;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/3/25 15:58
 * @Description 有效的括号
 */
public class L20 {

    /**
     * 返回同类型的括号
     * @param c 右侧括号
     * @return  左侧括号
     */
    public static char sameType(char c) {
        if (c == ')') {return '(';}
        else if (c == ']') {return '[';}
        else if (c == '}') {return '{';}
        return Character.MIN_VALUE;
    }

    /**
     * 20. 有效的括号
     * 题目：
     *  给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
     *
     * 思路：
     *  1. 依次遍历字符串中的每个字符：
     *      1.1 如果是"("、"["、"{}"中的任意一个，则将其压入堆栈。
     *      1.2 如果是其他字符，并且堆栈不为空，当前字符与堆栈中最上面的字符相同，则继续查看下一个字符。
     *      1.3 否则的话，则直接返回 false
     *  2. 如果程序中间没有结束，并且堆栈为空，则直接返回 true。
     * @param s 字符串
     * @return  字符串的括号是否有效
     */
    public static boolean isValid(String s) {
        //  创建一个堆栈
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {stack.push(c);}
            else if (!stack.empty() && sameType(c) == stack.pop()) {continue;}
            else {return false;}
        }
        return stack.empty() && true;
    }

    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch();

        stopWatch.start();
        String s = "()";
        boolean res = isValid(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 1 结果为：%s，执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        s = "()[]{}";
        res = isValid(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 2 结果为：%s，执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));

        stopWatch.reset();
        stopWatch.start();
        s = "[";
        res = isValid(s);
        stopWatch.stop();
        System.out.println(String.format("测试用例 2 结果为：%s，执行用时：%s 微秒", res, stopWatch.getTime(TimeUnit.MICROSECONDS)));
    }

}
```




<h1 style='page-break-before: always;'>2.3.3 长度为3的不同回文子序列</h1>

## 1 题目

给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。

即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。

回文 是正着读和反着读一样的字符串。

子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。

例如，"ace" 是 "abcde" 的一个子序列。
**示例 1：**

```txt
输入：s = "aabca"
输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- "aba" ("aabca" 的子序列)
- "aaa" ("aabca" 的子序列)
- "aca" ("aabca" 的子序列)
```

**示例 2：**

```txt
输入：s = "adc"
输出：0
解释："adc" 不存在长度为 3 的回文子序列。
```

**示例 3：**

```txt
输入：s = "bbcbaba"
输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- "bbb" ("bbcbaba" 的子序列)
- "bcb" ("bbcbaba" 的子序列)
- "bab" ("bbcbaba" 的子序列)
- "aba" ("bbcbaba" 的子序列)
```

**提示：**

* 3 <= s.length <= 105
* s 仅由小写英文字母组成

## 2 解题思路

### 2.1 两次遍历

#### 2.1.1 问题分析

1. 该题目的基本原理是**两个字符之间字符的种类数即为这两个字符之间的字符所能组成的长度为 3 的回文序列的个数**。
2. 因此首先需要**遍历字符串中的每个字符**，然后使用 $map$**存储每个字符在字符串中的位置**。
3. 然后**遍历 $map$**，当**一个字符在字符串中出现两次**的时候，**统计这两个字符之间出现的字符的种类数**，即为**这两个字符之间的长度为 3 的回文序列的个数**。
4. 然后**将所有的回文序列的个数相加**，**便是总的回文序列的个数**。
   
   ![](../../media/202107/5809-长度为 3 的不同回文子序列（解法一：两次遍历）_1625987315.gif)

#### 2.1.2 参考代码

```java
/**
 * 5809. 长度为 3 的不同回文子序列
 * @param s 字符串
 * @return  字符串中长度为 3 的不同回文子序列
 */
public int countPalindromicSubsequence(String s) {
    int n = s.length();
    int count = 0;
    //  用于存储每个字符在字符串中的位置
    Map<Character, List<Integer>> map = new HashMap<>();

    //  遍历字符串，将每个字符对应的位置存储到 map 中
    for (int i =  0; i < n; i++) {
        char c = s.charAt(i);
        if (!map.containsKey(c)) {
            List<Integer> list = new ArrayList<>();
            list.add(i);
            map.put(c, list);
        } else {
            List<Integer> list = map.get(c);
            list.add(i);
            map.put(c, list);
        }
    }

    //  遍历 map，当一个字符在字符串中出现大于等于两次时，则这两个字符之间字符的种类数就是这两个字符之间的回文序列个数，最后将所有的回文序列个数相加，便是总的回文序列个数
    for (Map.Entry<Character, List<Integer>> entry: map.entrySet()) {
        List<Integer> values = entry.getValue();
        if (values.size() >= 2) {
            int start = values.get(0);
            int end = values.get(values.size() - 1);
            Set<Character> set = new HashSet<>();
            for (int j = start + 1; j <= end - 1; j++) {
                set.add(s.charAt(j));
            }
            count += set.size();
        }
    }

    //  返回最后的结果
    return count;
}
```

## 3 参考文献

1. [5809. 长度为 3 的不同回文子序列](https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences)。




<h1 style='page-break-before: always;'>2.3.4 字符串相加</h1>

## 1 题目

给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。

**提示：**

1. num1 和 num2 的长度都小于 5100
2. num1 和 num2 都只包含数字 0-9
3. num1 和 num2 都不包含任何前导零
4. 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

## 2 解题思路

### 2.1 模拟竖式算法

#### 2.1.1 问题分析

1. 如果两个字符串的长度不同，则将位数较短的字符串补零，使其和较长的字符串长度相同。
2. 将两个字符串各位进行相加：
   1. 两个字符串当前数字分别是 $a$、$b$，进位值 $plus$ 初始为 0。
   2. 将 $a$、$b$、$plus$ 相加得 $tempRes$，同时令当前位相加结果 $add$ 等于 $tempRes$：
      1. 如果 $tempRes>9$，说明当前位有进位，则令 $plus=tempRes/10$，$add=tempRes-plus/10$。
      2. 否则令 $plus=0$，说明当前位没有进位。
   3. 将当前位相加得结果 $add$ 添加到最终结果 $res$ 中。
3. 如果最后 $plus$ 大于 0，说明最后一位又有进位，将进位结果添加到最终结果 $res$ 中。
4. 前面得到的结果 $res$ 是反的，将其反转一下返回即可。

![](../../media/202106/415-字符串相加_1623938058.gif)

#### 2.1.2 参考代码

```java
/**
 * 将两个数字字符（均为个位数）相加
 * @param a 第一个数字字符
 * @param b 第二个数字字符
 * @param plus  进位数字
 * @return  两个数字字符之和
 */
public int add(char a, char b, int plus) {
    return (a - '0') + (b - '0') + plus;
}

/**
 * 415. 字符串相加（版本 1：模拟竖式算法）
 *
 * @param num1 数字 1
 * @param num2 数字 2
 * @return 以字符串形式返回两个数字相加后的结果
 */
public String addStringsV1(String num1, String num2) {
    int len1 = num1.length();
    int len2 = num2.length();
    int len = len1 >= len2 ? len1 : len2;
    int plus = 0;
    StringBuilder res = new StringBuilder();
    String s = num1, s2 = num2;
    if (len1 != len2) {
        s = len1 > len2 ? num2 : num1;
        s2 = len1 > len2 ? num1 : num2;
        StringBuilder temp = new StringBuilder();
        //  将位数较短的数字字符串补零，使其和较长的字符串长度相同
        for (int i = 0; i < Math.abs(len1 - len2); i++) {
            temp.append("0");
        }
        s = temp.append(s).toString();
    }
    //  将两个数字字符串各位相加
    for (int i = len - 1; i >= 0; i--) {
        char a = s.charAt(i);
        char b = s2.charAt(i);
        int tempRes = add(a, b, plus);
        int add = tempRes;
        if (tempRes > 9) {
            plus = tempRes / 10;
            add = tempRes - plus * 10;
        } else {
            plus = 0;
        }
        res.append(add);
    }
    //  如果最后 plus 不为 0，说明最后一位又有进位，将进的位直接拼接到结果后面
    if (plus > 0) {
        res.append(plus);
    }
    //  前面得到的结果是反的，将其进一步反转后返回
    return res.reverse().toString();
}
```

### 2.2 双指针法

#### 2.2.1 问题分析

1. 双指针法实质是利用两个指针从后往前依次遍历字符串，然后将每次遍历的结果按照竖式算法进行相加，具体过程如下：
   1. 初始时令 $i=num1.length() - 1$，$j=num2.length()-1$，进位值 $plus$ 初始为 0。
   2. 如果 $i!=0$ 或者 $j!=0$：
      1. 如果 $i>=0$，则 $a=num1.charAt(i)$，否则，$a='0'$。
      2. 如果 $j>=0$，则 $b=num1.charAt(j)$，否则，$b='0'$。
      3. 将 $a$、$b$、$plus$ 相加得 $tempRes$，同时令当前位相加结果 $add$ 等于 $tempRes$：
      4. 如果 $tempRes>9$，说明当前位有进位，则令 $plus=tempRes/10$，$add=tempRes-plus/10$。
      5. 否则令 $plus=0$，说明当前位没有进位。
      6. 将当前位相加得结果 $add$ 添加到最终结果 $res$ 中。
2. 如果最后 $plus$ 大于 0，说明最后一位又有进位，将进位结果添加到最终结果 $res$ 中。
3. 前面得到的结果 $res$ 是反的，将其反转一下返回即可。

![](../../media/202106/415-字符串相加（解法二：双指针法）_1623938659.gif)

#### 2.2.2 参考代码

```java
/**
 * 将两个数字字符（均为个位数）相加
 * @param a 第一个数字字符
 * @param b 第二个数字字符
 * @param plus  进位数字
 * @return  两个数字字符之和
 */
public int add(char a, char b, int plus) {
    return (a - '0') + (b - '0') + plus;
}

/**
 * 415. 字符串相加（版本 2：双指针）
 *
 * @param num1 数字 1
 * @param num2 数字 2
 * @return 以字符串形式返回两个数字相加后的结果
 */
public String addStringsV2(String num1, String num2) {
    int i = num1.length() - 1;
    int j = num2.length() - 1;
    int plus = 0;
    StringBuilder res = new StringBuilder();
    //  从右向左依次对两个字符串进行遍历，然后将两个对应的值按照竖式算法进行相加
    while (i >= 0 || j >= 0) {
        char a = i >= 0 ? num1.charAt(i) : '0';
        char b = j >= 0 ? num2.charAt(j) : '0';
        int tempRes = add(a, b, plus);
        int add = tempRes;
        if (tempRes > 9) {
            plus = tempRes / 10;
            add = tempRes - plus * 10;
        } else {
            plus = 0;
        }
        res.append(add);
        i--;
        j--;
    }
    //  如果最后 plus 不为 0，说明最后一位又有进位，将进的位直接拼接到结果后面
    if (plus > 0) {
        res.append(plus);
    }
    //  前面得到的结果是反的，将其进一步反转后返回
    return res.reverse().toString();
}
```

## 3 参考文献

1. [415. 字符串相加](https://leetcode-cn.com/problems/add-strings)。
2. [字符串相加 （双指针，清晰图解）](https://leetcode-cn.com/problems/add-strings/solution/add-strings-shuang-zhi-zhen-fa-by-jyd)。




<h1 style='page-break-before: always;'>2.4 链表</h1>





<h1 style='page-break-before: always;'>2.4.0 环形链表 II</h1>

## 1 题目

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

**说明：** 不允许修改给定的链表。

**进阶：**

* 你是否可以使用 O(1) 空间解决此题？

**示例 1：**

![circularlinkedlist.png (531×171)](/media/202104/2021-04-01_202434.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![circularlinkedlist_test2.png (201×105)](/media/202104/2021-04-01_202450.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![circularlinkedlist_test3.png (65×65)](/media/202104/2021-04-01_202501.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

* 链表中节点的数目范围在范围 [0, 104] 内
* -105 <= Node.val <= 105
* pos 的值为 -1 或者链表中的一个有效索引

## 2 解题思路

### 2.1 哈希表

#### 2.1.1 问题分析

当链表中有环时，在对链表进行遍历时环入口的节点一定会被重复遍历到，因此我们在对链表进行遍历时将每个节点的地址存到哈希表中，然后每访问一个节点，都看一下哈希表中是否存在该节点对应的地址：

* 若存在的话在该链表有环，直接返回即可。
* 如果访问到一个节点为 `null` 时，则该链表没有环，直接返回 `null` 即可。

#### 2.1.2 参考代码

```java
/**
     * 142. 环形链表 II（版本 1：哈希表）
     * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
     * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
     *
     * @param head 链表头指针
     * @return 链表是否有环
     */
    public static ListNode detectCycleV1(ListNode head) {
        ListNode p = head;
        //  定义一个 Map
        Map<Integer, Integer> map = new HashMap<>();
        //  遍历链表，同时将链表中的数据存入栈中
        while (p != null) {
            if (map.containsKey(p.hashCode())) {
                return p;
            }
            map.put(p.hashCode(), 1);
            p = p.next;
        }
        return null;
    }
```

### 2.2 双指针

#### 2.2.1 问题分析

1. 我们使用两个指针，`fast` 与 `slow`，他们都位于链表的头部。
2. 随后，`slow` 指针每次向后移动一个位置，`fast` 指针向后移动两个位置。
3. 如果链表中存在环，则 `fast` 指针将再次与 `slow` 指针相遇。
4. 如下图所示，设链表中环外部分的长度为 `a`，`slow` 指针进入环后又走了 `b` 的距离与 `fast` 指针相遇。
5. 此时，`fast` 指针已经走完了环的 `n` 圈，因此他走过的总距离为 `a+n(b+c)+b=a+(n+1)b+nc`。
6. 根据题意，任意时刻 `fast` 指针走过的距离都为 `slow` 指针的 2 倍，因此，我们有 `a+(n+1)b+nc=2(a+b)`，即 `a=c+(n-1)(b+c)`。
7. 根据这个等量关系我们可以发现：从相遇点到入环点的距离加上 `n-1` 圈的环长，恰好等于从链表头部到入环点的距离。
8. 因此，当发现 `slow` 与 `fast` 相遇时，我们再额外使用一个指针 `q`：
   1. 开始的时候，`q` 指向链表头部，随后，他和 `slow` 每次向后移动一个位置，最终，他们会在入环点相遇。

![142_fig1.png (2000×1125)](/media/202104/2021-04-01_204244.png)

#### 2.2.2 参考代码

```java
/**
     * 142. 环形链表 II（版本 2：双指针）
     * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
     * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
     *
     * @param head 链表头指针
     * @return 链表是否有环
     */
    public static ListNode detectCycleV2(ListNode head) {
        ListNode slow = head,fast = head;
        //  两种情况：
        //      1. 链表没有环，fast 先走到链表结尾
        //      2. 链表有环，slow 最终赶上 fast
        while (true) {
            if (fast == null || fast.next == null) {return null;}
            //  fast 每次走两步
            fast = fast.next.next;
            //  slow 每次走一步
            slow = slow.next;
            if (slow == fast) {
                //  链表有环，且 slow 和 fast 相遇
                //  再定义一个指针 q，从 head 开始，然后 q 和 slow 每次都走一步，则 q 会和 slow 在 环的入口处相遇
                ListNode q = head;
                while (true) {
                    if (q == slow) {return slow;}
                    q = q.next;
                    slow = slow.next;
                }
            }
        }
    }
```

## 3 参考文献

1. [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii)。
2. [环形链表 II（双指针法，清晰图解）](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-)。
3. [环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution)。
4. 解题思路 `2.2` 来自于[@力扣官方题解](https://leetcode-cn.com/u/leetcode-solution)。




<h1 style='page-break-before: always;'>2.4.1 如何高效判断回文链表</h1>

## 1 题目

请判断一个链表是否为回文链表。

**示例 1:**

```txt
输入: 1->2
输出: false
```

**示例 2:**

```txt
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

## 2 不同解法

### 2.1 创建一个新的单链表

我们可以把原始链表反转存入一条新的链表，然后比较这两个链表是否相同即可。

```java
/**
 * Definition for singly-linked list.
 */
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

/**
 * 反转链表
 * @param head  单链表的头指针
 * @return  反转后的链表
 */
private static ListNode reverse(ListNode head) {
    ListNode p = null;
    //  遍历并反转链表
    while (head != null) {
        ListNode tmpNode = new ListNode(head.val);
        tmpNode.next = p;
        p = tmpNode;
        head = head.next;
    }
    return p;
}

/**
 * 234. 回文链表（版本 1：创建一个新的单链表）
 * 请判断一个链表是否为回文链表。
 * @param head  单链表的头指针
 * @return  当前链表是否为回文链表
 */
public static boolean isPalindromeV1(ListNode head) {
    ListNode q = reverse(head);
    ListNode p;
    ListNode r;

    //  一次比较两个链表的值是否相等，如果相等的话，就是回文链表，否则就不是
    p = head;
    r = q;
    while (p != null && r != null) {
        //  如果两个链表有一个值不相等，则该链表不是回文链表，直接返回
        if (p.val != r.val) {return false;}
        p = p.next;
        r = r.next;
    }

    //  两个链表的值都相等，该链表是回文链表，返回 true
    return true;
}
```

### 2.2 双指针法

1. 先通过双指针技巧中的快慢指针来找到链表的中点。

![](../../media/202103/2021-03-26_213406.png)

2. 如果`fast` 指针没有指向`null`，说明链表长度为奇数，`slow` 还要再向前进一步。

![](../../media/202103/2021-03-26_213729.png)

3. 从`slow` 后面开始反转链表，然后就可以开始比较回文串了。

```java
/**
 * Definition for singly-linked list.
 */
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

/**
 * 反转链表
 * @param head  单链表的头指针
 * @return  反转后的链表
 */
private static ListNode reverse(ListNode head) {
    ListNode p = null;
    //  遍历并反转链表
    while (head != null) {
        ListNode tmpNode = new ListNode(head.val);
        tmpNode.next = p;
        p = tmpNode;
        head = head.next;
    }
    return p;
}

/**
 * 234. 回文链表（版本 3：双指针法）
 * 请判断一个链表是否为回文链表。
 * @param head  单链表的头指针
 * @return  当前链表是否为回文链表
 */
public static boolean isPalindromeV3(ListNode head) {
    ListNode slow = head, fast = null;

    //  寻找中间节点
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    //  如果 fast 不为 null，则说明链表的长度为奇数
    if (fast != null) {slow = slow.next;}

    //  判断两个链表公共的部分是否相同
    fast = reverse(slow);
    slow = head;
    while (fast != null && slow != null) {
        //  当前链表不是回文链表，返回 false
        if (fast.val != slow.val) {return false;}
        fast = fast.next;
        slow = slow.next;
    }

    //  当前链表是回文链表，返回 true
    return true;
}
```

### 2.3 栈

我们知道**栈是一种后进先出的数据结构**，这里**可以用栈把双指针法中中间节点后面的节点的值放在栈中保存，然后将链表中间节点前面的部分和栈里面的中间节点后面的值进行比较**即可。

```java
/**
 * Definition for singly-linked list.
 */
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

/**
 * 234. 回文链表（版本 4：栈）
 * 请判断一个链表是否为回文链表。
 * @param head  单链表的头指针
 * @return  当前链表是否为回文链表
 */
public static boolean isPalindromeV4(ListNode head) {
    //  将单链表的数据存储在栈中
    Stack<Integer> stack = new Stack<>();
    ListNode p = head;
    int len = 0;
    while (p != null) {
        len++;
        stack.push(p.val);
        p = p.next;
    }

    //  遍历栈
    //  计算右侧开始比对的节点的位置：
    //      1. 节点个数为偶数：len / 2 + 1
    //      2. 节点个数为奇数：len / 2 + 2
    if (len > 1) {len = (len % 2 == 0 ? len / 2 + 1 : len / 2 + 2);}
    p = head;
    while (len-- > 0) {
        if (p.val != stack.pop()) {return false;}
        p = p.next;
    }

    //  当前链表是回文链表，返回 true
    return true;
}
```

### 2.4 后序遍历

**链表具有递归结构**，其实也可以有**前序遍历**和**后序遍历**，例如通过后序遍历来倒序打印链表：

```java
/* 倒序打印单链表中的元素值 */
public static void traverse(ListNode head) {
    if (head == null) return;
    traverse(head.next);
    // 后序遍历代码
    System.out.println(head.val);
}
```

因此，我们可以将上面的程序稍作修改，模仿双指针实现回文判断功能，这么做的核心逻辑就是**把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已**。

```java
/**
 * Definition for singly-linked list.
 */
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

/**
 * 判断一个链表是否是回文链表
 * @param head  单链表的表头
 * @return  当前链表是否是回文链表
 */
public static boolean check(ListNode head) {
    if (head == null) {return true;}
    boolean res = check(head.next) && temp.val == head.val;
    temp = temp.next;
    return res;
}

/**
 * 234. 回文链表（版本 5：后序遍历）
 * 请判断一个链表是否为回文链表。
 * @param head  单链表的头指针
 * @return  当前链表是否为回文链表
 */
public static boolean isPalindromeV5(ListNode head) {
    temp = head;
    return check(head);
}
```



<h1 style='page-break-before: always;'>2.5 二叉树</h1>





<h1 style='page-break-before: always;'>2.5.0 在二叉树中分配硬币</h1>

## 1 题目

给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

**示例 1：**

![](../../media/202104/2021-04-02_193340.png)

```
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
```

**示例 2：**

![tree2.png (368×348)](/media/202104/2021-04-02_193407.png)

```
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
```

**示例 3：**

![tree3.png (368×348)](/media/202104/2021-04-02_193421.png)

```
输入：[1,0,2]
输出：2
```

**示例 4：**

![tree4.png (498×500)](/media/202104/2021-04-02_193440.png)

```
输入：[1,0,0,null,3]
输出：4
```

** 提示：**

* 1<= N <= 100
* 0 <= node.val <= N

## 2 解题思路

这里我们引入一个 `过载量`，用 $O$ 表示，他表示当前节点需要移出的金币数。

例如一个节点 $T_1$ 有 2 枚金币，则他需要移出的金币数为 1，即该节点的过载量 $O(T_1)=1$。

假如一个树 $T$ 有 $k$ 个节点，其中 $m$ 个非叶节点，分别为 $T_1,T_2,T_3,...,T_m$，$k-m$ 个叶子节点，分别为 $T_{m+1},T_{m+2},T_{m+3},...,T_k$，则：

1. 叶子节点 $T_i$ 的过载量为：

$$
O(T_i)=N(T_i)-1
$$

其中 $N(T_i)$ 为该叶子节点含有的金币个数。

即**一个叶子节点的过载量等于其含有的金币数减 1，该值可能为正，也可能为负，如果为正的话表示移出的金币个数，如果为负的话表示移入的金币个数**。

2. 非叶节点 $T_j$ 的过载量为：

$$
O(T_j)=N(T_j)+O(T_{lj})+O(T_{rj})-1
$$

其中 $O(T_{lj})$ 和 $O(T_{rj})$ 分别为该非叶节点 $O(T_j)$ 的 `左孩子节点` 和 `右孩子节点` 对应的过载量。

即**一个非叶节点的过载量等于=自身的金币个数 + 左孩子节点的过载量 + 右孩子节点的过载量-1**。

3. 则该树对应的过载量为：

$$
O(T)=\sum_{i=1}^kabs(O(T_i))
$$

即**一棵树的过载量等于所有节点的过载量的绝对值之和**。

具体实例如下：

![](../../media/202104/2021-04-02_201811.png)

1. 该树 $T$ 共有 7 个节点，其中 4 个叶子节点，分别为 `d、e、f、g`，有 3 个非叶节点，分别为 `a、b、c`。
2. 计算叶子节点的过载量：

$$
O(d)=N(d)-1=1-1=0
$$

$$
O(e)=O(e)-1=0-1=-1
$$

$$
O(f)=O(f)-1=1-1=0
$$

$$
o(g)=O(g)=0-1=-1
$$

3. 计算非叶节点的过载量：

$$
O(b)=N(b)+O(d)+O(e)-1=3+0-1-1=1
$$

$$
O(c)=N(c)+O(f)+O(g)-1=0+0-1-1=-2
$$

$$
O(a)=N(a)+O(b)+O(c)-1=2+1-2-1=0
$$

4. 计算整棵树 $T$ 的过载量：

$$
O(T)=abs(O(a))+abs(O(b))+abs(O(c))+abs(O(d))+abs(O(e))+abs(O(f))+abs(O(g))=0+1+2+0+1+0+1=5
$$

因此该树使每个结点上只有一枚硬币所需的移动次数为 5。

## 3 参考代码

```java
package com.grayson.top;

import apple.laf.JRSUIUtils;
import com.grayson.top.domain.TreeNode;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/1 21:54
 * @Description 在二叉树中分配硬币
 */
public class L979 {

    int ans;
  
    /**
     * 采用深度优先搜索获取当前二叉树的过载量
     * @param node  二叉树头结点
     * @return  二叉树的过载量
     */
    public int dfs(TreeNode node) {
        if (node == null) {return 0;}
        int left = dfs(node.left);
        int right = dfs(node.right);
        ans += Math.abs(left) + Math.abs(right);
        return (node.val - 1) + left + right;
    }

    /**
     * 979. 在二叉树中分配硬币
     * 给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
     * 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
     * 返回使每个结点上只有一枚硬币所需的移动次数。
     * @param root  二叉树根节点
     * @return  使二叉树每个结点上只有一枚硬币所需的移动次数
     */
    public int distributeCoins(TreeNode root) {
        ans = 0;
        dfs(root);
        return ans;
    }

}
```

## 4 参考文献

1. [979. 在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree)。
2. [在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/solution/zai-er-cha-shu-zhong-fen-pei-ying-bi-by-leetcode)。




<h1 style='page-break-before: always;'>2.5.1 将有序数组转换为二叉搜索树</h1>

## 1 题目

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

![](../../media/202104/2021-04-09_201534.png)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

![](../../media/202104/2021-04-09_201625.png)

**示例 2：**

![](../../media/202104/2021-04-09_201618.png)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

## 2 解题思路

### 2.1 问题分析

**二叉搜索树的中序遍历是升序序列，题目中的数组也是按照生序排序的有序数组，因此可以判断数组时二叉搜索树的中序遍历序列。**

我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或相差 1，这样可以使得树保持平衡，因此问题的实质可以转化为**将有序数组按照中序遍历的方式构造为一棵二叉树即可**。

### 2.2 参考代码

```java
package com.grayson.top;

import com.grayson.top.domain.TreeNode;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/9 19:32
 * @Description 将有序数组转换为二叉搜索树
 */
public class L108 {
    /**
     * 创建二叉搜索树
     *
     * @param nums  有序数组
     * @param left  左节点下标
     * @param right 右节点下标
     * @return 创建的二叉树的根节点
     */
    public TreeNode createBST(int[] nums, int left, int right) {
        //  base case
        if (left > right) {
            return null;
        }

        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode();
        node.left = createBST(nums, left, mid - 1);
        node.right = createBST(nums, mid + 1, right);
        node.val = nums[mid];
        return node;
    }

    /**
     * 108. 将有序数组转换为二叉搜索树
     * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
     * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
     *
     * @param nums 有序数组
     * @return 二叉搜索树
     */
    public TreeNode sortedArrayToBST(int[] nums) {
        int left = 0, right = nums.length - 1;
        return createBST(nums, left, right);
    }

    public static void main(String[] args) {
        int[] nums = {-10, -3, 0, 5, 9};
        L108 l108 = new L108();
        TreeNode node = l108.sortedArrayToBST(nums);
        System.out.println(node);
    }
}
```

## 3 参考文献

1. [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)。
2. [将有序数组转换为二叉搜索树『官方题解』](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33)。




<h1 style='page-break-before: always;'>2.5.2 重建二叉树</h1>

## 1 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```txt
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

![](../../media/202104/2021-04-28_210531.png)

**限制：**

```txt
0 <= 节点个数 <= 5000
```

## 2 解题思路

### 2.1 递归法

#### 2.1.1 问题分析

前序遍历性质：节点按照 `[根子树 | 左子树 | 右子树]` 排序。

中序遍历性质：节点按照 `[左子树 | 根节点 | 右子树]` 排序。

根据以上性质，可得出以下结论：

1. **前序遍历**的**首元素**为树的**根节点 `node` 的值**。
2. 在**中序遍历**中搜索**根节点 `node` 的索引**，可将**中序遍历**划分为 `[左子树 | 根节点 | 右子树]`。
3. 根据**中序遍历**中的**左/右子树的节点数量**，可将**前序遍历**划分为 `[根节点 | 左子树 | 右子树]`。

通过以上三步，可确定三个节点：**树的根节点**、**左子树根节点**、**右子树根节点**。对于树的左、右子树，仍可使用以上步骤划分子树的左右子树。

以上子树的递归性质是**分治算法**的体现，考虑通过递归对所有子树进行划分。

##### 2.1.1.1 分治算法解析

1. **递推参数：** 根节点在前序遍历的索引 `root`、**子树**在**中序遍历的左边界**`left`、**子树**在**中序遍历的右边界**`right`。
2. **终止条件：** 当 `left > right` 时，代表已经越过叶节点，此时返回 `null`。
3. **递推工作：**
   1. **建立根节点**`node`：节点值为 `preOrder[root]`。
   2. **划分左右子树：** 查找**根节点**在**中序遍历 `inOrder`** 中的索引 `i`。
   3. **构建左右子树：** 开启左右子树递归。

| **根节点索引** | **中序遍历左边界** | **中序遍历右边界** |
| :------------------- | ------------------------ | ------------------------ |
| 左子树               | root + 1                 | left                     |
| 右子树               | i - left + root + 1      | i + 1                    |

> 1. 为了提升效率。本文使用哈希表 `dic` 存储中序遍历的值与索引的映射，查找时间复杂度为 $O(1)$。
> 2. `i - left + root + 1` 表示 ` 根节点索引 + 左子树长度 + 1`

4. **返回值：** 回溯返回 `node`，作为上一层递归中根节点的左/右子节点。

> 注：本方法只适用于**无重复节点值**的二叉树。

#### 2.1.2 参考代码

```java
package com.grayson.top.codinginterviews;

import com.grayson.top.domain.TreeNode;

import java.util.HashMap;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/28 20:13
 * @Description 重建二叉树
 */
public class CI7 {
    //  二叉树前序遍历数组
    int[] preOrder;
    //  哈希表，其中 key 为二叉树节点的值，value 为二叉树节点的值在后序遍历中的索引
    HashMap<Integer, Integer> inValueAndIndexMap = new HashMap<>();

    /**
     * 剑指 Offer 07. 重建二叉树
     *
     * @param preorder 前序遍历数组
     * @param inorder  中序遍历数组
     * @return 二叉树
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preOrder = preorder;
        //  构建哈希表，其中 key 为二叉树节点的值，value 为二叉树节点的值在后序遍历中的索引
        int m = inorder.length;
        for (int i = 0; i < m; i++) {
            inValueAndIndexMap.put(inorder[i], i);
        }
        //  递归构建二叉树
        return recur(0, 0, m - 1);
    }

    /**
     * 递归构建二叉树
     *
     * @param root  根节点在前序遍历中的索引
     * @param left  子树在中序遍历的左边界
     * @param right 子树在中序遍历的右边界
     * @return 二叉树
     */
    private TreeNode recur(int root, int left, int right) {
        //  已经越过叶节点，返回 null
        if (left > right) {
            return null;
        }
        TreeNode node = new TreeNode(preOrder[root]);
        node.left = recur(root + 1, left, inValueAndIndexMap.get(preOrder[root]) - 1);
        node.right = recur(root + inValueAndIndexMap.get(preOrder[root]) - left + 1, inValueAndIndexMap.get(preOrder[root]) + 1, right);
        return node;
    }

    public static void main(String[] args) {
        CI7 ci7 = new CI7();
        int[] preOrder = {3, 9, 20, 15, 7};
        int[] inOrder = {9, 3, 15, 20, 7};
        TreeNode res = ci7.buildTree(preOrder, inOrder);
        System.out.println(res);
    }
}
```

## 3 参考文献

1. [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof)。
2. [面试题 07. 重建二叉树（递归法，清晰图解）](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin)。




<h1 style='page-break-before: always;'>2.6 队列</h1>

2.7 栈




<h1 style='page-break-before: always;'>2.6.0 用栈实现队列</h1>

## 1 题目

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

* void push(int x) 将元素 x 推到队列的末尾
* int pop() 从队列的开头移除并返回元素
* int peek() 返回队列开头的元素
* boolean empty() 如果队列为空，返回 true ；否则，返回 false

**说明：**

* 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
* 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**进阶：**

* 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。

**示例：**

```txt
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

** 提示：**

* 1 <= x <= 9
* 最多调用 100 次 push、pop、peek 和 empty
* 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）

## 2 解题思路

### 2.1 问题解析

创建两个栈，分别为 $stack1$、$stack2$，二者的主要作用如下：

1. $stack1$：作为容器，$push$ 进来的元素开始的时候都保存在 $stack1$ 中。
2. $stack2$：作为窗口，$pop$ 和 $peek$ 操作都是从 $stack2$ 取元素，如果 $stack2$ 为空，则将 $stack1$ 中的元素全部都 $push$ 到 $stack2$ 中，然后再从 $stack2$ 中 $pop$ 或 $peek$ 元素即可。

![](../../media/202106/232-用栈实现队列_1624800511.gif)

### 2.2 参考代码

```java
class MyQueue {

    //  stack1 作为容器，push 进来的元素开始的时候都保存在 stack1 中
    public Stack<Integer> stack1;
    //  stack2 作为窗口，pop 和 peek 操作都是从 stack1 取元素，如果 stack2 为空，则将 stack1 中的元素全部都 push 到 stack2 中，然后再从 stack2 中 pop 或 peek 元素即可
    public Stack<Integer> stack2;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        stack1.push(x);
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        if (stack2.size() == 0) {
            //  如果 stack2 为空，则将 stack1 中的元素全部都 push 到 stack2 中
            while (stack1.size() > 0) {
                stack2.push(stack1.pop());
            }
        }
        //  从 stack2 中 pop 元素
        return stack2.pop();
    }

    /**
     * Get the front element.
     */
    public int peek() {
        if (stack2.size() == 0) {
            //  如果 stack2 为空，则将 stack1 中的元素全部都 push 到 stack2 中
            while (stack1.size() > 0) {
                stack2.push(stack1.pop());
            }
        }
        //  从 stack2 中 peek 元素
        return stack2.peek();
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return stack1.empty() && stack2.empty();
    }
}
```

## 3 参考文献

1. [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks)。




<h1 style='page-break-before: always;'>2.7 动态规划</h1>

2.8 动态规划




<h1 style='page-break-before: always;'>2.7.0 如何高效解决接雨水问题</h1>

## 2.3.1 题目

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

![](../../media/202103/2021-03-22_161216.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

示例 2：

```
输入：height = [4,2,0,3,2,5]
输出：9
```

## 2.3.2 核心思路

对于这种问题，我们不要想整体，而应该去想局部。这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 `i`，能装下能装 2 格水。

![](http://notebook.ricear.com/media/202103/2021-03-22_161714.png)

这是因为位置 `i` 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，假设这两个柱子的高度分别为 `leftMax` 和 `rightMax`，则位置 `i` 的水柱高度为：

```java
water[i] = min(leftMax, rightMax) - height[i]
```

![](../../media/202103/2021-03-22_164438.png)

![](../../media/202103/2021-03-22_164917.png)

## 2.3.3 解法

### 2.3.3.1 暴力解法

```java
/**
     * 获取一个数组中指定下标范围内的最大值
     * @param height    数组
     * @param startIndex    起始坐标
     * @param endIndex  结束坐标
     * @return  该数组指定下标范围内的最大值
     */
    public static int getMax(int[] height, int startIndex, int endIndex) {
        int max = -1;
        if (startIndex < 0 || endIndex > height.length - 1 || startIndex > endIndex) {return -1;}
        for (int i = startIndex; i <= endIndex; i++) {
            max = Math.max(height[i], max);
        }
        return max;
    }

/**
     * 42.接雨水（版本 1：暴力解法）
     * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
     * @param height    每个柱子的高度
     * @return  总共可以接多少雨水
     */
    public static int trapV1(int[] height) {
        int trap = 0;
        for (int i = 0; i < height.length; i++) {
            int leftMax = getMax(height, 0, i);
            int rightMax = getMax(height, i, height.length - 1);
            trap += Math.min(leftMax, rightMax) - height[i];
        }
        return trap;
    }
```

暴力解法的时间复杂度为 `O(N^2)`，空间复杂度为 `O(1)`，这种计算 `leftMax` 和 `rightMax` 的方法十分笨拙，一般的优化方法就是备忘录。

### 2.3.3.2 备忘录优化

之前的暴力解法是在每个位置都要计算 `leftMax` 和 `rightMax`，现在可以把结果都缓存下来，这样时间复杂度就降下来了。我们可以用两个数组 `leftMax` 和 `rightMax` 充当备忘录，`leftMax[i]` 表示位置 `i` 左边最高的柱子高度，`rightMax[i]` 表示位置 `i` 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算。

#### 2.3.3.2.1 优化一

```java
/**
     * 获取一个数组中指定下标范围内的最大值
     * @param height    数组
     * @param startIndex    起始坐标
     * @param endIndex  结束坐标
     * @return  该数组指定下标范围内的最大值
     */
    public static int getMax(int[] height, int startIndex, int endIndex) {
        int max = -1;
        if (startIndex < 0 || endIndex > height.length - 1 || startIndex > endIndex) {return -1;}
        for (int i = startIndex; i <= endIndex; i++) {
            max = Math.max(height[i], max);
        }
        return max;
    }

/**
     * 42.接雨水（版本 2：备忘录解法）
     * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
     * @param height    每个柱子的高度
     * @return  总共可以接多少雨水
     */
    public static int trapV2(int[] height) {
        int trap = 0;
        int[] leftMax = new int[height.length];
        int[] rightMax = new int[height.length];
        for (int i = 0; i < height.length; i++) {
            leftMax[i] = getMax(height, 0, i);
            rightMax[i] = getMax(height, i, height.length - 1);
        }
        for (int i = 0; i < height.length; i++) {
            trap += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return trap;
    }
```

#### 2.3.3.2.2 优化二-优化求最大值方法

```java
/**
     * 42.接雨水（版本 3：备忘录解法-优化求最大值方法）
     * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
     * @param height    每个柱子的高度
     * @return  总共可以接多少雨水
     */
    public static int trapV3(int[] height) {
        if (height.length == 0) {return 0;}
        int trap = 0;
        int[] leftMax = new int[height.length];
        int[] rightMax = new int[height.length];
        leftMax[0] = height[0];
        rightMax[height.length - 1] = height[height.length - 1];
        for (int i = 1; i < height.length; i++) {
            leftMax[i] = Math.max(height[i], leftMax[i - 1]);
        }
        for (int i = height.length - 2; i >= 0; i--) {
            rightMax[i] = Math.max(height[i], rightMax[i + 1]);
        }
        for (int i = 0; i < height.length; i++) {
            trap += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return trap;
    }
```

这个优化其实和暴力解法差不多，就是避免了重复计算，把时间复杂度降低为 `O(N)`，已经是最优了，但是空间复杂度是 `O(N)`，所以空间复杂度还需要进一步优化。

### 2.3.3 双指针解法

这种解法的思路是完全相同的，但是实现手法上非常巧妙，我们这一次也不用备忘录提前计算了，而是用双指**边走边算**，节省下空间复杂度。

```java
/**
 * 42.接雨水（版本 4：双指针解法）
 * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
 * @param height    每个柱子的高度
 * @return  总共可以接多少雨水
 */
public static int trapV4(int[] height) {
    if (height.length == 0) {return 0;}
    int left = 0, right = height.length - 1, trap = 0;
    int leftMax = height[0], rightMax = height[height.length - 1];
    while (left <= right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);
        if (leftMax < rightMax) {
            trap += leftMax - height[left];
            left++;
        } else {
            trap += rightMax - height[right];
            right--;
        }
    }
    return trap;
}
```

核心思想和之前一样，但是细节上有差别。

之前的备忘录解法，`leftMax[i]` 和 `rightMax[i]` 分别代表的是 `height[0..i]` 和 `height[i..end]` 的最高柱子高度。

![](../../media/202103/2021-03-22_171144.png)

但是双指针解法中， `leftMax` 和 `rightMax` 分别代表的是 `height[0..left]` 和 `height[right..end]` 的最高柱子高度。比如这段代码：

```java
if (leftMax < rightMax) {
  trap += leftMax - height[left];
  left++;
}
```

![](../../media/202103/2021-03-22_171638.png)

此时的 `leftMax` 是 `left 指针 ` 左边的最高柱子，由于我们只在乎 `min(leftMax, rightMax)`，并且此时 `leftMax < rightMax`，因此 `rightMax` 是不是右边最大的不重要，重要的是 `height[i]` 能装的水之和 `leftMax` 有关。

![](../../media/202103/2021-03-22_172217.png)




<h1 style='page-break-before: always;'>2.7.1 最少侧跳次数</h1>

## 1 题目

给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。

给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。

比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。

比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。

**注意：** 点 0 处和点 n 处的任一跑道都不会有障碍。

**示例 1：**

![](../../media/202104/2021-04-12_191457.png)

```
输入：obstacles = [0,1,2,3,0]
输出：2
解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
```

**示例 2：**

![](../../media/202104/2021-04-12_191503.png)

```
输入：obstacles = [0,1,1,3,3,0]
输出：0
解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
```

**示例 3：**

![](../../media/202104/2021-04-12_191513.png)

```
输入：obstacles = [0,2,1,0,3,0]
输出：2
解释：最优方案如上图所示。总共有 2 次侧跳。
```

**提示：**

* obstacles.length == n + 1
* 1 <= n <= 5 * 105
* 0 <= obstacles[i] <= 3
* obstacles[0] == obstacles[n] == 0

## 2 解题思路

通过 `最少侧跳次数` 我们可以知道该问题属于动态规划问题，因此可以采用**DP 数组**来解决，DP 数组解决问题时主要由以下两个步骤：

1. 找状态关系（通过数学归纳获得）。
2. 定义 dp 数组（根据状态转移方程获得）。

### 2.1 找状态关系

1. 第 $i$ 列的任意一个赛道的最少侧跳次数 $S_i$ 等于当前列其他赛道的最少侧跳次数的最少值，即：

$$
S_i=min(S_{i1},S_{i2},S_{i3})
$$

2. 因此，为了求第 $i$ 列的最少侧跳次数，我们需要求每个赛道的最少侧跳次数，每个赛道的最少侧跳次数的求法主要分为两步：
   
   1. **根据前一列相同赛道更新当前赛道的最少侧跳次数：** 由于同一赛道上不需要进行侧跳，所以如果当前赛道上没有障碍，则当前赛道的最少侧跳次数等于前一列的当前赛道的最少侧跳次数，即：
      
      $$
      S_{ij}=S_{i(j-1)}
      $$
   2. **根据当前列更新当前赛道的最少侧跳次数：** 由于到达同一列不同赛道上需要一次侧跳，所以如果当前赛道上没有障碍，则当前赛道的最少侧跳次数等于当前列所有赛道的最少侧跳次数的最小值（假设当前赛道为第一条赛道），即：
      
      $$
      S_{i1}=min(S_{i1},S_{i2},S_{i3})
      $$

### 2.2 定义 dp 数组

根据 `2.1 找状态关系 ` 中的状态关系，我们可以确定 dp 数组的定义为 $dp[i][j]$**表示到达第 $i$ 列第 $j$ 条赛道需要的最少侧跳次数**。

## 3 参考代码

```java
package com.grayson.top.competition.c20210411;

import java.util.Arrays;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/11 15:12
 * @Description
 */
public class Third {
    /**
     * 5728. 最少侧跳次数
     * @param obstacles 障碍数组
     * @return  最少侧条次数
     */
    public int minSideJumps(int[] obstacles) {
        int ol = obstacles.length;
        //  dp 数组
        int[][] dp = new int[ol][3];
        //  base case
        dp[0][0] = 1;
        dp[0][1] = 0;
        dp[0][2] = 1;
        //  将 dp 数组中其他数据初始化为 ol，即将其他赛道的最小侧条次数初始化为最大
        for (int i = 1; i < ol; i++) {
            Arrays.fill(dp[i], ol);
        }

        for (int i = 1; i < ol; i++) {
            //  现根据与其平行的前一列的赛道的最小侧条次数求当前节点的最小侧条次数
            if (obstacles[i] != 1) {dp[i][0] = dp[i-1][0];}
            if (obstacles[i] != 2) {dp[i][1] = dp[i-1][1];}
            if (obstacles[i] != 3) {dp[i][2] = dp[i-1][2];}
            //  根据同一列的其他节点求出当前节点的最小侧条次数
            if (obstacles[i] != 1) {dp[i][0] = Math.min(dp[i][0], Math.min(dp[i][1], dp[i][2]) + 1);}
            if (obstacles[i] != 2) {dp[i][1] = Math.min(dp[i][1], Math.min(dp[i][0], dp[i][2]) + 1);}
            if (obstacles[i] != 3) {dp[i][2] = Math.min(dp[i][2], Math.min(dp[i][0], dp[i][1]) + 1);}
        }

        //  dp 数组的第 ol - 1 列中的最小值即为该列中任意一条赛道的最小侧条次数
        return Math.min(
                dp[ol-1][0],
                Math.min(
                        dp[ol-1][1],
                        dp[ol-1][2]
                )
        );
    }

    public static void main(String[] args) {
        Third third = new Third();
        int[] obstacles = {0, 1, 2, 3, 0};
//        int[] obstacles = {0,1,1,3,3,0};
        int res = third.minSideJumps(obstacles);
        System.out.println(res);
    }
}
```

## 4 参考文献

1. [1824. 最少侧跳次数](https://leetcode-cn.com/problems/minimum-sideway-jumps)。
2. [DP](https://leetcode-cn.com/problems/minimum-sideway-jumps/solution/dp-by-zhouzzz-8tj2)。




<h1 style='page-break-before: always;'>2.8 设计</h1>

2.9 设计




<h1 style='page-break-before: always;'>2.8.0 实现 Trie (前缀树)</h1>

## 1 题目

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

** 提示：**

* 1 <= word.length, prefix.length <= 2000
* word 和 prefix 仅由小写英文字母组成
* insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

## 2 解题思路

### 2.1 HashMap

#### 2.1.1 问题解析

1. 第一种方法我们可以使用 `HashMap`，使用单词作为 `key`，`value` 默认为 1。
2. 当 `insert` 一个元素时，先判断 `HashMap` 中是否包含该元素，如果不包含的话，则将该元素插入 `HashMap`。
3. 当 `search` 一个元素时，直接看一下 `HashMap` 中是否含有该字符串对应的 `key` 即可。
4. 当判断是否含有一个元素以某个字符串开头时，直接遍历 `HashMap` 的 `key`，看是否含有以该字符串开头的 `key` 即可。

#### 2.1.2 参考代码

```java
/**
 * 208. 实现 Trie (前缀树)（版本 1：HashMap）
 */
class TrieV1 {
    Map<String, Integer> pool;

    /**
     * Initialize your data structure here.
     */
    public TrieV1() {
        pool = new HashMap<>();
    }

    /**
     * Inserts a word into the trie.
     */
    public void insert(String word) {
        if (!pool.containsKey(word)) {
            pool.put(word, 1);
        }
    }

    /**
     * Returns if the word is in the trie.
     */
    public boolean search(String word) {
        return pool.containsKey(word);
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix.
     */
    public boolean startsWith(String prefix) {
        for (String key : pool.keySet()) {
            if (key.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
}
```

### 2.2 TrieNode

#### 2.2.1 问题解析

1. 相比 `HashMap`，更加常规的做法是建立 `TrieNode` 结构节点，具体如下：

```java
package com.grayson.top.domain;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/14 20:50
 * @Description TrieNode 实体类
 */
public class TrieNode {
    public boolean end;
    public TrieNode[] nodes = new TrieNode[26];

    public TrieNode() {
    }
}
```

2. 随着数据的不断插入，根据需要不断创建 `TrieNode` 节点即可。

![IMG_1659.PNG](/media/202104/2021-04-16_214224.png)

#### 2.2.2 参考代码

```java
/**
 * 208. 实现 Trie (前缀树)（版本 2：TrieNode）
 */
class TrieV2 {
    public class TrieNode {
      public boolean end;
      public TrieNode[] nodes = new TrieNode[26];
  
      public TrieNode() {}
    }
  
    TrieNode root;

    /**
     * Initialize your data structure here.
     */
    public TrieV2() {
        root = new TrieNode();
    }

    /**
     * Inserts a word into the trie.
     */
    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); i++) {
            int u = word.charAt(i) - 'a';
            if (p.nodes[u] == null) {p.nodes[u] = new TrieNode();}
            p = p.nodes[u];
        }
        p.end = true;
    }

    /**
     * Returns if the word is in the trie.
     */
    public boolean search(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); i++) {
            int u = word.charAt(i) - 'a';
            if (p.nodes[u] == null) {return false;}
            p = p.nodes[u];
        }
        return p.end;
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix.
     */
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (int i = 0; i < prefix.length(); i++) {
            int u = prefix.charAt(i) - 'a';
            if (p.nodes[u] == null) {return false;}
            p = p.nodes[u];
        }
        return true;
    }
}
```

## 3 参考文献

1. [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree)。
2. [【宫水三叶】一题双解：「二维数组」&amp;「TrieNode」方式](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9)。




<h1 style='page-break-before: always;'>2.8.1 LRU 缓存机制</h1>

## 1 题目

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
**实现 LRUCache 类：**

* LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
* int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
* void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶：** 你是否可以在 O(1) 时间复杂度内完成这两种操作？

**示例：**

```txt
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

* 1 <= capacity <= 3000
* 0 <= key <= 3000
* 0 <= value <= 104
* 最多调用 3 * 104 次 get 和 put

## 2 解题思路

### 2.1 PriorityQueue

#### 2.1.1 问题解析

1. 这种方法是采用 $HashMap$ 和 $PriorityQueue$ 相结合的方式来完成的，其中创建了三个变量，分别为 $map$、$timeMap$、$queue$，其对应的具体含义如下：
   1. $map$：类型为 $HashMap< Integer,String>$，数据格式为 $key:value\_timestamp$，主要用来存储 $key$、$value$ 及其对应的时间戳（当前总的操作次数）。
   2. $timeMap$：类型为 $HashMap< Integer,Integer>$，数据格式为 $timestamp:key$，主要用来存储 $timestamp$、$key$。
   3. $queue$：类型为 $PriorityQueue< Integer>$，数据格式为 $timestamp$，主要用来存储时间戳。
2. 当执行 $get(key)$ 方法时：
   1. 如果 $map$ 中不包含当前 $key$ 时，直接返回 $-1$。
   2. 当 $map$ 中包含当前 $key$ 时：修改 $map$ 中当前 $key$ 对应的 $timestamp$，同时将 $timestamp$ 和 $key$ 对应的存到 $timeMap$ 和 $queue$ 中，然后从 $map$ 中获取其对应的 $value$ 并返回。
   3. 将 $timestamp$ 加 1。
3. 当执行 $put(key,value)$ 时：
   1. 将 $timestamp$ 加 1。
   2. 判断当前 $map$ 的容量是否大于等于 $capacity$：
      1. 如果是的话，则将 $queue$ 中的元素依次弹出，直到弹出的 $\_timestamp$ 不小于当前的 $timestamp$，同时移除 $timeMap$ 中对应的 $timestamp$，然后获取 $timeMap$ 中 $timestamp$ 对应的 $key$，并从 $map$ 中移除对应的 $key$。
      2. 如果否的话，判断当前 $map$ 中是否存在对应的 $key$：
         1. 如果存在的话，更新 $map$ 中对应的 $key$、$value$ 和 $timestamp$，然后将 $key$ 和 $timestamp$ 添加到 $timeMap$ 和 $queue$ 中。
         2. 如果不存在的话，添加 $key$、$value$ 和 $timestamp$ 到 $map$，同时将 $key$ 和 $timestamp$ 添加到 $timeMap$ 和 $queue$ 中。

#### 2.1.2 参考代码

```java
class LRUCache {

    //  容量
    int capacity;
    //  时间戳（每进行任何一次操作都 +1）
    int timestamp = 0;
    //  key:value_timestamp
    Map<Integer, String> map = new HashMap<>();
    //  timestamp:key
    Map<Integer, Integer> timeMap = new HashMap<>();
    //  timestamp
    Queue<Integer> queue = new PriorityQueue<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        timestamp++;
        String[] splits = map.get(key).split("_");
        int value = Integer.parseInt(splits[0]);
        //  修改时间戳
        map.put(key, String.format("%s_%s", value, timestamp));
        timeMap.put(this.timestamp, key);
        queue.add(timestamp);
        return value;
    }

    public void put(int key, int value) {
        timestamp++;
        if (map.size() >= capacity && !map.containsKey(key)) {
            //  如果容量超限：
            //      1. 移除 队列 中时间戳小于当前时间戳的所有元素。
            //      2. 移除 timeMap 中第一步中队列中的时间戳。
            //      3. 移除 前两步时间戳对应的 key。
            while (true) {
                Integer _timestamp = queue.poll();
                Integer _key = timeMap.get(_timestamp);
                timeMap.remove(_timestamp);
                int currTimestamp = Integer.parseInt(map.get(_key).split("_")[1]);
                if (_timestamp < currTimestamp) {
                    continue;
                }
                map.remove(_key);
                break;
            }
        }
        //  添加元素及其对应的时间戳
        map.put(key, String.format("%s_%s", value, timestamp));
        timeMap.put(timestamp, key);
        queue.add(timestamp);
    }
}
```

### 2.2 双链表

#### 2.2.1 问题解析

1. 这种方法采用的是将 $HashMap$ 和 $ 链表 $ 相结合的方式其中：
   1. $HashMap$ 中存储的数据格式为:
      
      $$
      HashMap< Integer,DlinkNode>
      $$
   2. $ 链表 $ 的数据格式为：
      
      ```java
      class DLinkNode {
          int key;
          int value;
          //  前驱结点
          DLinkNode prev;
          //  后驱节点
          DLinkNode next;
      
          DLinkNode() {
          }
      
          DLinkNode(int _key, int _value) {
              this.key = _key;
              this.value = _value;
          }
      }
      ```
2. 当执行 $get(key)$ 方法时：
   1. 如果 $map$ 中不存在当前 $key$，则直接返回-1。
   2. 否则，获取当前 $key$ 对应的节点，并将其移动到链表头部，然后返回当前节点对应的值。
3. 当执行 $put(key,value)$ 方法时：
   1. 如果 $map$ 中的容量大于或等于 $capacity$，并且 $map$ 中不包含当前 $key$，则将尾部节点从链表中删除。
   2. 判断 $map$ 中是否包含当前 $key$：
      1. 如果不包含的话，则根据 $(key,value)$ 创建一个节点，并将当前节点添加到链表头部。
      2. 如果不包含的话，则更新链表中当前 $key$ 对应节点的 $value$，同时将该节点移动到链表头部。

#### 2.2.2 参考代码

```java
class LRUCache {

    class DLinkNode {
        int key;
        int value;
        //  前驱结点
        DLinkNode prev;
        //  后驱节点
        DLinkNode next;

        DLinkNode() {
        }

        DLinkNode(int _key, int _value) {
            this.key = _key;
            this.value = _value;
        }
    }

    //  模仿 链头 和 链尾
    DLinkNode head, tail;
    //  存储 key 及其对应的链表
    Map<Integer, DLinkNode> map = new HashMap<>();

    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        //  初始化链表的头部和尾部
        head = new DLinkNode();
        tail = new DLinkNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        } else {
            //  获取当前 key 对应的节点，并将其移动至链表头部
            DLinkNode node = map.get(key);
            int value = node.value;
            moveToHead(key, node);
            return value;
        }
    }

    public void put(int key, int value) {
        if (map.size() >= capacity && !map.containsKey(key)) {

            //  将链表尾部的节点删除
            DLinkNode tmpNode = tail.prev;
            tmpNode.prev.next = tail;
            tail.prev = tmpNode.prev;
            map.remove(tmpNode.key);
        }
        if (!map.containsKey(key)) {
            //  将当前 key 对应的节点添加到链表头部
            DLinkNode node = new DLinkNode(key, value);
            map.put(key, node);
            addToHead(node);
        } else {
            //  更新当前 key 对应的元素并将其添加到链表头部
            moveToHeadAndUpdateValue(key, value);
        }
    }

    /**
     * 将当前节点添加到链表头部
     * @param node  当前节点
     */
    public void addToHead(DLinkNode node) {
        node.prev = head;
        node.next = head.next;
        head.next = node;
        node.next.prev = node;
    }

    /**
     * 更新当前 key 对应节点的值，然后将该节点移动到链表头部
     * @param key   key
     * @param value value
     */
    public void moveToHeadAndUpdateValue(int key, int value) {
        DLinkNode node = map.get(key);
        node.value = value;
        moveToHead(key, node);
    }

    /**
     * 将当前节点移动到链表头部
     * @param key   key
     * @param node  当前节点
     */
    public void moveToHead(int key, DLinkNode node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;

        head.next.prev = node;
        node.next = head.next;
        node.prev = head;
        head.next = node;
    }
}
```

## 3 参考文献

1. [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache)。
2. [LRU 缓存机制【官方题解】](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution)。




<h1 style='page-break-before: always;'>2.8.2 LFU 缓存</h1>

## 1 题目

请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

实现 LFUCache 类：

LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。
void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。
为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

**示例：**

```txt
输入：
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
输出：
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]解释：
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // 返回 1
// cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
// cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
// cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
// cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
// cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // 返回 4
// cache=[3,4], cnt(4)=2, cnt(3)=3
```

**提示：**

* 0 <= capacity <= 104
* 0 <= key <= 105
* 0 <= value <= 109
* 最多调用 2 * 105 次 get 和 put 方法

## 2 问题分析

1. 首先理解题意：
   1. 当**缓存满的时候**，**需要删除元素**，**具体删除哪些元素**，**由具体的缓存策略来控制**，主要有下面两种缓存策略：
      1. [**LRU**](https://notebook.ricear.com/project-21/doc-329)（Least Recently Used）（**看时间**）：
         1. **在缓存满的时候**，**删除缓存里最久未使用的数据**，**然后再放入新元素**。
         2. **数据的访问时间很重要**，**访问时间距离现在越近**，**就越不容易被删除**。
         3. 该种策略就是**喜新厌旧**，**淘汰在缓存里待的时间最久的元素**，**在删除元素的时候**，**只看时间这一维度**。
      2. **LFU**（Least Frequently Used）（**看访问次数**）：
         1. **在缓存满的时候**，**删除缓存里使用次数最少的元素**，**然后再放入新元素**。
         2. **数据的访问次数很重要**，**访问次数越多**，**就越不容易被删除**。
         3. **在访问次数相同的情况下**，**按照时间顺序**，**先删除在缓存里时间最久的数据**。
         4. 该种策略**在删除策略里多考虑了一个访问次数的维度**，其**核心思想是先考虑访问次数**，**在访问次数相同的情况下**，**再考虑缓存的时间**。
2. 基本思路是：
   1. 由于题目的**时间复杂度要求 $O(1)$**，**空间肯定不能省**，**存取数据时间性能最好的就是哈希表**，因此**底层的数据结构一定是一个哈希表**。
   2. 又由于**缓存大小有限制**，**删除策略是【先看访问频次**，**再看访问时间】**，所以**需要记录每个数据访问的频次**。
   3. 【**删除某个数据**】**得 $O(1)$**，**访问某个数据**，**时间优先级得提前**（**提前到当前批次最高**），**这样的数据结构符合在头尾访问数据最快**，**并且删除前中一个节点也得是 $O(1)$**，**这种数据结构是双向链表**，**双向链表常见的操作是使用两个虚拟节点**，**一个访问头部最快**，**另一个访问尾部最快**，**叫哨兵节点**。
   4. **每次访问一个已经存在的元素时**，**应该先把访问的节点从当前所属的访问次数双链表里删除**，**然后再添加到下一个访问次数的双向链表的头部**。
      ![](../../media/202201/2022-01-09_210322_014109.png)
3. 具体实现：
   1. `get()`：
      1. 首先需要**判断哈希表中是否包含当前 `key`**：
         1. **如果哈希表中包含当前 `key`**：
            1. **获得 `key` 对应的节点**。
            2. **将获得的节点挂接到新的访问次数的双向链表的头部**。
         2. **如果哈希表中不包含当前 `key`**：
            1. **直接返回-1**。
   2. `put()`：
      1. 首先需要**判断哈希表中是否包含当前 `key`**：
         1. **如果哈希表中包含当前 `key`**：
            1. **更新当前 `key` 对应的链表的访问次数 +1**。
            2. **更新 `value`**。
         2. **如果哈希表中不包含当前 `key`**：
            1. **如果哈希表满了**：
               1. **删除访问次数最小的末尾节点**。
               2. **删除哈希表里对应的 `key`**。
            2. **创建新节点**，**放在访问次数为 1 的双向链表的前面**。
            3. **修改全局最小访问次数为 1**。

## 3 参考代码

```java
/**
 * 460. LFU 缓存
 */
class LFUCache {

    /**
     *  key 就是题目中的 key
     *  value 是节点类
     */
    private Map<Integer, ListNode> map;

    /**
     *  访问次数哈希表
     */
    private Map<Integer, DoubleLinkedList> frequentMap;

    /**
     *  外部传入的容量大小
     */
    private Integer capacity;

    /**
     *  全局最低访问次数
     */
    private Integer minFrequent = 1;

    public LFUCache(int capacity) {
        this.map = new HashMap<>();
        this.frequentMap = new HashMap<>();
        this.capacity = capacity;
    }

    /**
     * 获取 key 对应的值
     * @param key   key
     * @return  key 对应的值
     */
    public int get(int key) {
        if (capacity == 0) {return -1;}
        if (map.containsKey(key)) {
            //  哈希表中包含当前 key：
            //      1. 获得 key 对应的节点
            //      2. 将获得的节点挂接到新的访问次数的双向链表的头部
            ListNode listNode = removeListNode(key);
            int frequent = listNode.frequent;
            addListNode2Head(frequent, listNode);
            return listNode.value;
        } else {
            //  哈希表中不包含当前 key
            //  直接返回 -1
            return -1;
        }
    }

    /**
     * 添加元素
     * @param key   key
     * @param value value
     */
    public void put(int key, int value) {
        if (capacity == 0) {return;}
        if (map.containsKey(key)) {
            //  哈希表中包含当前 key：
            //      1. 更新当前 key 对应的链表的访问次数 +1
            //      2. 更新 value
            ListNode listNode = removeListNode(key);
            listNode.value = value;
            int frequent = listNode.frequent;
            addListNode2Head(frequent, listNode);
            return;
        }
        //  哈希表中不包含当前 key：
        //      1. 如果哈希表满了，则：
        //          1.1 删除访问次数最小的末尾节点。
        //          1.2 删除哈希表里对应的 key。
        //      2. 创建新节点，放在访问次数为 1 的双向链表的前面。
        //      3. 修改全局最小访问次数为 1。
        if (map.size() == capacity) {
            DoubleLinkedList doubleLinkedList = frequentMap.get(minFrequent);
            ListNode removeNode = doubleLinkedList.removeTail();
            map.remove(removeNode.key);
        }
        ListNode newListNode = new ListNode(key, value);
        addListNode2Head(1, newListNode);
        map.put(key, newListNode);
        this.minFrequent = 1;
    }

    /**
     * 节点类，是双向链表的组成部分
     */
    private class ListNode {
        private int key;
        private int value;
        private int frequent = 1;
        private ListNode pre;
        private ListNode next;

        public ListNode() {}

        public ListNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    /**
     * 双向链表
     */
    private class DoubleLinkedList {
        /**
         *  虚拟头结点，无前驱结点
         */
        private ListNode dummyHead;
        /**
         *  虚拟尾节点，无后继节点
         */
        private ListNode dummyTail;
        /**
         *  当前双向链表的有效节点数
         */
        private int count;

        private DoubleLinkedList() {
            //  虚拟头尾节点赋值多少无所谓
            this.dummyHead = new ListNode(-1, -1);
            this.dummyTail = new ListNode(-2, -2);
            dummyHead.next = dummyTail;
            dummyTail.pre = dummyHead;
        }

        /**
         *  把一个节点类添加到双向链表的开头（头部是最新使用数据）
         */
        public void addNode2Head(ListNode addNode) {
            ListNode oldHead = dummyHead.next;
            dummyHead.next = addNode;
            oldHead.pre = addNode;
            addNode.pre = dummyHead;
            addNode.next = oldHead;
            count++;
        }

        /**
         *  把双向链表的末尾节点删除（尾部是最旧的数据，在缓存满的时候淘汰）
         */
        public ListNode removeTail() {
            ListNode oldTail = dummyTail.pre;
            ListNode newTail = oldTail.pre;
            newTail.next = dummyTail;
            dummyTail.pre = newTail;
            oldTail.pre = null;
            oldTail.next = null;
            count--;
            return oldTail;
        }
    }

    /**
     *  将原来访问次数的节点，从双向链表里脱离出来
     */
    private ListNode removeListNode(int key) {
        ListNode deleteNode = map.get(key);
        ListNode preNode = deleteNode.pre;
        ListNode nextNode = deleteNode.next;
        preNode.next = nextNode;
        nextNode.pre = preNode;
        deleteNode.pre = null;
        deleteNode.next = null;

        frequentMap.get(deleteNode.frequent).count--;

        if (deleteNode.frequent == minFrequent && frequentMap.get(deleteNode.frequent).count == 0) {
            //  如果当前节点正好在最小访问次数的链表上，并且移除以后节点数为 0，最小访问次数需要 +1
            minFrequent++;
        }

        deleteNode.frequent++;

        return deleteNode;
    }

    /**
     *  把节点放在对应访问次数的双链表的头部
     */
    private void addListNode2Head(int frequent, ListNode addNode) {
        DoubleLinkedList doubleLinkedList;
        if (frequentMap.containsKey(frequent)) {
            doubleLinkedList = frequentMap.get(frequent);
        } else {
            doubleLinkedList = new DoubleLinkedList();
        }
        doubleLinkedList.addNode2Head(addNode);
        frequentMap.put(frequent, doubleLinkedList);
    }
}
```

## 参考文献

1. [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache)。
2. [哈希表 + 双向链表（Java）](https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei)。


</textarea>
                </div>
            <script>
                editormd.markdownToHTML("content", {
                htmlDecode      : "style,script,iframe",
                emoji           : true,  //emoji表情
                taskList        : true,  // 任务列表
                tex             : true,  // 科学公式
                flowChart       : true,  // 流程图
                sequenceDiagram : true,  // 时序图
                tocm            : true, //目录
                toc             :true,
                tocContainer : "#toc-container",
                tocDropdown   : false,
                atLink    : false,//禁用@链接
                plugin_path : '../../static/editor.md/lib/',
    
            });
            $('img.emoji').each(function(){
                var img = $(this);
                if(img[0].src.indexOf("/static/editor.md/")){
                    var src = img[0].src.split('static');
                    img[0].src = '../../static' + src[1];
                }
            })
            </script>
            </body>
            </html>
        